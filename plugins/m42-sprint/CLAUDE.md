# Claude Code Configuration - m42-sprint Plugin

## Learnings

- **Verify context files before declaring preflight complete**: During sprint preflight, context files may already exist from previous runs. Simply checking git status isn't sufficient. In preflight phases: 1) Check if context directory exists, 2) Read existing context files (_shared-context.md, implementation-plan.md), 3) Verify they contain required information, 4) Check git log for preflight commit, 5) Only re-create if missing or incomplete. This prevents duplicate work and ensures context quality.

- **Use worktree-specific paths when referencing sprint context**: Sprint context files live in the worktree-specific directory structure: `trees/<sprint-id>/.claude/sprints/<sprint-id>/context/` and `trees/<sprint-id>/.claude/sprints/<sprint-id>/transcriptions/`. Always use full worktree paths for sprint context. The sprint framework handles this via CWD, but explicit paths prevent confusion.

- **Use "preflight:" prefix for sprint context setup commits**: Sprint phases need to identify when preflight is complete via git log. Preflight commits must use format: "preflight: sprint context prepared". This allows `git log --oneline -1 --grep="^preflight:"` to check completion and creates clear separation between setup and development commits.

- **Delegate codebase research to Explore subagent during preflight**: Sprint preflight phases need to understand project structure, test framework, patterns, and key files before implementation begins. Use Task(subagent_type="Explore") to delegate systematic codebase research. The subagent will methodically explore and return a comprehensive summary. This creates reusable context documents (_shared-context.md and implementation-plan.md) that all subsequent phases can reference.

- **Create _shared-context.md and implementation-plan.md during preflight**: Sprint steps need consistent access to project patterns, file paths, schemas, and the overall implementation strategy. During preflight, create two standardized context files: _shared-context.md (project info, test framework, key paths, patterns, schemas, edge cases) and implementation-plan.md (goals, current problems, architecture, files to create/modify, phases, verification). These become reference documentation for all subsequent sprint phases.

- **Document edge case handling matrix in sprint context**: Complex commands need to handle edge cases gracefully, and all sprint phases should handle them consistently. Create an "Edge Cases to Handle" matrix in _shared-context.md mapping each edge case to its expected response. Include cases like empty input, no content, mechanical tasks, all-filtered results, and duplicates.

- **Structure sprint implementation as creation phases before refactoring**: Refactoring existing code while simultaneously creating new dependencies can lead to broken intermediate states. Order sprint phases so all new components (skills, subagents) are created and tested individually before refactoring the existing command that depends on them. This ensures the refactored command can immediately use validated components.

- **Sprint workflows read from main repo and write to worktree paths**: Sprint workflows in worktree environments must handle two path contexts: 1) Worktree-local paths for current sprint artifacts, modified plugin files, test outputs, 2) Main repo paths for historical sprint data, shared configuration, reference transcripts. Commands should accept absolute paths for inputs (allowing main repo references) while writing outputs to relative paths (landing in current worktree). Preflight checks use CWD-relative paths for targets but accept absolute paths for source data.

- **Sprint tooling phase validates docs match implementation**: After implementing feature changes (like removing depends-on), documentation, commands, and skills need to be reviewed for consistency. Stale references can remain in unrelated files. During sprint tooling phase: 1) Identify affected plugin, 2) Review all commands and skills for stale references using grep/rg, 3) Check that documentation examples match current implementation, 4) Update SKILL.md files to remove deprecated feature references (id, depends-on, parallel execution sections).

- **Version bump must check both committed and uncommitted plugin changes**: When determining which plugin to version bump in a sprint worktree, checking only `git diff main..HEAD` misses uncommitted changes that are part of the sprint work. Example: Branch named `sprint/extract-command-refactor` suggests m42-signs work, but `git diff main..HEAD` only shows m42-sprint commits. The actual m42-signs changes are uncommitted. For comprehensive version bump determination: 1) Check committed changes with `git diff main..HEAD --name-only | grep "^plugins/"`, 2) Check uncommitted changes with `git status --short | grep "plugins/"`, 3) Take union of both results to identify all affected plugins needing version bumps.

- **Phase-2 documentation delegates to parallel Task subagents**: The phase-2_documentation workflow uses the operator pattern - it reads sprint context files (_shared-context.md, implementation-plan.md), analyzes git diff to identify changed files, then spawns multiple parallel Task subagents (one per documentation category: getting-started, user-guide, reference). Each subagent independently updates its assigned documentation and commits changes. This enables parallel processing of independent documentation updates while the coordinator aggregates results into a summary artifact.

- **Sprint context files guide documentation phase strategy**: The documentation phase depends on preflight-created context files to understand what changed and why. It reads _shared-context.md and implementation-plan.md to get the "why" (goals, architecture decisions), then uses git diff against main branch to get the "what" (specific file changes). Combining context + diff enables intelligent documentation updates that explain both the changes and their rationale.

- **Documentation phase creates summary artifact for audit trail**: After subagents complete documentation updates, the phase-2 coordinator creates `artifacts/docs-summary.md` containing: changes analyzed (git diff summary), updates made (grouped by category), commits created (with messages), files modified (with line counts), files NOT changed (with rationale explaining why they were intentionally skipped), and verification checklist. This artifact provides complete transparency into what was updated and why, preventing future confusion about intentional non-changes.

- **Large-scale documentation cleanup requires thorough grep verification**: Removing deprecated features from documentation requires multiple grep passes to ensure completeness. Pattern: 1) Grep for feature name and variations, 2) Read all matches to understand context, 3) Edit files to remove deprecated sections, 4) Grep again for related terms to catch indirect references, 5) Document in summary artifact which files were intentionally NOT changed (e.g., files mentioning "parallel execution" for worktree feature vs removed depends-on feature). Statistics help scope the effort: track files edited, total lines removed per category, and commits created.

- **Distinguish between similar feature names when cleaning documentation**: Some codebases have multiple features with similar names serving different purposes (e.g., "depends-on" step-level dependencies vs "worktree-based parallel execution"). When removing one, grep patterns will match both. Solution: 1) Explicitly identify all similarly-named features upfront, 2) Use targeted edit patterns that remove only the deprecated feature, 3) Verify retained documentation with follow-up greps, 4) Document the distinction in summary artifact's "Files NOT Changed" section. This prevents accidental removal of active feature documentation.

- **Distinguish parallel execution contexts in feature removal**: When removing features with overloaded terminology (like "parallel", "dependency"), create a disambiguation map of legitimate vs deprecated contexts before executing removals. For example, when removing deprecated `depends-on` feature: "parallel sprint execution" refers to worktree isolation (keep), "parallel execution in workflows" means phase-level parallelism (keep), "step dependencies via depends-on" is the deprecated feature (remove). Use this map during grep/search to avoid false positives and preserve correct documentation. This prevents accidentally removing documentation for active features that share similar terminology with the deprecated feature.

