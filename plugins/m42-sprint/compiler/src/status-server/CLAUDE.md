# Claude Code Configuration - m42-sprint/compiler/src/status-server

## Learnings

- **TranscriptionWatcher must extract text blocks from non-streaming assistant messages**: The status page live activity panel was completely missing agent reasoning and output text like "I'll analyze...", "Now I need to...", etc. In transcription-watcher.ts lines 289-301, the non-streaming message handler only extracts tool_use blocks and completely ignores text blocks. This means agent communication is captured in logs but never converted to ActivityEvents. Solution: In parseLine() for non-streaming assistant messages, add text block extraction: check if `block.type === 'text'` and emit ActivityEvent with the text content. This is critical for status page visibility - without it, users can't see what the agent is thinking or planning.

- **Classify Read/Glob/Grep as detailed verbosity to reduce noise at basic level**: At "basic" verbosity level (the default), the live activity panel shows every file read, glob pattern, and grep search. This creates excessive noise that obscures meaningful actions. Users want to see what's happening without drowning in file operations. Solution: Verbosity level classification should be: **Minimal** (always visible): TodoWrite, AskUserQuestion, TaskCreate, TaskUpdate, TaskList, TaskGet, Task, Skill (agent delegation is important). **Basic** (default view): Write, Edit, Bash (actual changes/commands). **Detailed** (verbose mode): Read, Glob, Grep, and all other tools. This keeps the default view focused on progress and decisions, not exploration details.

- **Read large status page file incrementally to understand structure**: The status page file (page.ts) is very large (40k+ tokens). Attempting to read it all at once fails with token limit errors. Reading without a strategy leads to multiple failed attempts. Solution: Use an incremental reading strategy: 1) Start with structure overview (limit: 500 lines) to understand overall organization. 2) Target specific sections using offset (find CSS styles, rendering functions, data handlers). 3) Use Grep for specific patterns instead of reading entire sections. 4) Read around key lines once you find them using offset + limit. This incremental approach was successfully used to add parallel and subprocess indicators to the 5k+ line page.ts file.

- **Status page CSS follows section-based organization with clear boundaries**: When adding new CSS styles to the status page, it's not obvious where to insert them in the 5000+ line file. Solution: The CSS is organized into clearly marked sections: 1) Base & Layout, 2) Phase tree styles (tree-icon, tree-label, tree-children), 3) Phase Action Buttons, 4) Live Activity Panel, 5) Responsive/Mobile styles. When adding new feature styles: insert after related existing styles, add a comment header for the new feature, and group all related styles together (element, states, animations). Responsive styles go at the end in the mobile section. This keeps features cohesive and makes future maintenance easier.

- **Parallel execution indicator requires counting leaf nodes, not all in-progress steps**: When implementing a parallel execution indicator, counting all steps with status=in-progress gives incorrect counts because parent phase nodes can be in-progress while children execute. Users want to know how many ACTUAL steps are executing in parallel. Solution: Implement a recursive leaf node counter that only counts executable steps - if a node has children, recurse into them; if it's a leaf node and in-progress, count it. Use this count to show/hide the parallel indicator (show when count >= 2, hide when count < 2). See page.ts:5217-5231.

- **Subprocess indicators use runtime agent state maps, not PhaseTreeNode interface**: When adding subprocess indicators to show subagent activity, it might seem necessary to add fields to the PhaseTreeNode interface. But PhaseTreeNode represents the workflow structure, not runtime state. Adding runtime fields pollutes the interface. Solution: The status page already tracks runtime agent state in separate maps: `agentStates: Map<agentId, AgentState>` tracks active agents and subagent counts, `stepToAgent: Map<stepId, agentId>` maps steps to their executing agents. Use these existing maps in renderTreeNode to add subprocess indicators without modifying the PhaseTreeNode interface. This keeps the interface clean and focused on structure while still enabling rich runtime visualizations. See page.ts:5347-5395.

- **Status page elements object centralizes DOM references with TypeScript safety**: When adding new dynamic UI elements to the status page, querying DOM elements directly in update functions is inefficient and error-prone. Solution: The status page uses a centralized `elements` object (lines ~3470-3497) that stores all DOM element references after initialization. When adding a new element: 1) Add HTML with a unique ID, 2) Add field to `elements` object with proper TypeScript type, 3) Query and assign in initialization, 4) Use in update functions with null check. This pattern provides type safety and efficient DOM access.

- **Add responsive/mobile CSS overrides at end of stylesheet**: When adding new CSS features with desktop styles, it's easy to forget mobile responsiveness or add mobile styles in the middle where they get overridden. Solution: Follow the CSS cascade pattern: 1) Desktop/base styles in main sections (lines 100-2900), 2) Responsive overrides in dedicated section at end (lines 2915+). When adding a new feature, add desktop styles in appropriate section, then add mobile overrides at the end in the `@media (max-width: 768px)` block. This ensures mobile overrides always take precedence due to cascade order.

- **Build and verify compiled output after TypeScript changes to status page**: The status page is written in TypeScript but served as compiled JavaScript. Changes to page.ts won't take effect until compilation. Solution: After making changes to plugins/m42-sprint/compiler/src/status-server/page.ts, build the compiler with `cd plugins/m42-sprint/compiler && npm run build`, verify compilation succeeded, and optionally verify the compiled output with grep. The build catches TypeScript type errors, syntax errors, missing imports, and interface mismatches. Don't skip this step - the status server uses the compiled dist/ files, not src/.

- **Use Grep to locate specific sections in large status page file**: The status page file (page.ts) is very large (40k+ tokens). When you need to modify a specific function or section, reading the entire file or even large chunks with offset/limit is inefficient and wastes tokens. Solution: Use Grep to search for specific function names or patterns first (e.g., `Grep(pattern: "function getToolDescription", output_mode: "content", -C: 10)`). This shows exact line numbers, surrounding context, and what needs to be changed. Then use Read with offset/limit to get the full function if needed. This pattern was successfully used to locate and modify getToolDescription, renderLiveActivity, and CSS styling sections.

- **Distinguish thinking state from final output in assistant events**: Assistant events can represent thinking/reasoning (streaming text before tool calls) vs final output/response (text after tool calls complete). Without distinction, all assistant text looks the same. Solution: Differentiate these states using visual styling: **Thinking state** (isThinking: true) uses ðŸ’­ icon, dimmed/muted color, animated ellipsis, and `.activity-thinking` CSS class. **Final output** (isThinking: false) uses ðŸ’¬ icon, prominent styling with green background and left border, and `.activity-output` CSS class. This makes it clear what's in-progress vs what's final.

- **Extract meaningful parameters for tool descriptions in live activity**: Tool descriptions in live activity panel show generic tool names like "TaskCreate" without context. Users can't tell what task is being created without clicking into details. Solution: Implement param extraction in transcription-watcher.ts: TaskCreate extracts `subject` ("Creating task: Fix bug X"), TaskUpdate extracts `status` and `subject` ("completed: Fix bug X"), Task extracts `description` ("Delegating: Analyze codebase"), Skill extracts skill name and args ("Running skill: commit -m 'Fix bug'"). This turns generic descriptions into meaningful progress updates.

- **Build compiler after changes to transcription-watcher.ts**: The transcription-watcher.ts file is TypeScript but the status server uses compiled JavaScript. Changes to event extraction, verbosity levels, or param handling won't take effect until compilation. Solution: After making changes to plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts, build the compiler with `cd plugins/m42-sprint/compiler && npm run build` or `cd plugins/m42-sprint && npm run build`. The status server imports from dist/status-server/transcription-watcher.js, not the TypeScript source.

- **Status page feature changes often require coordinating transcription-watcher and page.ts**: When improving status page features, it's tempting to only modify the UI (page.ts) without considering where the data comes from (transcription-watcher.ts). Missing one side makes the feature incomplete. Solution: Status page features typically require coordinated changes with data flow: transcription-watcher.ts â†’ ActivityEvent â†’ page.ts. When adding/improving a feature: 1) **Event Extraction** (transcription-watcher.ts): Parse transcript lines, extract relevant data, create ActivityEvent objects, assign verbosity levels. 2) **Event Rendering** (page.ts): Handle ActivityEvent in renderLiveActivity(), add CSS styling, update DOM elements object, add responsive styles. Both files must be modified and built for the feature to work end-to-end.

- **Use auto-port allocation for parallel sprint execution**: Multiple sprints running simultaneously need dedicated status servers on different ports. Hard-coding port 3100 causes conflicts. Solution: Implement auto-port allocation in server.ts: 1) Update ServerConfig to accept `port: 'auto' | number`, 2) Add findAvailablePort() function that tries ports starting from 3100, 3) Resolve port in start() method before binding, 4) Write .status-port JSON file with { port, pid, startedAt, host }, 5) Remove port file on server stop. Port file enables port discovery for commands like /sprint-watch, checking if server process is alive via PID, and knowing when server started. This architecture supports N parallel sprints, each with a dedicated status server on a unique port. Files: server.ts (implementation), status-types.ts (StatusPortFile interface), index.ts (CLI default to auto).

- **Each sprint gets dedicated status server with single-sprint view**: The old architecture had one central status server with a dashboard showing all sprints and navigation between them. This doesn't work for parallel execution where each sprint runs in an isolated worktree with its own server. Solution: Refactor to single-sprint view architecture: 1) Remove navigation components from page.ts (SprintNavigation interface, generateNavigationBar function, sprint switcher dropdown, nav-bar CSS styles ~116 lines), 2) Simplify routes in server.ts (/ and /dashboard serve main sprint page, /sprint/:id returns error for other sprints, remove generateDashboardPage), 3) Page is self-contained with all data from current sprint's PROGRESS.yaml, 4) Each sprint worktree has .status-port file for its dedicated server. This architecture scales to N parallel sprints because each is completely independent with no shared state or cross-sprint coordination.

- **Classify tools by user-facing impact for verbosity levels**: When implementing verbosity levels for activity feeds, it's not obvious which tools should be "minimal" (always visible) vs "basic" (default) vs "detailed" (verbose). Incorrect classification creates either too much noise or too little visibility. Solution: Classify tools by user-facing impact: **Minimal** (always visible - high-level decisions and interactions): TodoWrite, AskUserQuestion, Task, Skill (agent delegation), TaskCreate/Update/List/Get (progress tracking). **Basic** (default view - actual work): Write, Edit, Bash (commands that modify state). **Detailed** (verbose mode - exploration): Read, Glob, Grep, and all other tools. Rationale: Users want to see *what's being decided and done*, not *how it's being researched*. Exploration is important but creates noise at the default verbosity level.
