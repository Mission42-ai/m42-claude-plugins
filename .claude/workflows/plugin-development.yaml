# Plugin Development Workflow
# Operator-based TDD with subagent delegation
#
# Design principles:
# - Claude acts as OPERATOR, delegating to subagents for actual work
# - Fewer phases, more intelligence per phase
# - RED/GREEN/REFACTOR handled within single development iteration
# - WORKTREE ISOLATION for parallel development

schema-version: "2.0"
name: Plugin Development Workflow
description: |
  Streamlined TDD workflow where Claude operates as an intelligent coordinator.

  **WORKTREE ISOLATION**: Each sprint runs in its own git worktree for parallel development.

  Each development step spawns subagents for:
  - RED: Write failing tests
  - GREEN: Implement to pass tests
  - REFACTOR: Clean up code

  The operator monitors progress, handles failures, and ensures quality.

# Per-iteration hooks run after each development iteration
# Enable in SPRINT.yaml: per-iteration-hooks: { learning: { enabled: true } }
per-iteration-hooks:
  - id: learning
    prompt: /m42-signs:extract $ITERATION_TRANSCRIPT --auto-apply-high
    parallel: true
    enabled: false

# Worktree configuration for isolated parallel development
worktree:
  enabled: true
  branch-prefix: sprint/
  path-prefix: trees/
  cleanup: never

phases:
  # ============================================================================
  # Phase 1: PREFLIGHT
  # Sprint planning and context gathering
  # ============================================================================
  - id: preflight
    prompt: |
      Prepare sprint context and development plan.

      ## Your Role
      You are the sprint OPERATOR. Your job is to:
      1. Understand the sprint scope
      2. Research the codebase
      3. Create shared context for development phases

      ## Step 1: Read Sprint Definition
      Read the SPRINT.yaml to understand:
      - All steps and their requirements
      - Dependencies between steps
      - Overall sprint goal

      ## Step 2: Research Codebase
      Use the Explore subagent to investigate:
      - Project architecture and patterns
      - Test framework and conventions
      - Build/test/lint commands
      - Related existing code

      ## Step 3: Create Shared Context
      Create: context/_shared-context.md

      ```markdown
      # Sprint Context

      ## Project Info
      - Test framework: [vitest/jest/etc]
      - Test location: [pattern]
      - Build command: `[command]`
      - Test command: `[command]`
      - Lint command: `[command]`

      ## Patterns to Follow
      [Key patterns discovered in codebase]

      ## Sprint Steps Overview
      [Brief summary of each step and dependencies]
      ```

      ## Step 4: Commit
      ```bash
      git add context/
      git commit -m "preflight: sprint context prepared"
      ```

  # ============================================================================
  # Phase 2: DEVELOPMENT
  # Operator-driven TDD for each step
  # ============================================================================
  - id: development
    for-each: step
    prompt: |
      ## Your Role: TDD OPERATOR

      You coordinate the TDD cycle by spawning subagents for each phase.

      ## Step Requirements
      {{item.prompt}}

      ## Context
      Read: context/_shared-context.md

      ---

      ## TDD CYCLE: Execute in Order

      ### 1. RED Phase (Write Failing Tests)

      Spawn a subagent to write tests FIRST:

      ```
      Task: RED - Write failing tests for {{item.id}}

      Requirements:
      {{item.prompt}}

      Instructions:
      1. Read context/_shared-context.md for test patterns
      2. Create test file(s) following project conventions
      3. Write 4-8 test cases covering happy path, edge cases, errors
      4. Tests should FAIL (no implementation yet)
      5. Commit: git commit -m "test({{item.id}}): add failing tests [RED]"
      ```

      **Verify RED**: Run tests, confirm they fail (expected).

      ### 2. GREEN Phase (Implement to Pass)

      Spawn a subagent to implement:

      ```
      Task: GREEN - Implement {{item.id}} to pass tests

      Requirements:
      {{item.prompt}}

      Instructions:
      1. Read the test files to understand expected behavior
      2. Implement MINIMAL code to pass all tests
      3. Run tests frequently
      4. Don't optimize - just make tests pass
      5. Commit: git commit -m "feat({{item.id}}): implementation [GREEN]"
      ```

      **Verify GREEN**: Run tests, confirm they ALL pass.

      ### 3. REFACTOR Phase (Clean Up)

      Spawn a subagent to refactor:

      ```
      Task: REFACTOR - Clean up {{item.id}} implementation

      Instructions:
      1. Remove duplication, improve naming
      2. Run tests after EACH change - revert if tests fail
      3. Run lint and fix issues
      4. Commit: git commit -m "refactor({{item.id}}): code cleanup"
      ```

      **Verify REFACTOR**: Run tests + lint + typecheck, all must pass.

      ### 4. INTEGRATION TEST Phase (if needed)

      Determine if this feature requires integration testing:
      - ✅ YES if: spawns external processes, modifies file system state,
        involves async/parallel operations, or inter-process communication
      - ❌ NO if: pure function, simple data transformation, isolated logic

      If YES, spawn an integration test subagent:

      ```
      Task: INTEGRATION - Create end-to-end test for {{item.id}}

      Requirements:
      {{item.prompt}}

      Instructions:
      1. Identify the end-to-end flow to test
      2. Create integration test file: {{item.id}}.integration.test.ts
      3. Test with real dependencies where safe, mocked where necessary
      4. Verify observable outcomes (files created, processes spawned, state changed)
      5. Include teardown to clean up test artifacts
      6. Commit: git commit -m "test({{item.id}}): add integration tests"

      Examples of what to verify:
      - If feature spawns Claude: verify it's invoked with correct args
      - If feature writes files: verify files exist with correct content
      - If feature modifies state: verify state changes are observable
      - If feature runs in parallel: verify non-blocking behavior

      Common Integration Test Patterns:
      - Use test fixtures for file system state
      - Mock external APIs but test real process spawning
      - Verify error handling with real failure scenarios
      - Test transaction/recovery with simulated crashes
      ```

      **Verify INTEGRATION**: Run integration tests, confirm end-to-end flow works.

      ---

      ## OPERATOR DECISIONS

      - If tests fail unexpectedly: retry with more context or spawn fix subagent
      - If implementation incomplete: spawn another GREEN subagent
      - If blocked: escalate to human

      ## Final Output

      Create: artifacts/{{item.id}}-complete.md

      ```markdown
      # Step Complete: {{item.id}}

      ## TDD Cycle
      - RED: [N] tests written
      - GREEN: Implementation complete
      - REFACTOR: Code cleaned

      ## Files Changed
      [List]

      ## Test Coverage
      - Unit tests: [count]
      - Integration tests: [count if applicable]

      ## Status: COMPLETE
      ```

      Commit:
      ```bash
      git add artifacts/{{item.id}}-complete.md
      git commit -m "complete({{item.id}}): TDD cycle finished"
      ```

  # ============================================================================
  # Phase 3: DOCUMENTATION
  # Operator spawns subagents for each doc category
  # ============================================================================
  - id: documentation
    prompt: |
      ## Your Role: Documentation OPERATOR

      Update documentation by spawning subagents for each category.

      ## Step 1: Analyze Changes
      ```bash
      git diff main..HEAD --name-only
      git diff main..HEAD --stat
      ```

      Create a list of what changed and needs documenting.

      ## Step 2: Spawn Subagents (in parallel if independent)

      ### User Guide Subagent
      ```
      Task: Update user guide documentation

      Changes made in this sprint:
      [List relevant changes]

      Instructions:
      1. Find existing user guide (docs/USER-GUIDE.md or docs/user-guide/)
      2. Add/update sections for new features
      3. Update examples if behavior changed
      4. Keep it task-oriented and example-rich
      5. Commit: git commit -m "docs(user-guide): update for sprint changes"

      Skip if: No user-facing feature changes
      ```

      ### Getting Started Subagent
      ```
      Task: Update getting started / quickstart docs

      Changes made in this sprint:
      [List relevant changes]

      Instructions:
      1. Find quickstart docs (README.md, docs/getting-started/)
      2. Update installation steps if changed
      3. Update first-steps examples if affected
      4. Ensure copy-paste commands work
      5. Commit: git commit -m "docs(getting-started): update for sprint changes"

      Skip if: No changes affect onboarding flow
      ```

      ### Reference Docs Subagent
      ```
      Task: Update reference documentation

      Changes made in this sprint:
      [List relevant changes]

      Instructions:
      1. Find reference docs (docs/reference/, API docs)
      2. Update command/function signatures
      3. Update configuration options
      4. Update type definitions
      5. Commit: git commit -m "docs(reference): update for sprint changes"

      Skip if: No API/config/type changes
      ```

      ## Step 3: Verify All Documentation
      - Run code examples from docs to verify they work
      - Check internal links are valid
      - Ensure consistency across all doc updates

      ## Output
      Create: artifacts/docs-summary.md

      ```markdown
      # Documentation Summary

      ## Changes Analyzed
      [What changed in the sprint]

      ## Updates Made
      | Category | Status | Changes |
      |----------|--------|---------|
      | User Guide | Updated/Skipped | [summary] |
      | Getting Started | Updated/Skipped | [summary] |
      | Reference | Updated/Skipped | [summary] |

      ## Verification
      - [ ] Code examples tested
      - [ ] Links validated
      ```

  # ============================================================================
  # Phase 4: TOOLING-UPDATE
  # Update Commands and Skills to reflect implementation changes
  # ============================================================================
  - id: tooling-update
    prompt: |
      ## Your Role: Tooling OPERATOR

      Ensure all Commands and Skills are up-to-date with implementation changes.

      ## Step 1: Identify Affected Plugin
      ```bash
      git diff main..HEAD --name-only | grep "^plugins/" | cut -d'/' -f2 | sort -u
      ```

      ## Step 2: List All Commands and Skills
      For each affected plugin:
      ```bash
      # List commands
      ls plugins/<plugin>/commands/*.md 2>/dev/null

      # List skills
      ls plugins/<plugin>/skills/*.md 2>/dev/null
      ```

      ## Step 3: Analyze Changes
      ```bash
      git diff main..HEAD --name-only
      git diff main..HEAD --stat
      ```

      Determine which Commands/Skills might be affected by the changes.

      ## Step 4: Spawn Review Subagents (in parallel)

      For EACH Command file, spawn a subagent:
      ```
      Task: Review and update Command - <command-name>

      Implementation changes in this sprint:
      [Summary of relevant changes]

      Instructions:
      1. Read the command file: plugins/<plugin>/commands/<command>.md
      2. Compare against current implementation
      3. Check if examples, descriptions, or behavior changed
      4. Update ONLY if necessary - no cosmetic changes
      5. If updated: git commit -m "docs(<command>): sync with implementation"

      Skip if: Command is unaffected by changes
      ```

      For EACH Skill file, spawn a subagent:
      ```
      Task: Review and update Skill - <skill-name>

      Implementation changes in this sprint:
      [Summary of relevant changes]

      Instructions:
      1. Read the skill file: plugins/<plugin>/skills/<skill>.md
      2. Compare against current implementation
      3. Check if triggers, examples, or capabilities changed
      4. Update ONLY if necessary - no cosmetic changes
      5. If updated: git commit -m "docs(<skill>): sync with implementation"

      Skip if: Skill is unaffected by changes
      ```

      ## Step 5: Generate Tooling Report
      Create: artifacts/tooling-update-summary.md

      ```markdown
      # Tooling Update Summary

      ## Commands Reviewed
      | Command | Status | Changes |
      |---------|--------|---------|
      | <name> | Updated/Unchanged | [summary] |

      ## Skills Reviewed
      | Skill | Status | Changes |
      |-------|--------|---------|
      | <name> | Updated/Unchanged | [summary] |

      ## Verification
      - All commands reflect current implementation
      - All skills reflect current capabilities
      ```

      Commit:
      ```bash
      git add artifacts/tooling-update-summary.md
      git commit -m "tooling: commands and skills synced"
      ```

  # ============================================================================
  # Phase 5: VERSION-BUMP
  # Semantic version update with changelog
  # ============================================================================
  - id: version-bump
    prompt: |
      ## Your Role: Version OPERATOR

      Update plugin version based on sprint changes following semantic versioning.

      ## Step 1: Identify Affected Plugin
      ```bash
      git diff main..HEAD --name-only | grep "^plugins/" | cut -d'/' -f2 | sort -u
      ```

      For each affected plugin, perform steps 2-5.

      ## Step 2: Analyze Changes for Version Type

      Examine all changes to determine version bump type:
      ```bash
      git log main..HEAD --oneline
      git diff main..HEAD --stat
      ```

      ### Version Bump Rules (Semantic Versioning)

      **MAJOR (x.0.0)** - Breaking changes:
      - Schema changes that break existing SPRINT.yaml/workflow files
      - Removed commands or required flags
      - Changed behavior that breaks existing usage
      - API changes requiring user migration

      **MINOR (0.x.0)** - New features (backwards compatible):
      - New commands or skills added
      - New optional configuration options
      - New workflow phases or capabilities
      - New validation rules (non-breaking)

      **PATCH (0.0.x)** - Bug fixes and maintenance:
      - Bug fixes
      - Documentation updates only
      - Test additions/fixes
      - Performance improvements
      - Internal refactoring (no API changes)

      ## Step 3: Read Current Version
      ```bash
      cat plugins/<plugin>/.claude-plugin/plugin.json | grep '"version"'
      ```

      Calculate new version based on bump type.

      ## Step 4: Update plugin.json

      Edit `plugins/<plugin>/.claude-plugin/plugin.json`:
      - Update the `version` field to the new version

      ## Step 5: Update CHANGELOG.md

      Create or update `plugins/<plugin>/CHANGELOG.md`:

      ```markdown
      # Changelog

      All notable changes to this plugin will be documented in this file.

      ## [X.Y.Z] - YYYY-MM-DD

      ### Added
      - [New features added in this sprint]

      ### Changed
      - [Changes to existing functionality]

      ### Fixed
      - [Bug fixes]

      ### Removed
      - [Removed features]

      ---
      [Previous versions below...]
      ```

      Guidelines:
      - Use today's date
      - Keep entries concise (one line per change)
      - Group by category (Added/Changed/Fixed/Removed)
      - Only include user-facing changes
      - Reference issue numbers if applicable

      ## Step 6: Commit Version Bump
      ```bash
      git add plugins/<plugin>/.claude-plugin/plugin.json
      git add plugins/<plugin>/CHANGELOG.md
      git commit -m "chore: bump <plugin> version to X.Y.Z"
      ```

      ## Output
      Report version changes made:
      ```
      Version bump: <plugin> v1.2.3 → v1.3.0 (MINOR)
      Reason: Added new for-each collection feature
      ```

  # ============================================================================
  # Phase 6: FINAL-QA
  # Comprehensive quality verification
  # ============================================================================
  - id: final-qa
    prompt: |
      ## Your Role: QA OPERATOR

      Verify the entire sprint meets quality standards.

      ## Step 1: Build Verification
      ```bash
      npm run build
      npm run typecheck
      npm run lint
      ```

      All must pass. If any fail, spawn fix subagent.

      ## Step 2: Full Test Suite
      ```bash
      npm test
      ```

      All tests must pass. Record coverage if available.

      **Integration Test Verification:**
      - [ ] If feature spawns processes: integration test verifies spawning
      - [ ] If feature modifies state: integration test verifies persistence
      - [ ] If feature has async/parallel: integration test verifies timing

      ## Step 3: Review All Step Artifacts
      Read each artifacts/{{item.id}}-complete.md to verify all steps finished.

      ## Step 4: Integration Check
      - Verify modules import correctly
      - Check for circular dependencies
      - Run any integration tests

      ## Step 5: Generate QA Report
      Create: artifacts/sprint-qa-report.md

      ```markdown
      # Sprint QA Report

      ## Build Status
      | Check | Status |
      |-------|--------|
      | Build | PASS/FAIL |
      | TypeCheck | PASS/FAIL |
      | Lint | PASS/FAIL |

      ## Test Results
      - Total: [N]
      - Passed: [N]
      - Failed: [N]
      - Coverage: [%]

      ## Step Verification
      | Step | Status |
      |------|--------|
      | [step-id] | COMPLETE |

      ## Overall: PASS / FAIL
      ```

      ## Handle Failures
      If any check fails:
      1. Spawn fix subagent with specific error details
      2. Re-run verification
      3. If still failing, escalate to human

      Commit:
      ```bash
      git add artifacts/sprint-qa-report.md
      git commit -m "qa: sprint verification complete"
      ```

  # ============================================================================
  # Phase 7: SUMMARY
  # Generate sprint deliverables
  # ============================================================================
  - id: summary
    prompt: |
      Generate sprint summary for PR.

      ## Collect Information
      - Read all artifacts/*-complete.md
      - Read artifacts/sprint-qa-report.md
      - Get commit history: `git log main..HEAD --oneline`
      - Get file changes: `git diff main..HEAD --stat`

      ## Create Summary
      Create: artifacts/sprint-summary.md

      ```markdown
      # Sprint Summary: {{sprint.id}}

      ## Completed Steps
      [For each step: what was accomplished]

      ## Test Coverage
      - Tests added: [N]
      - All tests passing: Yes

      ## Files Changed
      [Summary of changes]

      ## Commits
      [List of commits]

      ## Ready for Review
      - Build: PASS
      - Tests: PASS
      - Lint: PASS
      - Docs: Updated
      ```

      Commit:
      ```bash
      git add artifacts/sprint-summary.md
      git commit -m "docs: sprint summary"
      ```

  # ============================================================================
  # Phase 8: PR-CREATE
  # Push and create pull request
  # ============================================================================
  - id: pr-create
    prompt: |
      Push branch and create pull request.

      ## Step 1: Verify Clean State
      ```bash
      git status
      ```

      ## Step 2: Push Branch
      ```bash
      git push -u origin HEAD
      ```

      ## Step 3: Create PR
      Read artifacts/sprint-summary.md for PR body content.

      ```bash
      gh pr create \
        --title "{{sprint.id}}" \
        --body "$(cat <<'EOF'
      ## Summary
      [Key points from sprint-summary.md]

      ## Changes
      [List major changes]

      ## Verification
      - [x] Build passes
      - [x] All tests pass
      - [x] Lint passes
      - [x] Documentation updated

      ---
      See `artifacts/sprint-summary.md` for full details.
      EOF
      )"
      ```

      ## Step 4: Output PR URL
      ```bash
      gh pr view --json url -q '.url'
      ```
