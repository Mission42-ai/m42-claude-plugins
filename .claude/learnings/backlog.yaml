version: 1
extracted-from: .claude/sprints/2026-01-18_m42-sprint-refactor/transcripts/iteration-5.jsonl
extracted-at: "2026-01-19T09:47:47Z"
reviewed-at: "2026-01-19T10:48:00Z"
reviewed-by: ralph-iteration-22
last-extraction: .claude/sprints/2026-02-01_status-page-fix/transcriptions/phase-4_version-bump.log
last-extraction-at: "2026-02-01T22:30:00Z"
learnings:
  - id: handle-large-files-with-read-tool
    status: applied
    applied-at: "2026-01-19T10:50:00Z"
    applied-in-iteration: 23
    title: Handle large files with Read tool using offset/limit or alternatives
    problem: |
      Reading large files without offset/limit parameters causes token limit errors:
      - Files >25k tokens: "File content exceeds maximum allowed tokens (25000)"
      - Files >40k tokens: Requires more conservative approach

      This occurred across multiple iterations with files like:
      - sprint-loop.sh (25-26k tokens)
      - page.ts (40k tokens)
    solution: |
      When encountering large files, use these strategies:

      1. Use offset and limit parameters to read specific sections:
         - offset: 1, limit: 200 (read from beginning)
         - offset: 690, limit: 150 (read middle section)
         - For very large files (>40k), start with limit: 500 or less

      2. Use Grep tool instead for searching specific content

      3. Read smaller, related files first (e.g., read implement-feature.md instead of sprint-loop.sh when exploring patterns)

      4. If you only need specific sections, use offset to skip to relevant parts
    target: /home/konstantin/projects/CLAUDE.md
    confidence: high
    source:
      tool: Read
      command: Multiple large file reads without offset/limit
      error: File content exceeds maximum allowed tokens
      instances: 5
  - id: fix-read-file-path-for-status-server
    status: rejected
    title: Fix Read file path for status server
    problem: |
      Attempted to read non-existent file: routes.ts
      Error: "<tool_use_error>File does not exist.</tool_use_error>"

      Failed file path: /home/konstantin/projects/m42-claude-plugins/plugins/m42-sprint/compiler/src/status-server/routes.ts
    solution: |
      Corrected to existing file: worktree.ts

      Success file path: /home/konstantin/projects/m42-claude-plugins/plugins/m42-sprint/compiler/src/status-server/worktree.ts

      When working with status server files, verify file names match the actual codebase structure.
    target: home/konstantin/projects/m42-claude-plugins/plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Read
      command: file_path=/home/konstantin/projects/m42-claude-plugins/plugins/m42-sprint/compiler/src/status-server/routes.ts
      error: "<tool_use_error>File does not exist.</tool_use_error>"
    rejection-reason: Too specific - one-time filename mistake, not a generalizable pattern
  - id: handle-read-tool-large-file-with-offset-limit
    status: rejected
    title: Handle Read tool large file with offset/limit
    problem: |
      Attempted to read a large file without using offset/limit parameters.
      File: /home/konstantin/projects/m42-claude-plugins/plugins/m42-sprint/scripts/sprint-loop.sh (26016 tokens)
      Error: "File content (26016 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."
    solution: |
      Instead of reading the entire large file, the agent successfully switched to reading a smaller, more specific file.
      Successful approach: Read /home/konstantin/projects/m42-claude-plugins/plugins/m42-sprint/patterns/implement-feature.md instead.

      When encountering large files:
      1. Use offset and limit parameters to read specific portions
      2. Consider using Grep to search for specific content
      3. If exploring patterns/configs, read smaller related files first
    target: home/konstantin/projects/m42-claude-plugins/plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: Read
      command: file_path=/home/konstantin/projects/m42-claude-plugins/plugins/m42-sprint/scripts/sprint-loop.sh
      error: File content (26016 tokens) exceeds maximum allowed tokens (25000)
    rejection-reason: Consolidated into handle-large-files-with-read-tool
  - id: handle-read-tool-large-file-with-limit
    status: rejected
    title: Handle Read tool large file with limit
    problem: |
      Attempted to read a very large file (page.ts, 40540 tokens) without using offset/limit parameters.
      File: /home/konstantin/projects/m42-claude-plugins/plugins/m42-sprint/compiler/src/status-server/page.ts
      Error: "File content (40540 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."
    solution: |
      Successfully added limit parameter to read only the first portion of the file.
      Successful approach: Added limit: 500 to the Read tool call.

      When encountering large files:
      1. Use limit parameter to read a reasonable number of lines (e.g., 500)
      2. Use offset and limit together to read specific portions
      3. Consider using Grep to search for specific content instead of reading entire file
      4. For very large files (>40k tokens), start with a small limit to avoid token overflow
    target: /home/konstantin/projects/CLAUDE.md
    confidence: medium
    source:
      tool: Read
      command: file_path=/home/konstantin/projects/m42-claude-plugins/plugins/m42-sprint/compiler/src/status-server/page.ts
      error: File content (40540 tokens) exceeds maximum allowed tokens (25000)
    rejection-reason: Consolidated into handle-large-files-with-read-tool
  # Extracted from phase-0_preflight.log (2026-02-01)
  - id: sprint-preflight-uses-explore-agent
    status: applied
    applied-at: "2026-02-01T18:50:39Z"
    applied-by: auto-apply-high
    title: Use Explore agent for comprehensive codebase research in preflight
    problem: |
      Preflight phase needs to understand codebase structure, patterns, test framework, and
      architectural decisions before implementation begins. Direct file reading/grepping is
      inefficient when you need broad understanding of a subsystem.

      This is especially important for complex plugins with multiple directories (runtime,
      compiler, skills, commands) where patterns span across different modules.
    solution: |
      In preflight phase, delegate comprehensive codebase exploration to the Explore agent
      rather than manually reading files:

      Example from this sprint:
      - Task: "Explore m42-sprint codebase to understand structure and patterns"
      - Agent systematically investigated:
        * Test framework setup
        * Directory structure and responsibilities
        * Key architectural patterns (worktree, status server, state machine)
        * Build/test commands

      The Explore agent returns structured findings that can be directly incorporated into
      shared context documents. This is more efficient than sequential file reads.

      Pattern: Preflight -> Explore agent -> Structured context document -> Implementation
    target: plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: Task
      context: Preflight phase delegated codebase exploration to specialized agent
  - id: preflight-creates-shared-context-document
    status: applied
    applied-at: "2026-02-01T18:50:39Z"
    applied-by: auto-apply-high
    title: Create shared context document in preflight for multi-step sprints
    problem: |
      Sprints with multiple development steps run in fresh context for each step. Without
      shared context, each step must rediscover the same architectural patterns, test
      commands, file locations, and dependencies.

      This wastes time and risks inconsistent approaches across steps.
    solution: |
      In preflight phase, after researching the codebase, create a comprehensive
      `context/_shared-context.md` file that includes:

      1. **Project Info**: Test framework, build commands, lint commands
      2. **Key Directories**: Structure and responsibilities
      3. **Architectural Patterns**: Critical patterns each step should follow
         - Example: Fresh context pattern, PROGRESS.yaml state machine
      4. **Sprint Steps Overview**: Brief description of each step's goal
      5. **Dependencies Between Steps**: What order constraints exist
      6. **Testing Approach**: How to verify changes in each area
      7. **Key Files Quick Reference**: Table mapping purpose to file paths

      This document is read at the start of each fresh-context execution step, giving the
      agent all necessary background without re-exploration.

      File location: `.claude/sprints/{sprint-id}/context/_shared-context.md`
    target: plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: Write
      context: Preflight created _shared-context.md after codebase exploration
  - id: preflight-preserves-research-in-context-files
    status: applied
    applied-at: "2026-02-01T18:50:39Z"
    applied-by: auto-apply-high
    title: Preserve detailed analysis in separate context files, not just shared context
    problem: |
      Some sprint steps require deep problem analysis beyond general codebase patterns.
      For example, bug fixes need root cause analysis, proposed solutions, and specific
      code locations to modify.

      Putting all this detail in _shared-context.md makes it too long and unfocused.
    solution: |
      Create step-specific context files alongside _shared-context.md for detailed analysis:

      Example from this sprint:
      - `context/bug-analysis.md` - Deep dive into parallel status tracking bug
        * Root cause with specific line numbers
        * Proposed solution with code snippets
        * Before/after behavior
      - `context/live-activity-analysis.md` - Analysis of verbosity level issues
        * Current behavior table
        * Desired behavior specification
        * Multi-part solution with exact changes

      Step prompts can reference these files: "See context/bug-analysis.md for solution"

      This keeps _shared-context.md focused on general patterns while preserving deep
      analysis for steps that need it.

      File pattern: `.claude/sprints/{sprint-id}/context/{topic}.md`
    target: plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: Write
      context: Preflight created bug-analysis.md and live-activity-analysis.md
  - id: m42-sprint-test-framework-is-custom
    status: applied
    applied-at: "2026-02-01T18:50:39Z"
    applied-by: auto-apply-high
    title: m42-sprint uses custom Node.js test runner, not vitest/jest
    problem: |
      Attempting to use standard test frameworks (vitest, jest) or their conventions when
      working in m42-sprint will fail. The plugin has a custom lightweight test runner.
    solution: |
      Test pattern in m42-sprint:
      ```typescript
      function test(name: string, fn: () => void): void {
        try {
          fn();
          console.log(`✓ ${name}`);
          testsPassed++;
        } catch (error) {
          console.error(`✗ ${name}`);
          process.exitCode = 1;
        }
      }
      ```

      Test locations:
      - `runtime/src/*.test.ts` - Runtime tests
      - `compiler/src/*.test.ts` - Compiler tests
      - `e2e/*.test.ts` - End-to-end tests

      Run tests:
      ```bash
      cd plugins/m42-sprint/runtime && npm test  # Builds + runs all test files
      cd plugins/m42-sprint/compiler && npm test # Builds + runs validate.test.js
      ```

      When writing new tests, follow this lightweight pattern rather than importing test
      frameworks.
    target: plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: Task (Explore agent)
      context: Discovered test framework pattern during codebase exploration
  - id: sprint-worktree-handled-by-runtime-cli
    status: applied
    applied-at: "2026-02-01T18:50:39Z"
    applied-by: auto-apply-high
    title: Worktree setup is handled by runtime CLI setupWorktreeIfNeeded, not command skills
    problem: |
      Command skills like `/run-sprint` might try to manually set up worktrees before
      launching the runtime CLI. This duplicates logic and can use incorrect paths or
      versions.

      The runtime CLI already has comprehensive worktree handling built-in.
    solution: |
      The runtime CLI (`runtime/src/cli.ts`) automatically handles worktree setup via
      `setupWorktreeIfNeeded()` (lines 354-454):

      1. Loads SPRINT.yaml and workflow definition
      2. Calls `shouldCreateWorktree()` to check if worktree is needed
      3. Resolves paths with variable substitution
      4. Creates worktree if needed
      5. Copies sprint files to worktree `.claude/sprints/{sprintId}`
      6. Returns target sprint directory

      Command skills should:
      - Parse arguments
      - Run preflight checks
      - Compile workflow if needed
      - **Launch runtime CLI directly** (which handles worktree internally)
      - Launch status server

      Do NOT duplicate worktree setup logic in command skills.
    target: plugins/m42-sprint/commands/CLAUDE.md
    confidence: high
    source:
      tool: Read
      context: Analysis of run-sprint.md bug and cli.ts worktree handling
  - id: parallel-execution-requires-early-progress-marking
    status: applied
    applied-at: "2026-02-01T18:50:39Z"
    applied-by: auto-apply-high
    title: Mark steps in-progress BEFORE writeProgressAtomic for parallel execution visibility
    problem: |
      When running parallel steps, if you mark them in-progress after writing to disk,
      the status page never sees the in-progress state. Steps appear to jump from pending
      directly to completed.

      This happens because parallel step execution is async - by the time the status page
      reads PROGRESS.yaml, the step might already be done.
    solution: |
      In the parallel execution loop (runtime/src/loop.ts ~lines 1372-1384):

      1. Mark all ready steps as in-progress in the progress data structure
      2. Write progress to disk via writeProgressAtomic
      3. THEN start executing the parallel steps

      This ensures status watchers see the in-progress state before execution completes.

      Example:
      ```typescript
      // Mark steps in-progress
      for (const step of readySteps) {
        scheduler.startStep(step.id);
        currentStep.status = 'in-progress';
        currentStep['started-at'] = new Date().toISOString();
      }

      // Persist state
      await writeProgressAtomic(progressPath, progress);

      // Execute in parallel
      const stepPromises = readySteps.map(step => executeParallelStep(...));
      ```
    target: plugins/m42-sprint/runtime/CLAUDE.md
    confidence: high
    source:
      tool: Write (bug-analysis.md)
      context: Root cause analysis of parallel status tracking bug
  - id: transcription-watcher-text-blocks-bug
    status: applied
    applied-at: "2026-02-01T18:50:39Z"
    applied-by: auto-apply-high
    title: TranscriptionWatcher must extract text blocks from non-streaming assistant messages
    problem: |
      The status page live activity panel was completely missing agent reasoning and output
      text like "I'll analyze...", "Now I need to...", etc.

      In transcription-watcher.ts lines 289-301, the non-streaming message handler only
      extracts tool_use blocks and completely ignores text blocks:
      ```typescript
      if (block.type === 'tool_use') { ... }
      // No handling for block.type === 'text'
      ```

      This means agent communication is captured in logs but never converted to ActivityEvents.
    solution: |
      In parseLine() for non-streaming assistant messages, add text block extraction:

      ```typescript
      if (event.type === 'assistant' && event.message?.content) {
        const content = event.message.content;
        if (Array.isArray(content)) {
          for (const block of content) {
            if (block.type === 'tool_use' && block.id && block.name) {
              // existing tool_use handling
            }
            // NEW: Extract text blocks
            if (block.type === 'text' && block.text) {
              const textEvent: ActivityEvent = {
                ts: timestamp,
                type: 'assistant',
                tool: '',
                level: 'minimal',
                text: block.text,
                isThinking: false,
              };
              this.addToRecentActivity(textEvent);
              this.emit('activity', textEvent);
            }
          }
        }
      }
      ```

      This is critical for status page visibility - without it, users can't see what the
      agent is thinking or planning.
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Write (live-activity-analysis.md)
      context: Root cause analysis of live activity visibility issue
  - id: verbosity-levels-for-noise-reduction
    status: applied
    applied-at: "2026-02-01T18:50:39Z"
    applied-by: auto-apply-high
    title: Classify Read/Glob/Grep as detailed verbosity to reduce noise at basic level
    problem: |
      At "basic" verbosity level (the default), the live activity panel shows every file
      read, glob pattern, and grep search. This creates excessive noise that obscures
      meaningful actions like task updates, agent decisions, and actual code changes.

      Users want to see what's happening without drowning in file operations.
    solution: |
      Verbosity level classification in transcription-watcher.ts should be:

      **Minimal** (always visible):
      - TodoWrite, AskUserQuestion - User interaction
      - TaskCreate, TaskUpdate, TaskList, TaskGet - Task tracking
      - Task, Skill - Agent delegation (important architectural events)

      **Basic** (default view):
      - Write, Edit, Bash - Actual changes/commands

      **Detailed** (verbose mode):
      - Read, Glob, Grep - File exploration
      - All other tools

      This keeps the default view focused on progress and decisions, not exploration details.

      Implementation:
      ```typescript
      function getToolVerbosityLevel(toolName: string): VerbosityLevel {
        const minimalTools = ['TodoWrite', 'AskUserQuestion', 'TaskCreate',
                              'TaskUpdate', 'TaskList', 'TaskGet', 'Task', 'Skill'];
        if (minimalTools.includes(toolName)) return 'minimal';

        const basicTools = ['Write', 'Edit', 'Bash'];
        if (basicTools.includes(toolName)) return 'basic';

        return 'detailed'; // Everything else including Read/Glob/Grep
      }
      ```
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Write (live-activity-analysis.md)
      context: Analysis of verbosity level assignments and desired behavior
  - id: runtime-cli-handles-worktree-setup
    status: applied
    title: Runtime CLI handles worktree setup automatically
    problem: |
      When creating commands that launch the sprint runtime, it's tempting to implement
      worktree setup logic in the command itself. This leads to duplicate logic that can
      drift out of sync with the runtime implementation.

      The outdated run-sprint.md had 95 lines (77-171) of manual worktree setup that:
      - Loaded workflow definitions
      - Checked worktree config
      - Created branches and worktrees
      - Copied sprint files
      - This duplicated logic already in runtime/src/cli.ts:354-454
    solution: |
      The runtime CLI (plugins/m42-sprint/runtime/src/cli.ts) has a `setupWorktreeIfNeeded()`
      function that handles ALL worktree logic automatically:

      - Called at line 485: `const actualSprintDir = await setupWorktreeIfNeeded(parsed.directory)`
      - Returns the actual sprint directory to use (worktree or original)
      - Handles: checking config, creating branches, creating worktrees, copying files

      Commands should simply pass the sprint directory to the runtime CLI and let it handle
      worktree setup internally. Do NOT duplicate this logic in commands.

      Correct pattern:
      ```bash
      node "${CLAUDE_PLUGIN_ROOT}/runtime/dist/cli.js" run "$SPRINT_DIR" [options]
      ```

      The runtime CLI is the single source of truth for worktree management.
    target: /home/koni/projects/m42-claude-plugins/plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Removed 95 lines of duplicate worktree logic from run-sprint.md
    applied-at: "2026-02-01T18:50:11Z"
  - id: investigate-before-prescribing-solutions
    status: applied
    title: Investigate codebase thoroughly before prescribing solutions
    problem: |
      When tasked with fixing or refactoring, it's easy to jump to solutions without
      fully understanding the current implementation. This can lead to fixing the wrong
      thing or missing the root cause.

      In this transcript, the agent started by reading the command file, encountered an
      error reading the runtime file (wrong path), corrected the path using Glob, then
      read the runtime implementation to understand how it actually works.
    solution: |
      Follow this investigation pattern:

      1. Read the file that needs fixing
      2. Identify what seems wrong or outdated
      3. Search for related implementations (use Glob to find correct paths)
      4. Read the actual implementation to understand current behavior
      5. Compare command's assumptions with implementation's reality
      6. Only then decide what needs to change

      The agent's reasoning in block 3 demonstrates this:
      "Now I have a clear understanding of the situation:
       1. Runtime CLI behavior (cli.ts:483-492): [describes what it does]
       2. Current run-sprint.md problem: [describes the duplication]
       The fix is to remove the entire section..."

      This shows understanding BEFORE prescribing the solution.
    target: /home/koni/projects/m42-claude-plugins/CLAUDE.md
    confidence: high
    source:
      tool: Read
      context: Read sequence that built understanding before making changes
    applied-at: "2026-02-01T18:50:11Z"
  - id: tool-sequence-file-not-found-to-glob-to-success
    status: pending
    title: Use Glob to find correct paths after file-not-found errors
    problem: |
      When reading a file that doesn't exist at the expected path, it's inefficient to
      guess alternative paths. This happened with runtime/src/cli.ts - the first attempt
      used a wrong path assumption.

      Error: "<tool_use_error>File does not exist.</tool_use_error>"
      Failed path: /home/koni/projects/m42-claude-plugins/trees/2026-02-01_status-page-fix/runtime/src/cli.ts
    solution: |
      When encountering file-not-found errors:

      1. Use Glob with pattern matching to find the actual location:
         `Glob(pattern: "**/runtime/src/cli.ts")`

      2. Glob returns the correct path:
         `/home/koni/projects/m42-claude-plugins/trees/2026-02-01_status-page-fix/plugins/m42-sprint/runtime/src/cli.ts`

      3. Read the file using the correct path

      This is faster than guessing paths and ensures you find the file even when directory
      structure doesn't match expectations.
    target: /home/koni/projects/m42-claude-plugins/CLAUDE.md
    confidence: medium
    source:
      tool: Glob
      context: Used after Read file-not-found error to locate cli.ts
  - id: explain-reasoning-in-text-blocks
    status: pending
    title: Explain architectural discoveries in text blocks before editing
    problem: |
      When making changes to fix duplication or refactor code, it's valuable to explain
      WHY the change is needed. This helps future readers (humans and agents) understand
      the rationale.

      The transcript shows good practice: reasoning block 3 explains the full situation
      before any edits are made.
    solution: |
      Before making significant edits, output a text block that:

      1. Describes what you discovered about current behavior
      2. Explains what the problem is (e.g., duplication, outdated assumptions)
      3. States the fix clearly

      Example from transcript (reasoning block 3):
      "Now I have a clear understanding of the situation:

      1. **Runtime CLI behavior**: When `run` command is called, it calls
         `setupWorktreeIfNeeded()` which handles ALL worktree logic automatically

      2. **Current run-sprint.md problem**: Lines 77-171 contain a section that
         duplicates all this logic

      The fix is to remove the entire 'Worktree Setup' section since the runtime
      CLI handles this internally."

      This makes the change self-documenting and easier to review.
    target: /home/koni/projects/m42-claude-plugins/CLAUDE.md
    confidence: medium
    source:
      tool: text
      context: Reasoning blocks that explained discoveries before edits
  - id: parallel-step-status-persistence-timing
    status: applied
    title: Write progress to disk AFTER marking parallel steps as in-progress
    problem: |
      When executing parallel steps, the status page doesn't show steps transitioning to `in-progress` - they jump directly from `pending` to `completed`.

      This happens because in executeParallelStep (loop.ts:~1180), the progress is written to disk BEFORE marking ready steps as `in-progress`. The sequence was:
      1. Write progress to disk (line 1379)
      2. Mark steps as in-progress (in-memory only, line 1180)
      3. Execute steps
      4. Mark steps as completed and write progress

      Result: Status page never sees the in-progress state.
    solution: |
      Update the progress object to mark steps as `in-progress` (with `started-at` timestamp) BEFORE writing to disk:

      1. For each ready step, mark as `in-progress` in progress.phases[phaseId].steps[stepIndex]
      2. If step has sub-phases, mark first sub-phase as `in-progress`
      3. THEN write progress to disk
      4. Execute the parallel steps

      This ensures the status page sees state transitions in the correct order.

      File: plugins/m42-sprint/runtime/src/loop.ts lines 1372-1396
    target: /home/koni/projects/m42-claude-plugins/plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Bug fix for status page not showing parallel step in-progress states
    applied-at: "2026-02-01T18:50:51Z"
  - id: ready-step-structure-and-indexing
    status: applied
    title: ReadyStep references step by phaseId and stepIndex
    problem: |
      When working with parallel execution in the sprint runtime, it's not obvious how ReadyStep objects relate to the progress data structure.

      The ReadyStep interface (in scheduler.ts) only has `id`, `phaseId`, and `stepIndex` - but how do you use these to access the actual step data?
    solution: "ReadyStep provides indexes into the progress structure:\n\n- ReadyStep.phaseId: Index into progress.phases array\n- ReadyStep.stepIndex: Index into progress.phases[phaseId].steps array\n- Access step: progress.phases[readyStep.phaseId].steps[readyStep.stepIndex]\n\nExample:\n```typescript\nreadySteps.forEach(readyStep => {\n  const step = progress.phases[readyStep.phaseId].steps[readyStep.stepIndex];\n  step.status = 'in-progress';\n  step['started-at'] = new Date().toISOString();\n});\n```\n\nFiles: \n- plugins/m42-sprint/runtime/src/scheduler.ts (ReadyStep interface)\n- plugins/m42-sprint/runtime/src/loop.ts (usage)\n"
    target: /home/koni/projects/m42-claude-plugins/plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: Read
      context: Understanding ReadyStep structure while fixing parallel execution bug
    applied-at: "2026-02-01T18:50:51Z"
  - id: runtime-build-required-for-loop-changes
    status: applied
    title: Build runtime after TypeScript changes to loop.ts
    problem: |
      After making TypeScript changes to files in plugins/m42-sprint/runtime/src/, the sprint loop may use old compiled JavaScript if you don't rebuild.

      Error pattern: "tsc: not found" when running `npm run build` in the runtime directory.
    solution: |
      Always run the build command from the plugin ROOT directory (plugins/m42-sprint/), not the runtime subdirectory:

      ```bash
      cd plugins/m42-sprint
      npm run build
      ```

      The sprint loop executes the compiled JavaScript in plugins/m42-sprint/runtime/dist/, so TypeScript changes in src/ won't take effect until compilation.

      Alternative: Use the npm workspace command from repo root:
      ```bash
      npm run build -w @m42/sprint-runtime
      ```
    target: /home/koni/projects/m42-claude-plugins/plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: Bash
      context: Build error when trying to verify TypeScript changes to loop.ts
    applied-at: "2026-02-01T18:50:51Z"
  # Extracted from phase-1_step-2_execute.log (2026-02-01)
  - id: status-page-read-large-file-incrementally
    status: applied
    applied-at: "2026-02-01T19:56:05+01:00"
    applied-by: auto-apply-high
    title: Read large status page file incrementally to understand structure
    problem: |
      The status page file (page.ts) is very large (40k+ tokens). Attempting to read it
      all at once fails with token limit errors. But you need to understand the structure
      to add features like parallel execution indicators and subprocess badges.

      Reading without a strategy leads to multiple failed attempts and wasted tokens.
    solution: |
      Use an incremental reading strategy when working with large UI files:

      1. **Start with structure overview** (limit: 500 lines)
         - Read beginning to understand overall organization
         - Identify major sections: HTML, CSS, JavaScript

      2. **Target specific sections** using offset
         - Find CSS styles: Look for <style> tag location
         - Find rendering functions: Search for specific function names
         - Find data handlers: Look for update* functions

      3. **Use Grep for specific patterns** instead of reading entire sections
         - Example: Grep for "tree-icon" to find icon CSS
         - Example: Grep for "renderTreeNode" to find rendering logic

      4. **Read around key lines** once you find them
         - Use offset + limit to read context around discovered locations

      This incremental approach was successfully used in this transcript to add parallel
      and subprocess indicators to the 5k+ line page.ts file.
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Read
      context: Multiple incremental reads to understand and modify large page.ts file
  - id: status-page-css-organization-pattern
    status: applied
    applied-at: "2026-02-01T19:56:05+01:00"
    applied-by: auto-apply-high
    title: Status page CSS follows section-based organization with clear boundaries
    problem: |
      When adding new CSS styles to the status page, it's not obvious where to insert them.
      Inserting in the wrong place can break existing styles or make the file harder to
      maintain.

      The page.ts file has 5000+ lines with CSS embedded in a <style> tag.
    solution: |
      The status page CSS is organized into clearly marked sections with comments:

      1. Base & Layout
      2. Phase tree styles (tree-icon, tree-label, tree-children)
      3. Phase Action Buttons
      4. Live Activity Panel
      5. Responsive/Mobile styles

      When adding new feature styles:
      - Insert after related existing styles
      - Add a comment header for the new feature
      - Group all related styles together (element, states, animations)

      Example from transcript:
      - New parallel indicator styles added after tree-children.collapsed
      - New subprocess indicator styles added in same section
      - Both got clear comment headers
      - Responsive styles added to mobile section at end

      This keeps features cohesive and makes future maintenance easier.

      File: plugins/m42-sprint/compiler/src/status-server/page.ts lines 100-3000
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: CSS insertion strategy for parallel and subprocess indicators
  - id: status-page-parallel-indicator-pattern
    status: applied
    applied-at: "2026-02-01T19:56:05+01:00"
    applied-by: auto-apply-high
    title: Parallel execution indicator requires counting leaf nodes, not all in-progress steps
    problem: |
      When implementing a parallel execution indicator, it's tempting to count all steps
      with status=in-progress. But this gives incorrect counts because:

      - Parent phase nodes can be in-progress while children execute
      - Sub-phases can be in-progress without being actual parallel work
      - The count would show "5 parallel" when only 2 actual steps are running

      Users want to know how many ACTUAL steps are executing in parallel.
    solution: |
      Implement a recursive leaf node counter that only counts executable steps:

      ```typescript
      function countInProgressLeafNodes(nodes: PhaseTreeNode[]): number {
        let count = 0;
        for (const node of nodes) {
          if (node.status === 'in-progress') {
            if (node.children && node.children.length > 0) {
              // Parent node - recurse into children
              count += countInProgressLeafNodes(node.children);
            } else {
              // Leaf node - this is an actual executing step
              count += 1;
            }
          }
        }
        return count;
      }
      ```

      Use this count to show/hide the parallel indicator:
      - Show when count >= 2 (actual parallel execution)
      - Hide when count < 2 (sequential or idle)

      File: plugins/m42-sprint/compiler/src/status-server/page.ts lines 5217-5231
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Implementation of countInProgressLeafNodes for accurate parallel counting
  - id: status-page-subprocess-indicator-uses-runtime-state
    status: applied
    applied-at: "2026-02-01T19:56:05+01:00"
    applied-by: auto-apply-high
    title: Subprocess indicators use runtime agent state maps, not PhaseTreeNode interface
    problem: |
      When adding subprocess indicators to show subagent activity, it might seem necessary
      to add fields to the PhaseTreeNode interface (like `hasSubprocess` or `subagentCount`).

      But PhaseTreeNode represents the workflow structure, not runtime state. Adding
      runtime fields pollutes the interface and requires changes across multiple files.
    solution: |
      The status page already tracks runtime agent state in separate maps:

      - `agentStates: Map<agentId, AgentState>` - Tracks active agents and subagent counts
      - `stepToAgent: Map<stepId, agentId>` - Maps steps to their executing agents

      Use these existing maps in renderTreeNode to add subprocess indicators:

      ```typescript
      function renderTreeNode(node: PhaseTreeNode): string {
        // Check runtime state without modifying PhaseTreeNode interface
        const agentId = stepToAgent.get(node.id);
        const agentState = agentId ? agentStates.get(agentId) : null;
        const hasSubprocess = agentState && agentState.subagentCount > 0;

        if (hasSubprocess) {
          // Add subprocess indicator and styling
        }
      }
      ```

      This keeps the PhaseTreeNode interface clean and focused on structure while still
      enabling rich runtime visualizations.

      File: plugins/m42-sprint/compiler/src/status-server/page.ts lines 5347-5395
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Subprocess indicator implementation using existing runtime state
  - id: status-page-elements-object-pattern
    status: applied
    applied-at: "2026-02-01T19:56:05+01:00"
    applied-by: auto-apply-high
    title: Status page elements object centralizes DOM references with TypeScript safety
    problem: |
      When adding new dynamic UI elements to the status page, it's not obvious where to
      register them for script access. Querying DOM elements directly in update functions
      is inefficient and error-prone.

      The status page has many dynamic elements that need to be updated frequently.
    solution: |
      The status page uses a centralized `elements` object (lines ~3470-3497) that stores
      all DOM element references after initialization:

      ```typescript
      const elements = {
        sidebar: null as HTMLElement | null,
        phaseTree: null as HTMLElement | null,
        liveActivity: null as HTMLElement | null,
        // ... other elements
      };
      ```

      When adding a new element:

      1. Add HTML with a unique ID
      2. Add field to `elements` object with proper TypeScript type
      3. Query and assign in initialization: `elements.newElement = doc.getElementById('new-id')`
      4. Use in update functions: `if (elements.newElement) { ... }`

      Example from transcript:
      ```typescript
      // 1. HTML
      <div class="parallel-indicator hidden" id="parallel-indicator"></div>

      // 2. Add to elements object
      parallelIndicator: null as HTMLElement | null,

      // 3. Initialize
      elements.parallelIndicator = doc.getElementById('parallel-indicator');

      // 4. Use in updates
      if (elements.parallelIndicator) {
        elements.parallelIndicator.textContent = `⟂ ${count} parallel`;
      }
      ```

      This pattern provides type safety and efficient DOM access.
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Adding parallelIndicator element to elements object
  - id: status-page-responsive-styles-last
    status: applied
    applied-at: "2026-02-01T19:56:05+01:00"
    applied-by: auto-apply-high
    title: Add responsive/mobile CSS overrides at end of stylesheet
    problem: |
      When adding new CSS features with desktop styles, it's easy to forget mobile
      responsiveness. Or worse, add mobile styles in the middle of the stylesheet where
      they get overridden by later desktop styles.

      The status page needs to work on various screen sizes.
    solution: |
      Follow the CSS cascade pattern already established in page.ts:

      1. Desktop/base styles in main sections (lines 100-2900)
      2. Responsive overrides in dedicated section at end (lines 2915+)

      When adding a new feature:
      - Add desktop styles in appropriate section
      - Add mobile overrides at the end in the `@media (max-width: 768px)` block

      Example from transcript:
      ```css
      /* Desktop styles added in main section */
      .parallel-indicator {
        font-size: 0.9rem;
        padding: 4px 12px;
      }

      /* Mobile overrides added at end */
      @media (max-width: 768px) {
        .parallel-indicator {
          font-size: 0.75rem;
          padding: 2px 8px;
        }
      }
      ```

      This ensures mobile overrides always take precedence due to cascade order.

      File: plugins/m42-sprint/compiler/src/status-server/page.ts
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Added mobile responsive styles for parallel and subprocess indicators
  - id: status-page-build-verification-after-typescript-changes
    status: applied
    applied-at: "2026-02-01T19:56:05+01:00"
    applied-by: auto-apply-high
    title: Build and verify compiled output after TypeScript changes to status page
    problem: |
      The status page is written in TypeScript but served as compiled JavaScript. Changes
      to page.ts won't take effect until compilation, and TypeScript errors won't appear
      until build time.

      It's easy to make changes and assume they work without verifying compilation.
    solution: |
      After making changes to plugins/m42-sprint/compiler/src/status-server/page.ts:

      1. Build the compiler:
         ```bash
         cd plugins/m42-sprint/compiler
         npm run build
         ```

      2. Verify compilation succeeded (exit code 0)

      3. Optionally verify the compiled output:
         ```bash
         # Check that changes appear in compiled JavaScript
         grep "parallel-indicator" plugins/m42-sprint/compiler/dist/status-server/page.js
         ```

      The build catches:
      - TypeScript type errors
      - Syntax errors
      - Missing imports
      - Interface mismatches

      Don't skip this step - the status server uses the compiled dist/ files, not src/.

      File: plugins/m42-sprint/compiler/package.json (build script)
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Bash
      context: Build verification after implementing parallel and subprocess indicators
  # Extracted from phase-1_step-3_execute.log (2026-02-01)
  - id: status-page-use-grep-for-targeted-reading
    status: applied
    applied-at: "2026-02-01T18:57:35Z"
    applied-by: auto-apply-high
    title: Use Grep to locate specific sections in large status page file
    problem: |
      The status page file (page.ts) is very large (40k+ tokens). When you need to modify
      a specific function or section, reading the entire file or even large chunks with
      offset/limit is inefficient and wastes tokens.

      For example, finding the `getToolDescription` function or `renderLiveActivity` function
      in a 5000+ line file.
    solution: |
      Use Grep to search for specific function names or patterns first:

      ```bash
      # Find function definition
      Grep(pattern: "function getToolDescription", path: "page.ts", output_mode: "content", -C: 10)

      # Find CSS class usage
      Grep(pattern: "activity-thinking", path: "page.ts", output_mode: "content")
      ```

      This shows you:
      1. Exact line numbers where the code exists
      2. Surrounding context (-C flag)
      3. What needs to be changed

      Then use Read with offset/limit to get the full function if needed:
      ```
      Read(file_path: "page.ts", offset: 2890, limit: 50)
      ```

      This pattern was successfully used in this transcript to locate and modify:
      - getToolDescription function
      - renderLiveActivity function
      - CSS styling sections

      File: plugins/m42-sprint/compiler/src/status-server/page.ts
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Grep
      context: Used to locate specific functions in large page.ts file before modifications
  - id: status-page-assistant-event-thinking-vs-output
    status: applied
    applied-at: "2026-02-01T18:57:35Z"
    applied-by: auto-apply-high
    title: Distinguish thinking state from final output in assistant events
    problem: |
      Assistant events can represent different states:
      - Thinking/reasoning while processing (streaming text before tool calls)
      - Final output/response (text after tool calls complete)

      Without distinction, all assistant text looks the same in the status page, making
      it hard to see what's in-progress vs what's final.
    solution: "The status page can differentiate these states using visual styling:\n\n**Thinking state** (isThinking: true):\n- Icon: \U0001F4AD (thought bubble)\n- Styling: Dimmed/muted color\n- Animation: Animated ellipsis to show ongoing process\n- CSS class: `.activity-thinking`\n\n**Final output** (isThinking: false):\n- Icon: \U0001F4AC (speech bubble)\n- Styling: Prominent with green background and left border\n- CSS class: `.activity-output`\n\nImplementation pattern:\n```typescript\nconst textEvent: ActivityEvent = {\n  ts: timestamp,\n  type: 'assistant',\n  tool: '',\n  level: 'minimal',\n  text: block.text,\n  isThinking: false, // Set based on context\n};\n```\n\nCSS distinguishes the states:\n```css\n.activity-thinking {\n  opacity: 0.7;\n  font-style: italic;\n}\n.activity-output {\n  background: #e8f5e9;\n  border-left: 3px solid #4caf50;\n}\n```\n\nFile: plugins/m42-sprint/compiler/src/status-server/page.ts\n"
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Enhanced assistant event display with thinking vs final output differentiation
  - id: status-page-tool-description-param-extraction
    status: applied
    applied-at: "2026-02-01T18:57:35Z"
    applied-by: auto-apply-high
    title: Extract meaningful parameters for tool descriptions in live activity
    problem: |
      Tool descriptions in live activity panel show generic tool names like "TaskCreate"
      or "TaskUpdate" without context. Users can't tell what task is being created or
      what status it's being updated to without clicking into details.

      Generic descriptions create noise instead of meaningful progress updates.
    solution: |
      Implement param extraction in transcription-watcher.ts to show meaningful descriptions:

      **TaskCreate**: Extract `subject`
      - Instead of: "TaskCreate"
      - Show: "Creating task: Fix bug X"

      **TaskUpdate**: Extract `status` and `subject`
      - Instead of: "TaskUpdate"
      - Show: "completed: Fix bug X" or "in-progress: Add feature Y"

      **Task**: Extract `description`
      - Instead of: "Task"
      - Show: "Delegating: Analyze codebase"

      **Skill**: Extract skill name and args
      - Instead of: "Skill"
      - Show: "Running skill: commit -m 'Fix bug'"

      Implementation pattern in extractParams():
      ```typescript
      function extractParams(toolName: string, params: any): string {
        switch (toolName) {
          case 'TaskCreate':
            return params.subject || '';
          case 'TaskUpdate':
            return params.status && params.subject
              ? `${params.status}: ${params.subject}`
              : '';
          case 'Task':
            return params.description || '';
          case 'Skill':
            return params.skill && params.args
              ? `${params.skill} ${params.args}`
              : params.skill || '';
        }
      }
      ```

      Then use in getToolDescription():
      ```typescript
      if (params) {
        return `${toolName}: ${params}`;
      }
      ```

      File: plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Added param extraction for meaningful tool descriptions in live activity
  - id: status-page-build-after-transcription-watcher-changes
    status: applied
    applied-at: "2026-02-01T18:57:35Z"
    applied-by: auto-apply-high
    title: Build compiler after changes to transcription-watcher.ts
    problem: |
      The transcription-watcher.ts file is TypeScript but the status server uses compiled
      JavaScript. Changes to event extraction, verbosity levels, or param handling won't
      take effect until compilation.

      This is easy to overlook because transcription-watcher.ts is deep in the compiler
      source tree.
    solution: |
      After making changes to plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts:

      1. Build the compiler from the compiler directory:
         ```bash
         cd plugins/m42-sprint/compiler
         npm run build
         ```

      2. Or build from plugin root:
         ```bash
         cd plugins/m42-sprint
         npm run build
         ```

      3. Verify compilation succeeded

      The status server imports from dist/status-server/transcription-watcher.js, not the
      TypeScript source. Changes to event parsing, activity filtering, or param extraction
      require a rebuild to take effect.

      Related: Any changes to files in compiler/src/status-server/ require compilation.
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Bash
      context: Built compiler after implementing text block extraction and param handling
  - id: status-page-multi-file-coordinated-changes
    status: applied
    applied-at: "2026-02-01T18:57:35Z"
    applied-by: auto-apply-high
    title: Status page feature changes often require coordinating transcription-watcher and page.ts
    problem: |
      When improving status page features, it's tempting to only modify the UI (page.ts)
      without considering where the data comes from (transcription-watcher.ts).

      For example, adding assistant text display requires BOTH:
      - Event extraction in transcription-watcher.ts
      - Event rendering in page.ts

      Missing one side makes the feature incomplete.
    solution: "Status page features typically require coordinated changes:\n\n**Data flow**: transcription-watcher.ts → ActivityEvent → page.ts\n\nWhen adding/improving a feature:\n\n1. **Event Extraction** (transcription-watcher.ts):\n   - Parse transcript lines\n   - Extract relevant data\n   - Create ActivityEvent objects\n   - Assign verbosity levels\n\n2. **Event Rendering** (page.ts):\n   - Handle ActivityEvent in renderLiveActivity()\n   - Add CSS styling for new event types\n   - Update DOM elements object if needed\n   - Add responsive styles\n\nExample from this transcript:\n- Feature: Show assistant thinking vs final output\n- transcription-watcher.ts: Extract text blocks, add isThinking field\n- page.ts: Different icons (\U0001F4AD vs \U0001F4AC), different CSS classes\n\nBoth files must be modified and built for the feature to work end-to-end.\n\nFiles:\n- plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts\n- plugins/m42-sprint/compiler/src/status-server/page.ts\n"
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Coordinated changes across transcription-watcher and page for assistant events
  # Extracted from phase-1_step-4_execute.log (2026-02-01)
  - id: status-server-auto-port-allocation
    status: applied
    applied-at: "2026-02-01T20:04:54+01:00"
    applied-by: auto-apply-high
    title: Use auto-port allocation for parallel sprint execution
    problem: |
      Multiple sprints running simultaneously need dedicated status servers on different ports.
      Hard-coding port 3100 causes conflicts when running parallel sprints.

      Operators need a way to:
      - Launch multiple sprint servers without port conflicts
      - Discover which port each sprint's server is using
      - Know if a server is still running
    solution: |
      Implement auto-port allocation in the status server (server.ts):

      1. **Add 'auto' port option**: Update ServerConfig to accept `port: 'auto' | number`
      2. **findAvailablePort() function**: Try ports starting from 3100 until one is available
      3. **Resolve port before binding**: In start() method, resolve 'auto' to actual port
      4. **Write .status-port file**: JSON file with { port, pid, startedAt, host }
      5. **Cleanup on stop**: Remove .status-port file when server stops

      Port file enables:
      - Port discovery for commands like /sprint-watch
      - Checking if server process is still alive via PID
      - Knowing when server started

      This architecture supports N parallel sprints, each with a dedicated status server
      on a unique port.

      Files:
      - plugins/m42-sprint/compiler/src/status-server/server.ts (implementation)
      - plugins/m42-sprint/compiler/src/status-server/status-types.ts (StatusPortFile interface)
      - plugins/m42-sprint/compiler/src/status-server/index.ts (CLI default to auto)
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Refactored status server to support parallel execution with auto-port allocation
  - id: status-server-single-sprint-view-architecture
    status: applied
    applied-at: "2026-02-01T20:04:54+01:00"
    applied-by: auto-apply-high
    title: Each sprint gets dedicated status server with single-sprint view
    problem: |
      The old architecture had one central status server with a dashboard showing all sprints
      and navigation between them. This doesn't work for parallel execution where each sprint
      runs in an isolated worktree with its own server.

      The navigation bar and sprint switcher become meaningless when each server only knows
      about one sprint.
    solution: |
      Refactor to single-sprint view architecture:

      1. **Remove navigation components** (page.ts):
         - Delete SprintNavigation interface
         - Remove generateNavigationBar function
         - Remove sprint switcher dropdown
         - Remove nav-bar CSS styles (~116 lines)

      2. **Simplify routes** (server.ts):
         - `/` and `/dashboard` serve the main sprint page
         - `/sprint/:id` returns error for other sprints (each has its own server)
         - Remove generateDashboardPage - no central dashboard needed

      3. **Page is self-contained**: All data comes from current sprint's PROGRESS.yaml

      4. **Each sprint worktree has**: `.status-port` file for its dedicated server

      This architecture scales to N parallel sprints because each is completely independent.
      No shared state, no cross-sprint coordination needed.

      Files:
      - plugins/m42-sprint/compiler/src/status-server/page.ts (removed navigation)
      - plugins/m42-sprint/compiler/src/status-server/server.ts (simplified routes)
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Removed navigation and simplified to single-sprint view
  - id: status-server-incremental-refactoring-pattern
    status: pending
    title: Follow incremental refactoring pattern for large TypeScript files
    problem: |
      Large files like server.ts and page.ts (5000+ lines) are difficult to refactor in one
      big change. Making too many changes at once increases risk of breaking things and makes
      debugging harder.

      It's tempting to try changing everything at once when refactoring.
    solution: |
      Use incremental refactoring pattern demonstrated in this session:

      **Phase 1: Core architecture change**
      - Add auto-port allocation to server.ts
      - Update config interface to support 'auto'
      - Add port file writing/cleanup
      - Verify compilation

      **Phase 2: UI simplification**
      - Remove navigation bar from page.ts
      - Remove unused functions
      - Remove related CSS
      - Verify compilation

      **Phase 3: Route simplification**
      - Update server route handling
      - Remove unused imports
      - Update exports

      **Phase 4: CLI and commands**
      - Update CLI default to auto-port
      - Update /sprint-watch command
      - Add utility functions for port discovery

      **Phase 5: Cleanup**
      - Remove obsolete tests
      - Verify all compilations
      - Test the changes

      Each phase is independently verifiable via TypeScript compilation. This makes it easier
      to identify which change broke something if issues arise.

      Pattern: Architecture → UI → Routes → CLI → Tests → Verification
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: medium
    source:
      tool: text
      context: Session followed clear incremental refactoring pattern across phases
  - id: status-server-port-file-json-structure
    status: pending
    title: Status port file uses JSON structure for extensibility
    problem: |
      When implementing the .status-port file, it would be simple to just write the port
      number as plain text. But this limits future extensibility - what if we need to add
      more metadata later?
    solution: |
      Use JSON structure for .status-port file even though we only store port initially:

      ```typescript
      interface StatusPortFile {
        port: number;
        pid: number;
        startedAt: string;
        host: string;
      }
      ```

      Benefits:
      - **PID tracking**: Can check if server process is still alive
      - **Timestamp**: Know when server started
      - **Host field**: Future support for remote servers
      - **Extensible**: Easy to add new fields (e.g., protocol, version)

      The small overhead of JSON parsing is worth the flexibility. This pattern makes it
      easy to add new metadata without breaking existing consumers.

      File: plugins/m42-sprint/compiler/src/status-server/status-types.ts
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: medium
    source:
      tool: Edit
      context: StatusPortFile interface design with multiple metadata fields
  - id: typescript-config-getters-for-nullable-resolution
    status: pending
    title: Use config getters after async resolution of optional config fields
    problem: |
      When a TypeScript config field can be resolved asynchronously (e.g., port: 'auto' → 3101),
      the config becomes temporarily nullable. Direct access to `this.config` causes type errors:

      "Object is possibly 'null'"

      You need to either use `this.config!` everywhere or restructure the class.
    solution: |
      Add a typed getter method that returns the resolved config:

      ```typescript
      class StatusServer {
        private config: ResolvedServerConfig | null = null;

        // After start() completes, config is always resolved
        private getConfig(): ResolvedServerConfig {
          if (!this.config) {
            throw new Error('Server not started - config not initialized');
          }
          return this.config;
        }

        getUrl(): string {
          // Use getter for type-safe access
          return `http://${this.getConfig().host}:${this.getConfig().port}`;
        }
      }
      ```

      This pattern:
      - Provides type safety without `!` assertions everywhere
      - Makes it explicit that config requires initialization
      - Gives helpful error message if accessed before start()

      Alternative: Use `this.config!` if you know start() has completed, but getter is cleaner.

      File: plugins/m42-sprint/compiler/src/status-server/server.ts
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: medium
    source:
      tool: Edit
      context: Added getConfig() getter for type-safe access to resolved config
  - id: remove-obsolete-tests-during-refactoring
    status: pending
    title: Remove tests that validate removed functionality instead of adapting them
    problem: |
      When refactoring removes a feature (like navigation bar), related test files become
      obsolete. It's tempting to try adapting the tests to the new architecture.

      In this case, dropdown-navigation.test.ts tested the navigation functionality which
      was completely removed. The test was failing because it passed a `navigation` argument
      that no longer exists.
    solution: |
      When a feature is intentionally removed as part of refactoring:

      1. **Identify obsolete tests**: Tests that validate the removed feature
      2. **Remove the test file entirely**: Don't try to adapt it
      3. **Document the removal**: "This test is no longer relevant due to [architectural change]"

      Example from this session:
      - Removed: SprintNavigation feature and navigation bar
      - Test file: dropdown-navigation.test.ts
      - Action: Deleted the entire test file
      - Reasoning: "Testing old navigation functionality which has been removed"

      Keeping obsolete tests adds maintenance burden without value. If the feature is gone,
      its tests should go too.

      Only keep tests if:
      - The feature still exists but changed implementation
      - The test validates a behavior that still matters

      File: plugins/m42-sprint/compiler/src/status-server/dropdown-navigation.test.ts (deleted)
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: medium
    source:
      tool: Bash
      context: Removed obsolete test file after navigation feature removal
  - id: status-server-cli-messaging-after-port-resolution
    status: pending
    title: Display resolved port in CLI startup message after auto-allocation
    problem: |
      When using auto-port allocation, the operator doesn't know which port was assigned
      until they check the .status-port file or try different ports. This creates friction
      during development.

      The startup message should tell them immediately.
    solution: |
      Update CLI to display the resolved port after server starts:

      ```typescript
      // Default port is 'auto'
      const config = { port: args.port || 'auto', ... };

      await server.start();

      // Display actual port after resolution
      console.log(`Status server running on ${server.getUrl()}`);
      console.log(`Port file: ${path.join(sprintDir, '.status-port')}`);
      ```

      This gives immediate feedback about:
      - What port the server is listening on
      - Where to find the port file for programmatic access

      Especially useful when running multiple sprints in parallel - each shows its unique port.

      File: plugins/m42-sprint/compiler/src/status-server/index.ts
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: medium
    source:
      tool: Edit
      context: CLI displays resolved port after auto-allocation
  - id: command-update-for-architectural-changes
    status: applied
    applied-at: "2026-02-01T20:04:54+01:00"
    applied-by: auto-apply-high
    title: Update command documentation when underlying architecture changes
    problem: |
      Commands like /sprint-watch encapsulate specific workflows. When the underlying
      architecture changes (like status server moving to auto-port), the command's
      implementation and documentation must update to match.

      Stale command docs lead to confusion and incorrect usage.
    solution: |
      When refactoring changes how a subsystem works, update related commands:

      1. **Identify affected commands**: Which commands interact with the changed subsystem?
      2. **Update implementation**: Change how the command uses the subsystem
      3. **Update documentation**: Explain new behavior and capabilities
      4. **Add examples**: Show new usage patterns

      Example from this session:
      - Change: Status server now uses auto-port with .status-port file
      - Affected command: /sprint-watch
      - Updates:
        * Read JSON port file instead of assuming port 3100
        * Check if server process is still running via PID
        * Document parallel sprint support
        * Add instructions for launching multiple status servers

      Commands are the user-facing API - they must stay in sync with internal architecture.

      File: plugins/m42-sprint/commands/sprint-watch.md
    target: plugins/m42-sprint/commands/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Updated /sprint-watch command after status server refactoring
  # Extracted from phase-2_documentation.log (2026-02-01)
  - id: documentation-phase-assess-before-writing
    status: applied
    applied-at: "2026-02-01T21:00:00Z"
    applied-by: auto-apply-high
    title: Assess implementation changes before assuming documentation updates needed
    problem: |
      Documentation phases in sprints can waste effort by creating unnecessary documentation
      updates when implementation changes are bug fixes or internal improvements to existing
      features rather than new user-facing functionality.

      It's tempting to blindly update docs without first verifying if the changes actually
      affect documented behavior or add new features.
    solution: |
      Follow this documentation assessment pattern:

      1. **Analyze implementation changes**: Use git diff or review modified files to understand
         what actually changed (bug fixes, UI improvements, internal refactoring, new features)

      2. **Classify change type**:
         - Bug fixes to existing features → Usually no doc updates needed
         - Internal improvements (performance, code quality) → No doc updates
         - UI enhancements to documented features → Check if behavior changed
         - New features or capabilities → Documentation required

      3. **Check existing documentation coverage**:
         - Read relevant doc sections
         - Verify if existing docs already cover the improved functionality
         - Identify gaps where new features aren't documented

      4. **Document decision**: Create artifacts summary explaining why docs were/weren't updated

      Example from this sprint:
      - Changes: Parallel execution indicator, subprocess indicators, activity feed improvements
      - Assessment: These improve existing documented features (parallel execution, subagent
        indicators, live activity feed)
      - Decision: No doc updates needed - existing sections already cover these features
      - Artifact: Summary explaining "implementation-level improvements to make existing
        features work better, not new features requiring new documentation"

      This prevents documentation churn while ensuring truly new features get documented.
    target: plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: Read
      context: Documentation phase analyzed changes and verified existing coverage
  - id: documentation-phase-multi-step-verification
    status: pending
    title: Verify documentation coverage across multiple doc files systematically
    problem: |
      Projects with multiple documentation files (USER-GUIDE.md, API.md, README.md) can have
      fragmented coverage. When assessing if docs need updates, checking just one file might
      miss that the feature is documented elsewhere.

      This leads to duplicate documentation or missed coverage gaps.
    solution: |
      Use systematic multi-file verification pattern:

      1. **Identify relevant doc files**: Use Glob to find all documentation
         - User guides, API references, tutorials, READMEs

      2. **Map features to doc locations**:
         - Where is parallel execution documented?
         - Where are subagent indicators explained?
         - Where is the live activity feed described?

      3. **Read each relevant section**: Verify what's already covered with line numbers

      4. **Create coverage matrix**: Document which features are covered where

      Example from transcript:
      ```
      Feature: Parallel execution indicator
      - Already documented: USER-GUIDE.md "Step Dependencies and Parallel Execution"
      - Conclusion: Enhancement to existing feature, docs already cover concept

      Feature: Subagent indicators
      - Already documented: USER-GUIDE.md lines 227-235
      - Conclusion: UI improvement, existing docs cover the feature

      Feature: Live Activity Feed improvements
      - Already documented: USER-GUIDE.md lines 118-158
      - Conclusion: Internal improvement, behavior already documented
      ```

      This systematic approach ensures you don't create redundant docs or miss gaps.
    target: plugins/m42-sprint/CLAUDE.md
    confidence: medium
    source:
      tool: Read
      context: Checked multiple sections of USER-GUIDE.md to verify coverage
  - id: git-diff-for-documentation-assessment
    status: applied
    applied-at: "2026-02-01T21:00:00Z"
    applied-by: auto-apply-high
    title: Use git diff to identify implementation changes at start of documentation phase
    problem: |
      Documentation phases need to know what was implemented in previous steps. Reading
      individual files doesn't give the complete picture of what changed.

      Without understanding the full scope of changes, documentation assessment is incomplete.
    solution: |
      Start documentation phases with git diff to see all changes:

      ```bash
      # See what files changed
      git diff --name-status main...HEAD

      # See actual code changes
      git diff main...HEAD
      ```

      This reveals:
      - Which files were modified (shows scope)
      - What code was added/removed (shows nature of changes)
      - Which areas of codebase were touched

      From this, you can:
      1. Distinguish sprint context files from actual implementation
      2. Identify which subsystems were modified
      3. Determine if changes are bug fixes, features, or refactoring
      4. Plan documentation strategy accordingly

      Example from transcript:
      - git diff showed only sprint context files committed
      - Checked for uncommitted changes to find actual implementation
      - Found changes to page.ts, transcription-watcher.ts, loop.ts
      - Used this to assess documentation needs

      This gives a complete picture before diving into individual files.
    target: plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: Bash
      context: Used git diff to identify changes before documentation assessment
learnings:
  - id: tooling-phase-parallel-subagent-reviews
    status: applied
    title: Use parallel subagent delegation for tooling update reviews
    problem: |
      After making implementation changes to a plugin with multiple commands and skills,
      the tooling update phase needs to review each one to ensure documentation reflects
      the new capabilities. Sequential reviews are slow and inefficient.

      For plugins with 10+ commands/skills, this becomes a bottleneck.
    solution: |
      Spawn multiple review subagents in parallel using a single Task() call with multiple
      invocations:

      Pattern from this transcript:
      1. Analyze implementation changes to understand what changed
      2. List all commands and skills in the affected plugin
      3. Spawn review subagents in parallel (one per command/skill)
      4. Each subagent:
         - Reads the current command/skill file
         - Reads related implementation files
         - Determines if updates are needed
         - Makes necessary updates or reports "no changes needed"

      This parallelizes the review process and completes tooling updates much faster.

      Example: 13 commands/skills reviewed simultaneously instead of sequentially.

      The key insight: "Let me spawn subagents in parallel to review all potentially
      affected commands and skills."
    target: plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: Task
      context: Parallel subagent delegation pattern for tooling reviews
    applied-at: "2026-02-01T22:00:00Z"
    applied-by: auto-apply-high
  - id: tooling-phase-analyzes-implementation-first
    status: applied
    title: Analyze implementation changes before spawning tooling review subagents
    problem: |
      When updating command/skill documentation after implementation changes, review
      subagents need context about what changed to make informed decisions. Without
      this context, they might miss relevant updates or make unnecessary changes.

      Spawning subagents without providing implementation context leads to incomplete
      or incorrect reviews.
    solution: |
      Before spawning tooling review subagents, create a comprehensive analysis of
      implementation changes:

      1. Check git diff for committed changes
      2. Check git status for uncommitted changes
      3. Read modified implementation files
      4. Summarize the changes in a structured format:
         - File changed
         - What was added/modified
         - Why it matters for commands/skills

      Example from this transcript:
      "The implementation changes include:
      1. **page.ts**: Added parallel execution indicator UI (shows when multiple steps
         run in parallel), subprocess indicators, and related CSS styles
      2. **transcription-watcher.ts**: Changed tool verbosity levels (Task/Skill now
         minimal, Read/Glob/Grep now detailed instead of basic)..."

      This summary can be passed to review subagents as context or used by the main
      agent to decide which commands/skills need review.
    target: plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: text
      context: Implementation analysis before subagent spawning
    applied-at: "2026-02-01T22:00:00Z"
    applied-by: auto-apply-high
  - id: task-tool-verbosity-classification-rationale
    status: applied
    title: Classify tools by user-facing impact for verbosity levels
    problem: |
      When implementing verbosity levels for activity feeds, it's not obvious which tools
      should be "minimal" (always visible) vs "basic" (default) vs "detailed" (verbose).

      Incorrect classification creates either too much noise (showing everything) or too
      little visibility (hiding important actions).
    solution: |
      Classify tools by user-facing impact and decision-making value:

      **Minimal** (always visible - high-level decisions and interactions):
      - TodoWrite, AskUserQuestion - Direct user interaction
      - Task, Skill - Agent delegation (architectural decisions)
      - TaskCreate, TaskUpdate, TaskList, TaskGet - Progress tracking

      **Basic** (default view - actual work being done):
      - Write, Edit - Code changes
      - Bash - Commands that modify state

      **Detailed** (verbose mode - exploration and research):
      - Read, Glob, Grep - File exploration
      - All other tools

      Rationale: Users want to see *what's being decided and done*, not *how it's
      being researched*. Exploration is important but creates noise at the default
      verbosity level.

      This change was implemented in transcription-watcher.ts as part of the tooling update.
    target: plugins/m42-sprint/compiler/src/status-server/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Verbosity level changes in transcription-watcher.ts
    applied-at: "2026-02-01T22:00:00Z"
    applied-by: auto-apply-high
  - id: subagent-review-pattern-read-analyze-decide-update
    status: pending
    title: Subagent review pattern follows read-analyze-decide-update flow
    problem: |
      When reviewing commands/skills for tooling updates, subagents need a systematic
      approach to determine if updates are needed. Ad-hoc review leads to inconsistent
      decisions and missed updates.
    solution: |
      Implement systematic review pattern in subagents:

      **Step 1: Read current state**
      - Read the command/skill file
      - Read related implementation files

      **Step 2: Analyze changes**
      - What changed in implementation?
      - Does this affect the command/skill behavior?
      - Are new capabilities exposed?

      **Step 3: Decide**
      - Does documentation need updates?
      - If yes, what sections need changes?
      - If no, why not?

      **Step 4: Update or report**
      - Make necessary updates with clear rationale
      - Or report "No changes needed" with reasoning

      This pattern ensures thorough, consistent reviews across all commands/skills.

      The parallel subagent delegation in this transcript followed this pattern,
      with each subagent completing all 4 steps independently.
    target: plugins/m42-sprint/CLAUDE.md
    confidence: medium
    source:
      tool: Task
      context: Review subagent workflow pattern
  - id: tooling-update-completion-summary
    status: pending
    title: Create tooling update summary document after reviews complete
    problem: |
      After spawning multiple parallel review subagents, the results are scattered across
      subagent outputs. Without a summary, it's hard to see what was updated and why.

      This makes it difficult to verify completeness or communicate changes to others.
    solution: |
      After all review subagents complete, create a comprehensive summary:

      1. List all commands/skills reviewed
      2. For each:
         - What was the review decision? (updated / no changes needed)
         - If updated, what changed?
         - Rationale for the decision

      3. Overall statistics:
         - Total reviewed
         - Number updated
         - Number unchanged

      4. Commit the summary to artifacts for future reference

      Example structure:
      ```markdown
      # Tooling Update Summary - Phase 3

      ## Implementation Changes Reviewed
      - page.ts: Parallel execution indicators
      - transcription-watcher.ts: Verbosity levels
      - loop.ts: Parallel status marking

      ## Commands Reviewed (13 total)
      - /run-sprint: Updated to document parallel execution visibility
      - /sprint-status: No changes needed
      ...

      ## Skills Reviewed (0 total)

      ## Summary
      - 3 commands updated
      - 10 commands unchanged
      ```

      This provides a complete audit trail of the tooling update phase.
    target: plugins/m42-sprint/CLAUDE.md
    confidence: medium
    source:
      tool: text
      context: Reasoning block 6 mentions creating summary after subagent completion
  # Extracted from phase-4_version-bump.log (2026-02-01)
  - id: worktree-path-confusion-edit-tool
    status: applied
    applied-at: "2026-02-01T22:30:00Z"
    applied-by: auto-apply-high
    title: Edit tool uses absolute paths - be aware of worktree context
    problem: |
      When working in a git worktree, path confusion can occur between the worktree location
      and the parent repository location. This happens because:

      - You're in a worktree at `/path/to/trees/sprint-name/`
      - But files you're editing reference the full path from the parent repo
      - The Edit tool was using full paths from parent repo instead of relative paths

      This can cause edits to fail or not persist because the paths don't match the current
      working directory context.

      From reasoning block 9: "I see - I'm in a worktree at
      `/home/koni/projects/m42-claude-plugins/trees/2026-02-01_status-page-fix`, but I was
      using the full path from the parent repo. Let me use the correct relative paths."
    solution: |
      When working in a sprint worktree, always use relative paths with Edit tool:

      **Incorrect** (full path from parent):
      ```
      Edit(file_path: "/home/koni/projects/m42-claude-plugins/plugins/m42-sprint/plugin.json")
      ```

      **Correct** (relative path from worktree):
      ```
      Edit(file_path: "plugins/m42-sprint/plugin.json")
      ```

      The worktree directory is a complete checkout of the repository, so all files exist
      at relative paths from the worktree root.

      Key indicators you're in a worktree:
      - PWD shows `/trees/sprint-name/` path segment
      - Git worktree list shows multiple working trees

      When edits don't persist or fail, check if you're using absolute vs relative paths
      and adjust to relative paths from the current worktree root.
    target: plugins/m42-sprint/CLAUDE.md
    confidence: high
    source:
      tool: Edit
      context: Path correction from full parent repo path to relative worktree path
  - id: version-bump-decision-pattern
    status: applied
    applied-at: "2026-02-01T22:30:00Z"
    applied-by: auto-apply-high
    title: Version bump decisions require analyzing change nature, not just counting commits
    problem: |
      When deciding version bumps (MAJOR.MINOR.PATCH), it's tempting to just count commits
      or look at commit messages. But semantic versioning requires understanding the nature
      of changes:

      - Breaking changes → MAJOR
      - New features → MINOR
      - Bug fixes and patches → PATCH

      Without analyzing actual code changes, version decisions may be incorrect.
    solution: |
      Follow systematic version bump analysis pattern:

      **Step 1: Read sprint context**
      - Check SPRINT.yaml title and description
      - Review step descriptions

      **Step 2: Analyze actual changes**
      - Use git diff to see code modifications
      - Identify which files changed and how
      - Categorize changes:
        * Bug fixes (PATCH)
        * New features (MINOR)
        * Breaking API changes (MAJOR)
        * Internal refactoring (usually PATCH)

      **Step 3: Determine compatibility**
      - Are changes backwards compatible?
      - Do they break existing APIs?
      - Do they add new public functionality?

      **Step 4: Choose version**
      - Prioritize the highest severity change level
      - Document rationale

      Example from this transcript (reasoning block 6):
      - Sprint title: "status-page-fix"
      - Changes: Bug fixes (dropdown navigation), minor additive feature (--dashboard flag),
        internal refactoring
      - Decision: PATCH (2.5.2 → 2.5.3)
      - Rationale: "Bug fixes with backwards compatible improvements"

      This structured approach ensures version numbers accurately reflect change impact.
    target: /home/koni/projects/m42-claude-plugins/CLAUDE.md
    confidence: high
    source:
      tool: text
      context: Version bump decision reasoning in block 6
