sprint-id: 2026-01-16_plugin-enhancements
status: in-progress
phases:
  - id: preflight
    status: completed
    prompt: >
      Create comprehensive sprint context that ALL subsequent phases will reference.


      ## Your Task

      Analyze the entire sprint scope and generate shared context documents.


      ## Step 1: Create Sprint Branch

      ```bash

      git checkout -b sprint/2026-01-16_plugin-enhancements 2>/dev/null || git checkout sprint/2026-01-16_plugin-enhancements

      ```


      ## Step 2: Analyze Sprint Scope

      Read SPRINT.yaml to understand:

      - All steps and their relationships

      - Overall sprint goal

      - Technical requirements across all steps

      - Potential dependencies between steps


      ## Step 3: Research Project Context

      Investigate the codebase to understand:

      - Project architecture and structure

      - Key patterns and conventions used

      - Relevant types and interfaces

      - Build/test/lint commands

      - Dependencies (internal modules, external packages)


      ## Step 4: Generate Shared Context

      Create: context/_shared-context.md


      ```markdown

      # Shared Sprint Context


      ## Project Architecture

      [High-level architecture overview relevant to this sprint]


      ## Key Patterns

      - [Pattern 1]: [Where and how it's used]

      - [Pattern 2]: [Where and how it's used]

      ...


      ## Conventions

      - Naming: [Naming conventions]

      - File structure: [File organization patterns]

      - Testing: [Testing patterns and frameworks]

      - Error handling: [Error handling patterns]


      ## Commands

      - Build: `[build command]`

      - Test: `[test command]`

      - Lint: `[lint command]`

      - TypeCheck: `[typecheck command]`


      ## Dependencies

      ### Internal Modules

      - [Module]: [Purpose]


      ### External Packages

      - [Package]: [Usage]


      ## Types and Interfaces

      [Key types relevant to this sprint]

      ```


      ## Step 5: Generate Sprint Plan

      Create: context/sprint-plan.md


      ```markdown

      # Sprint Plan: 2026-01-16_plugin-enhancements


      ## Goal

      [One paragraph describing what this sprint accomplishes]


      ## Success Criteria

      - [ ] [Measurable criterion 1]

      - [ ] [Measurable criterion 2]

      ...


      ## Step Breakdown


      ### Step 0: [Step title from prompt]

      **Scope**: [What this step does]

      **Files**: [Expected files to create/modify]

      **Dependencies**: [What it depends on]

      **Risk**: Low/Medium/High - [reason]


      ### Step 1: ...

      [Continue for all steps]


      ## Step Dependency Graph

      ```

      step-0 → step-1 → step-2



















                ↓
              step-3
      ```

      [Or describe dependencies textually]


      ## Risk Assessment

      | Risk | Impact | Mitigation |

      |------|--------|------------|

      | [Risk 1] | [Impact] | [How to mitigate] |


      ## Estimated Complexity

      | Step | Complexity | Reason |

      |------|------------|--------|

      | step-0 | Low/Medium/High | [Brief reason] |

      ```


      ## Output

      - Sprint branch created/checked out

      - context/_shared-context.md with project patterns

      - context/sprint-plan.md with step analysis

      - Commit preflight artifacts:



















        ```bash
        git add context/
        git commit -m "preflight: add shared context and sprint plan"
        ```
    started-at: "2026-01-16T13:01:19Z"
    completed-at: "2026-01-16T13:04:16Z"
    elapsed: 00:02:57
  - id: development
    status: in-progress
    steps:
      - id: step-0
        prompt: |
          Track A - Step 1: Add API Endpoints for Status Page Controls

          Add pause/resume/stop control API endpoints to the status server.

          Requirements:
          - Add POST /api/pause endpoint that creates .pause-requested signal file
          - Add POST /api/resume endpoint that creates .resume-requested signal file
          - Add POST /api/stop endpoint that creates .stop-requested signal file
          - Add GET /api/controls endpoint that returns available actions based on current sprint state
          - Signal files should be created in the sprint directory
          - Endpoints should read current PROGRESS.yaml to determine valid actions
          - Return appropriate HTTP status codes and JSON responses

          Files to modify:
          - compiler/src/status-server/server.ts

          Reference:
          - See compiler/src/status-server/server.ts for existing SSE implementation
          - sprint-loop.sh already checks for pause/resume state in PROGRESS.yaml
        status: in-progress
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Track A - Step 1: Add API Endpoints for Status Page Controls

              Add pause/resume/stop control API endpoints to the status server.

              Requirements:
              - Add POST /api/pause endpoint that creates .pause-requested signal file
              - Add POST /api/resume endpoint that creates .resume-requested signal file
              - Add POST /api/stop endpoint that creates .stop-requested signal file
              - Add GET /api/controls endpoint that returns available actions based on current sprint state
              - Signal files should be created in the sprint directory
              - Endpoints should read current PROGRESS.yaml to determine valid actions
              - Return appropriate HTTP status codes and JSON responses

              Files to modify:
              - compiler/src/status-server/server.ts

              Reference:
              - See compiler/src/status-server/server.ts for existing SSE implementation
              - sprint-loop.sh already checks for pause/resume state in PROGRESS.yaml


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-0-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-0

              ## Step Task
              Track A - Step 1: Add API Endpoints for Status Page Controls

              Add pause/resume/stop control API endpoints to the status server.

              Requirements:
              - Add POST /api/pause endpoint that creates .pause-requested signal file
              - Add POST /api/resume endpoint that creates .resume-requested signal file
              - Add POST /api/stop endpoint that creates .stop-requested signal file
              - Add GET /api/controls endpoint that returns available actions based on current sprint state
              - Signal files should be created in the sprint directory
              - Endpoints should read current PROGRESS.yaml to determine valid actions
              - Return appropriate HTTP status codes and JSON responses

              Files to modify:
              - compiler/src/status-server/server.ts

              Reference:
              - See compiler/src/status-server/server.ts for existing SSE implementation
              - sprint-loop.sh already checks for pause/resume state in PROGRESS.yaml


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-0-gherkin.md
              git commit -m "plan(step-0): define gherkin scenarios"
              ```
            started-at: "2026-01-16T13:04:34Z"
            completed-at: "2026-01-16T13:04:34Z"
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Track A - Step 1: Add API Endpoints for Status Page Controls

              Add pause/resume/stop control API endpoints to the status server.

              Requirements:
              - Add POST /api/pause endpoint that creates .pause-requested signal file
              - Add POST /api/resume endpoint that creates .resume-requested signal file
              - Add POST /api/stop endpoint that creates .stop-requested signal file
              - Add GET /api/controls endpoint that returns available actions based on current sprint state
              - Signal files should be created in the sprint directory
              - Endpoints should read current PROGRESS.yaml to determine valid actions
              - Return appropriate HTTP status codes and JSON responses

              Files to modify:
              - compiler/src/status-server/server.ts

              Reference:
              - See compiler/src/status-server/server.ts for existing SSE implementation
              - sprint-loop.sh already checks for pause/resume state in PROGRESS.yaml


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-0-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-0-context.md

              ```markdown
              # Step Context: step-0

              ## Task
              Track A - Step 1: Add API Endpoints for Status Page Controls

              Add pause/resume/stop control API endpoints to the status server.

              Requirements:
              - Add POST /api/pause endpoint that creates .pause-requested signal file
              - Add POST /api/resume endpoint that creates .resume-requested signal file
              - Add POST /api/stop endpoint that creates .stop-requested signal file
              - Add GET /api/controls endpoint that returns available actions based on current sprint state
              - Signal files should be created in the sprint directory
              - Endpoints should read current PROGRESS.yaml to determine valid actions
              - Return appropriate HTTP status codes and JSON responses

              Files to modify:
              - compiler/src/status-server/server.ts

              Reference:
              - See compiler/src/status-server/server.ts for existing SSE implementation
              - sprint-loop.sh already checks for pause/resume state in PROGRESS.yaml


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-0-context.md
              git commit -m "context(step-0): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Track A - Step 1: Add API Endpoints for Status Page Controls

              Add pause/resume/stop control API endpoints to the status server.

              Requirements:
              - Add POST /api/pause endpoint that creates .pause-requested signal file
              - Add POST /api/resume endpoint that creates .resume-requested signal file
              - Add POST /api/stop endpoint that creates .stop-requested signal file
              - Add GET /api/controls endpoint that returns available actions based on current sprint state
              - Signal files should be created in the sprint directory
              - Endpoints should read current PROGRESS.yaml to determine valid actions
              - Return appropriate HTTP status codes and JSON responses

              Files to modify:
              - compiler/src/status-server/server.ts

              Reference:
              - See compiler/src/status-server/server.ts for existing SSE implementation
              - sprint-loop.sh already checks for pause/resume state in PROGRESS.yaml


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-0-gherkin.md (scenarios to satisfy)
              4. context/step-0-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-0): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-0-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-0-qa-report.md

              ```markdown
              # QA Report: step-0

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-0-qa-report.md
                 git commit -m "qa(step-0): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-0.\n\n## Context\nRead: artifacts/step-0-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-0-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-0-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-0 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Track A - Step 1: Add API Endpoints for Status Page Controls

              Add pause/resume/stop control API endpoints to the status server.

              Requirements:
              - Add POST /api/pause endpoint that creates .pause-requested signal file
              - Add POST /api/resume endpoint that creates .resume-requested signal file
              - Add POST /api/stop endpoint that creates .stop-requested signal file
              - Add GET /api/controls endpoint that returns available actions based on current sprint state
              - Signal files should be created in the sprint directory
              - Endpoints should read current PROGRESS.yaml to determine valid actions
              - Return appropriate HTTP status codes and JSON responses

              Files to modify:
              - compiler/src/status-server/server.ts

              Reference:
              - See compiler/src/status-server/server.ts for existing SSE implementation
              - sprint-loop.sh already checks for pause/resume state in PROGRESS.yaml


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-0-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-0): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
        started-at: "2026-01-16T13:04:34Z"
      - id: step-1
        prompt: |
          Track A - Step 2: Add Button UI Components to Status Page

          Implement interactive control buttons in the status page UI.

          Requirements:
          - Add control bar below header with Pause/Resume/Stop buttons
          - Button visibility based on sprint status (show Pause when running, Resume when paused)
          - Stop button should be red and always visible when sprint is active
          - Add confirmation modal for Stop button with warning about incomplete work
          - Implement click handlers that call the new API endpoints
          - Add loading states during API calls
          - Add toast notifications for success/error feedback
          - Ensure buttons are styled consistently with existing GitHub dark theme

          Files to modify:
          - compiler/src/status-server/page.ts

          Reference:
          - Existing page structure in compiler/src/status-server/page.ts
          - Use fetch API for POST requests to control endpoints
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Track A - Step 2: Add Button UI Components to Status Page

              Implement interactive control buttons in the status page UI.

              Requirements:
              - Add control bar below header with Pause/Resume/Stop buttons
              - Button visibility based on sprint status (show Pause when running, Resume when paused)
              - Stop button should be red and always visible when sprint is active
              - Add confirmation modal for Stop button with warning about incomplete work
              - Implement click handlers that call the new API endpoints
              - Add loading states during API calls
              - Add toast notifications for success/error feedback
              - Ensure buttons are styled consistently with existing GitHub dark theme

              Files to modify:
              - compiler/src/status-server/page.ts

              Reference:
              - Existing page structure in compiler/src/status-server/page.ts
              - Use fetch API for POST requests to control endpoints


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-1-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-1

              ## Step Task
              Track A - Step 2: Add Button UI Components to Status Page

              Implement interactive control buttons in the status page UI.

              Requirements:
              - Add control bar below header with Pause/Resume/Stop buttons
              - Button visibility based on sprint status (show Pause when running, Resume when paused)
              - Stop button should be red and always visible when sprint is active
              - Add confirmation modal for Stop button with warning about incomplete work
              - Implement click handlers that call the new API endpoints
              - Add loading states during API calls
              - Add toast notifications for success/error feedback
              - Ensure buttons are styled consistently with existing GitHub dark theme

              Files to modify:
              - compiler/src/status-server/page.ts

              Reference:
              - Existing page structure in compiler/src/status-server/page.ts
              - Use fetch API for POST requests to control endpoints


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-1-gherkin.md
              git commit -m "plan(step-1): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Track A - Step 2: Add Button UI Components to Status Page

              Implement interactive control buttons in the status page UI.

              Requirements:
              - Add control bar below header with Pause/Resume/Stop buttons
              - Button visibility based on sprint status (show Pause when running, Resume when paused)
              - Stop button should be red and always visible when sprint is active
              - Add confirmation modal for Stop button with warning about incomplete work
              - Implement click handlers that call the new API endpoints
              - Add loading states during API calls
              - Add toast notifications for success/error feedback
              - Ensure buttons are styled consistently with existing GitHub dark theme

              Files to modify:
              - compiler/src/status-server/page.ts

              Reference:
              - Existing page structure in compiler/src/status-server/page.ts
              - Use fetch API for POST requests to control endpoints


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-1-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-1-context.md

              ```markdown
              # Step Context: step-1

              ## Task
              Track A - Step 2: Add Button UI Components to Status Page

              Implement interactive control buttons in the status page UI.

              Requirements:
              - Add control bar below header with Pause/Resume/Stop buttons
              - Button visibility based on sprint status (show Pause when running, Resume when paused)
              - Stop button should be red and always visible when sprint is active
              - Add confirmation modal for Stop button with warning about incomplete work
              - Implement click handlers that call the new API endpoints
              - Add loading states during API calls
              - Add toast notifications for success/error feedback
              - Ensure buttons are styled consistently with existing GitHub dark theme

              Files to modify:
              - compiler/src/status-server/page.ts

              Reference:
              - Existing page structure in compiler/src/status-server/page.ts
              - Use fetch API for POST requests to control endpoints


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-1-context.md
              git commit -m "context(step-1): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Track A - Step 2: Add Button UI Components to Status Page

              Implement interactive control buttons in the status page UI.

              Requirements:
              - Add control bar below header with Pause/Resume/Stop buttons
              - Button visibility based on sprint status (show Pause when running, Resume when paused)
              - Stop button should be red and always visible when sprint is active
              - Add confirmation modal for Stop button with warning about incomplete work
              - Implement click handlers that call the new API endpoints
              - Add loading states during API calls
              - Add toast notifications for success/error feedback
              - Ensure buttons are styled consistently with existing GitHub dark theme

              Files to modify:
              - compiler/src/status-server/page.ts

              Reference:
              - Existing page structure in compiler/src/status-server/page.ts
              - Use fetch API for POST requests to control endpoints


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-1-gherkin.md (scenarios to satisfy)
              4. context/step-1-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-1): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-1-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-1-qa-report.md

              ```markdown
              # QA Report: step-1

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-1-qa-report.md
                 git commit -m "qa(step-1): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-1.\n\n## Context\nRead: artifacts/step-1-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-1-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-1-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-1 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Track A - Step 2: Add Button UI Components to Status Page

              Implement interactive control buttons in the status page UI.

              Requirements:
              - Add control bar below header with Pause/Resume/Stop buttons
              - Button visibility based on sprint status (show Pause when running, Resume when paused)
              - Stop button should be red and always visible when sprint is active
              - Add confirmation modal for Stop button with warning about incomplete work
              - Implement click handlers that call the new API endpoints
              - Add loading states during API calls
              - Add toast notifications for success/error feedback
              - Ensure buttons are styled consistently with existing GitHub dark theme

              Files to modify:
              - compiler/src/status-server/page.ts

              Reference:
              - Existing page structure in compiler/src/status-server/page.ts
              - Use fetch API for POST requests to control endpoints


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-1-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-1): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-2
        prompt: |
          Track B - Step 1: Create creating-workflows Skill Structure

          Create a new skill for workflow definition guidance.

          Requirements:
          - Create skills/creating-workflows/ directory structure
          - Create main skill file: skills/creating-workflows/creating-workflows.md
          - Create references/ subdirectory with:
            - workflow-schema.md (Full YAML schema reference)
            - template-variables.md (All available template variables)
            - phase-types.md (Simple vs for-each phase explanations)
            - workflow-patterns.md (Common workflow patterns)
          - Create assets/ subdirectory with:
            - feature-workflow.yaml (Example feature workflow)
            - bugfix-workflow.yaml (Example bugfix workflow)
            - validation-checklist.md (Pre-deployment checklist)
          - Main skill file should trigger on: "create workflow", "new workflow", "workflow definition", "define phases"
          - Include comprehensive documentation for workflow authoring
          - Reference existing workflows in .claude/workflows/ as examples

          New files to create:
          - skills/creating-workflows/creating-workflows.md
          - skills/creating-workflows/references/*.md
          - skills/creating-workflows/assets/*.{yaml,md}
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: >
              Generate binary-verifiable gherkin scenarios for this step.


              ## Your Task

              Track B - Step 1: Create creating-workflows Skill Structure


              Create a new skill for workflow definition guidance.


              Requirements:

              - Create skills/creating-workflows/ directory structure

              - Create main skill file: skills/creating-workflows/creating-workflows.md

              - Create references/ subdirectory with:



















                - workflow-schema.md (Full YAML schema reference)
                - template-variables.md (All available template variables)
                - phase-types.md (Simple vs for-each phase explanations)
                - workflow-patterns.md (Common workflow patterns)
              - Create assets/ subdirectory with:



















                - feature-workflow.yaml (Example feature workflow)
                - bugfix-workflow.yaml (Example bugfix workflow)
                - validation-checklist.md (Pre-deployment checklist)
              - Main skill file should trigger on: "create workflow", "new workflow", "workflow definition", "define phases"

              - Include comprehensive documentation for workflow authoring

              - Reference existing workflows in .claude/workflows/ as examples


              New files to create:

              - skills/creating-workflows/creating-workflows.md

              - skills/creating-workflows/references/*.md

              - skills/creating-workflows/assets/*.{yaml,md}



              ## Shared Context

              Read: context/_shared-context.md (project patterns, conventions, commands)

              Read: context/sprint-plan.md (how this step fits in the sprint)


              ## Instructions

              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.

              Each scenario MUST have:

              1. Clear Given/When/Then structure

              2. An explicit verification command that returns exit code 0 on success

              3. Binary outcome: exactly 1 (pass) or 0 (fail)


              ## Gherkin Format

              Each scenario follows this exact structure:


              ```gherkin

              Scenario: [Descriptive name]



















                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ## Example Scenarios


              ### File Existence

              ```gherkin

              Scenario: Source file exists



















                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ### TypeScript Compilation

              ```gherkin

              Scenario: TypeScript compiles without errors



















                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ### Function Export

              ```gherkin

              Scenario: Login function is exported



















                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ### Test Execution

              ```gherkin

              Scenario: Unit tests pass



















                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ### Lint Check

              ```gherkin

              Scenario: Code passes linting



















                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ## Output

              Create: artifacts/step-2-gherkin.md


              ```markdown

              # Gherkin Scenarios: step-2


              ## Step Task

              Track B - Step 1: Create creating-workflows Skill Structure


              Create a new skill for workflow definition guidance.


              Requirements:

              - Create skills/creating-workflows/ directory structure

              - Create main skill file: skills/creating-workflows/creating-workflows.md

              - Create references/ subdirectory with:



















                - workflow-schema.md (Full YAML schema reference)
                - template-variables.md (All available template variables)
                - phase-types.md (Simple vs for-each phase explanations)
                - workflow-patterns.md (Common workflow patterns)
              - Create assets/ subdirectory with:



















                - feature-workflow.yaml (Example feature workflow)
                - bugfix-workflow.yaml (Example bugfix workflow)
                - validation-checklist.md (Pre-deployment checklist)
              - Main skill file should trigger on: "create workflow", "new workflow", "workflow definition", "define phases"

              - Include comprehensive documentation for workflow authoring

              - Reference existing workflows in .claude/workflows/ as examples


              New files to create:

              - skills/creating-workflows/creating-workflows.md

              - skills/creating-workflows/references/*.md

              - skills/creating-workflows/assets/*.{yaml,md}



              ## Success Criteria

              All scenarios must pass (score = 1) for the step to be complete.

              Total scenarios: [N]

              Required score: [N]/[N]


              ---


              ## Scenario 1: [Name]

              [Full gherkin with verification as shown above]


              ---


              ## Scenario 2: [Name]

              ...


              [Continue for 4-8 scenarios]

              ```


              ## Commit

              ```bash

              git add artifacts/step-2-gherkin.md

              git commit -m "plan(step-2): define gherkin scenarios"

              ```

          - id: context
            status: pending
            prompt: >
              Gather step-specific context for implementation.


              ## Your Task

              Track B - Step 1: Create creating-workflows Skill Structure


              Create a new skill for workflow definition guidance.


              Requirements:

              - Create skills/creating-workflows/ directory structure

              - Create main skill file: skills/creating-workflows/creating-workflows.md

              - Create references/ subdirectory with:



















                - workflow-schema.md (Full YAML schema reference)
                - template-variables.md (All available template variables)
                - phase-types.md (Simple vs for-each phase explanations)
                - workflow-patterns.md (Common workflow patterns)
              - Create assets/ subdirectory with:



















                - feature-workflow.yaml (Example feature workflow)
                - bugfix-workflow.yaml (Example bugfix workflow)
                - validation-checklist.md (Pre-deployment checklist)
              - Main skill file should trigger on: "create workflow", "new workflow", "workflow definition", "define phases"

              - Include comprehensive documentation for workflow authoring

              - Reference existing workflows in .claude/workflows/ as examples


              New files to create:

              - skills/creating-workflows/creating-workflows.md

              - skills/creating-workflows/references/*.md

              - skills/creating-workflows/assets/*.{yaml,md}



              ## Shared Context

              Read: context/_shared-context.md (already has project-wide patterns)

              Read: artifacts/step-2-gherkin.md (scenarios to implement)


              ## Instructions

              Research the specific code areas this step will touch:


              1. **Related Existing Code**



















                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**



















                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**



















                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**



















                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output

              Create: context/step-2-context.md


              ```markdown

              # Step Context: step-2


              ## Task

              Track B - Step 1: Create creating-workflows Skill Structure


              Create a new skill for workflow definition guidance.


              Requirements:

              - Create skills/creating-workflows/ directory structure

              - Create main skill file: skills/creating-workflows/creating-workflows.md

              - Create references/ subdirectory with:



















                - workflow-schema.md (Full YAML schema reference)
                - template-variables.md (All available template variables)
                - phase-types.md (Simple vs for-each phase explanations)
                - workflow-patterns.md (Common workflow patterns)
              - Create assets/ subdirectory with:



















                - feature-workflow.yaml (Example feature workflow)
                - bugfix-workflow.yaml (Example bugfix workflow)
                - validation-checklist.md (Pre-deployment checklist)
              - Main skill file should trigger on: "create workflow", "new workflow", "workflow definition", "define phases"

              - Include comprehensive documentation for workflow authoring

              - Reference existing workflows in .claude/workflows/ as examples


              New files to create:

              - skills/creating-workflows/creating-workflows.md

              - skills/creating-workflows/references/*.md

              - skills/creating-workflows/assets/*.{yaml,md}



              ## Related Code Patterns


              ### Similar Implementation: [path]

              ```typescript

              // Key pattern to follow

              [relevant code snippet]

              ```


              ### Similar Implementation: [path]

              [continue as needed]


              ## Required Imports

              ### Internal

              - `[module]`: [what to import]


              ### External

              - `[package]`: [what to import]


              ## Types/Interfaces to Use

              ```typescript

              // From [source]

              interface [Name] {



















                [relevant fields]
              }

              ```


              ## Integration Points

              - Called by: [who will use this]

              - Calls: [what this will call]

              - Tests: [related test files]


              ## Implementation Notes

              - [Specific note 1]

              - [Specific note 2]

              ```


              ## Commit

              ```bash

              git add context/step-2-context.md

              git commit -m "context(step-2): gather implementation context"

              ```

          - id: execute
            status: pending
            prompt: >
              Implement the step following gherkin scenarios and context.


              ## Your Task

              Track B - Step 1: Create creating-workflows Skill Structure


              Create a new skill for workflow definition guidance.


              Requirements:

              - Create skills/creating-workflows/ directory structure

              - Create main skill file: skills/creating-workflows/creating-workflows.md

              - Create references/ subdirectory with:



















                - workflow-schema.md (Full YAML schema reference)
                - template-variables.md (All available template variables)
                - phase-types.md (Simple vs for-each phase explanations)
                - workflow-patterns.md (Common workflow patterns)
              - Create assets/ subdirectory with:



















                - feature-workflow.yaml (Example feature workflow)
                - bugfix-workflow.yaml (Example bugfix workflow)
                - validation-checklist.md (Pre-deployment checklist)
              - Main skill file should trigger on: "create workflow", "new workflow", "workflow definition", "define phases"

              - Include comprehensive documentation for workflow authoring

              - Reference existing workflows in .claude/workflows/ as examples


              New files to create:

              - skills/creating-workflows/creating-workflows.md

              - skills/creating-workflows/references/*.md

              - skills/creating-workflows/assets/*.{yaml,md}



              ## MUST READ BEFORE IMPLEMENTING

              Read these files in order:

              1. context/_shared-context.md (project patterns, conventions)

              2. context/sprint-plan.md (how this fits in sprint)

              3. artifacts/step-2-gherkin.md (scenarios to satisfy)

              4. context/step-2-context.md (specific patterns, imports)


              ## Implementation Rules


              ### Follow the Gherkin

              Your implementation MUST satisfy ALL gherkin scenarios.

              Each scenario has a verification command - mentally run it to check your work.


              ### Follow the Context

              - Use patterns from similar implementations

              - Import from specified modules

              - Implement required interfaces

              - Follow naming conventions


              ### Code Quality

              - Keep code simple and focused

              - Follow existing patterns exactly

              - No over-engineering or extra abstractions

              - Only implement what's needed for the scenarios


              ### Commits

              Make atomic commits for logical units:

              ```bash

              # After each logical piece

              git add [files]

              git commit -m "[type](step-2): [description]"

              ```


              Types: feat, fix, refactor, test, docs


              ## Implementation Checklist

              Before marking complete, verify:

              - [ ] All files from gherkin scenarios exist

              - [ ] Code follows patterns from context

              - [ ] Imports are correct

              - [ ] No TypeScript errors (run typecheck mentally)

              - [ ] Each scenario's verification should pass


              ## If Blocked

              If you encounter an issue that prevents completion:

              - Document the blocker clearly

              - Set status to needs-human

              - Do NOT leave partial/broken implementation

          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-2-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-2-qa-report.md

              ```markdown
              # QA Report: step-2

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-2-qa-report.md
                 git commit -m "qa(step-2): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-2.\n\n## Context\nRead: artifacts/step-2-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-2-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-2-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-2 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: >
              Final integration verification for the step.


              ## Your Task

              Track B - Step 1: Create creating-workflows Skill Structure


              Create a new skill for workflow definition guidance.


              Requirements:

              - Create skills/creating-workflows/ directory structure

              - Create main skill file: skills/creating-workflows/creating-workflows.md

              - Create references/ subdirectory with:



















                - workflow-schema.md (Full YAML schema reference)
                - template-variables.md (All available template variables)
                - phase-types.md (Simple vs for-each phase explanations)
                - workflow-patterns.md (Common workflow patterns)
              - Create assets/ subdirectory with:



















                - feature-workflow.yaml (Example feature workflow)
                - bugfix-workflow.yaml (Example bugfix workflow)
                - validation-checklist.md (Pre-deployment checklist)
              - Main skill file should trigger on: "create workflow", "new workflow", "workflow definition", "define phases"

              - Include comprehensive documentation for workflow authoring

              - Reference existing workflows in .claude/workflows/ as examples


              New files to create:

              - skills/creating-workflows/creating-workflows.md

              - skills/creating-workflows/references/*.md

              - skills/creating-workflows/assets/*.{yaml,md}



              ## Context

              Read: context/_shared-context.md (build commands)

              Read: artifacts/step-2-qa-report.md (should show PASS)


              ## Step 1: Build Verification

              Run the project build to ensure this step integrates:

              ```bash

              # Use commands from _shared-context.md, typically:

              npm run build

              npm run typecheck

              ```


              ## Step 2: Integration Check

              Verify this step works with the rest of the sprint:

              - Check imports resolve correctly

              - Verify no circular dependencies

              - Ensure types are compatible


              ## Step 3: Smoke Test

              If possible, manually verify the functionality:

              - Run the code path that uses this step's output

              - Check expected behavior matches gherkin scenarios


              ## Step 4: Final Commit

              If all verification passes:

              ```bash

              git add -A

              git status  # Check for any uncommitted changes

              # Only commit if there are changes

              git diff --cached --quiet || git commit -m "verify(step-2): integration verified"

              ```


              ## Outcome

              - If integration passes: Mark step as complete

              - If integration fails: Document the issue and set status to needs-human


              ## Important

              This is the final gate before moving to the next step.

              The step's gherkin scenarios already passed in QA.

              This phase ensures the step works in the broader context.

      - id: step-3
        prompt: |
          Track B - Step 2: Create creating-sprints Skill Structure

          Create a new skill for sprint definition guidance.

          Requirements:
          - Create skills/creating-sprints/ directory structure
          - Create main skill file: skills/creating-sprints/creating-sprints.md
          - Create references/ subdirectory with:
            - sprint-schema.md (SPRINT.yaml structure reference)
            - step-writing-guide.md (How to write effective step prompts)
            - workflow-selection.md (Guide for choosing appropriate workflows)
          - Create assets/ subdirectory with:
            - sprint-template.yaml (Annotated example sprint definition)
          - Main skill file should trigger on: "create sprint", "new sprint", "sprint definition", "define steps"
          - Include best practices for step prompts (clear, actionable, scoped)
          - Guidance on sprint sizing (3-8 steps, single responsibility)
          - Integration instructions with existing workflows

          New files to create:
          - skills/creating-sprints/creating-sprints.md
          - skills/creating-sprints/references/*.md
          - skills/creating-sprints/assets/sprint-template.yaml
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Track B - Step 2: Create creating-sprints Skill Structure

              Create a new skill for sprint definition guidance.

              Requirements:
              - Create skills/creating-sprints/ directory structure
              - Create main skill file: skills/creating-sprints/creating-sprints.md
              - Create references/ subdirectory with:
                - sprint-schema.md (SPRINT.yaml structure reference)
                - step-writing-guide.md (How to write effective step prompts)
                - workflow-selection.md (Guide for choosing appropriate workflows)
              - Create assets/ subdirectory with:
                - sprint-template.yaml (Annotated example sprint definition)
              - Main skill file should trigger on: "create sprint", "new sprint", "sprint definition", "define steps"
              - Include best practices for step prompts (clear, actionable, scoped)
              - Guidance on sprint sizing (3-8 steps, single responsibility)
              - Integration instructions with existing workflows

              New files to create:
              - skills/creating-sprints/creating-sprints.md
              - skills/creating-sprints/references/*.md
              - skills/creating-sprints/assets/sprint-template.yaml


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-3-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-3

              ## Step Task
              Track B - Step 2: Create creating-sprints Skill Structure

              Create a new skill for sprint definition guidance.

              Requirements:
              - Create skills/creating-sprints/ directory structure
              - Create main skill file: skills/creating-sprints/creating-sprints.md
              - Create references/ subdirectory with:
                - sprint-schema.md (SPRINT.yaml structure reference)
                - step-writing-guide.md (How to write effective step prompts)
                - workflow-selection.md (Guide for choosing appropriate workflows)
              - Create assets/ subdirectory with:
                - sprint-template.yaml (Annotated example sprint definition)
              - Main skill file should trigger on: "create sprint", "new sprint", "sprint definition", "define steps"
              - Include best practices for step prompts (clear, actionable, scoped)
              - Guidance on sprint sizing (3-8 steps, single responsibility)
              - Integration instructions with existing workflows

              New files to create:
              - skills/creating-sprints/creating-sprints.md
              - skills/creating-sprints/references/*.md
              - skills/creating-sprints/assets/sprint-template.yaml


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-3-gherkin.md
              git commit -m "plan(step-3): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Track B - Step 2: Create creating-sprints Skill Structure

              Create a new skill for sprint definition guidance.

              Requirements:
              - Create skills/creating-sprints/ directory structure
              - Create main skill file: skills/creating-sprints/creating-sprints.md
              - Create references/ subdirectory with:
                - sprint-schema.md (SPRINT.yaml structure reference)
                - step-writing-guide.md (How to write effective step prompts)
                - workflow-selection.md (Guide for choosing appropriate workflows)
              - Create assets/ subdirectory with:
                - sprint-template.yaml (Annotated example sprint definition)
              - Main skill file should trigger on: "create sprint", "new sprint", "sprint definition", "define steps"
              - Include best practices for step prompts (clear, actionable, scoped)
              - Guidance on sprint sizing (3-8 steps, single responsibility)
              - Integration instructions with existing workflows

              New files to create:
              - skills/creating-sprints/creating-sprints.md
              - skills/creating-sprints/references/*.md
              - skills/creating-sprints/assets/sprint-template.yaml


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-3-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-3-context.md

              ```markdown
              # Step Context: step-3

              ## Task
              Track B - Step 2: Create creating-sprints Skill Structure

              Create a new skill for sprint definition guidance.

              Requirements:
              - Create skills/creating-sprints/ directory structure
              - Create main skill file: skills/creating-sprints/creating-sprints.md
              - Create references/ subdirectory with:
                - sprint-schema.md (SPRINT.yaml structure reference)
                - step-writing-guide.md (How to write effective step prompts)
                - workflow-selection.md (Guide for choosing appropriate workflows)
              - Create assets/ subdirectory with:
                - sprint-template.yaml (Annotated example sprint definition)
              - Main skill file should trigger on: "create sprint", "new sprint", "sprint definition", "define steps"
              - Include best practices for step prompts (clear, actionable, scoped)
              - Guidance on sprint sizing (3-8 steps, single responsibility)
              - Integration instructions with existing workflows

              New files to create:
              - skills/creating-sprints/creating-sprints.md
              - skills/creating-sprints/references/*.md
              - skills/creating-sprints/assets/sprint-template.yaml


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-3-context.md
              git commit -m "context(step-3): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Track B - Step 2: Create creating-sprints Skill Structure

              Create a new skill for sprint definition guidance.

              Requirements:
              - Create skills/creating-sprints/ directory structure
              - Create main skill file: skills/creating-sprints/creating-sprints.md
              - Create references/ subdirectory with:
                - sprint-schema.md (SPRINT.yaml structure reference)
                - step-writing-guide.md (How to write effective step prompts)
                - workflow-selection.md (Guide for choosing appropriate workflows)
              - Create assets/ subdirectory with:
                - sprint-template.yaml (Annotated example sprint definition)
              - Main skill file should trigger on: "create sprint", "new sprint", "sprint definition", "define steps"
              - Include best practices for step prompts (clear, actionable, scoped)
              - Guidance on sprint sizing (3-8 steps, single responsibility)
              - Integration instructions with existing workflows

              New files to create:
              - skills/creating-sprints/creating-sprints.md
              - skills/creating-sprints/references/*.md
              - skills/creating-sprints/assets/sprint-template.yaml


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-3-gherkin.md (scenarios to satisfy)
              4. context/step-3-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-3): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-3-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-3-qa-report.md

              ```markdown
              # QA Report: step-3

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-3-qa-report.md
                 git commit -m "qa(step-3): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-3.\n\n## Context\nRead: artifacts/step-3-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-3-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-3-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-3 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Track B - Step 2: Create creating-sprints Skill Structure

              Create a new skill for sprint definition guidance.

              Requirements:
              - Create skills/creating-sprints/ directory structure
              - Create main skill file: skills/creating-sprints/creating-sprints.md
              - Create references/ subdirectory with:
                - sprint-schema.md (SPRINT.yaml structure reference)
                - step-writing-guide.md (How to write effective step prompts)
                - workflow-selection.md (Guide for choosing appropriate workflows)
              - Create assets/ subdirectory with:
                - sprint-template.yaml (Annotated example sprint definition)
              - Main skill file should trigger on: "create sprint", "new sprint", "sprint definition", "define steps"
              - Include best practices for step prompts (clear, actionable, scoped)
              - Guidance on sprint sizing (3-8 steps, single responsibility)
              - Integration instructions with existing workflows

              New files to create:
              - skills/creating-sprints/creating-sprints.md
              - skills/creating-sprints/references/*.md
              - skills/creating-sprints/assets/sprint-template.yaml


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-3-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-3): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-4
        prompt: |
          Track C - Step 1: Create Sprint Activity Hook Script

          Implement PostToolCall hook for sprint activity logging.

          Requirements:
          - Create hooks/sprint-activity-hook.sh shell script
          - Hook receives sprint directory path as argument
          - Parse Claude Code tool call information from stdin (JSON format)
          - Extract: tool name, file paths, key parameters, timestamps
          - Write activity events to <sprint-dir>/.sprint-activity.jsonl in JSONL format
          - Support verbosity levels: minimal, basic, detailed, verbose
          - Event format: {"ts":"ISO-timestamp","type":"tool","tool":"ToolName","file":"path","level":"basic"}
          - Handle different tool types: Read, Write, Edit, Bash, Grep, Glob, etc.
          - Ensure atomic writes to prevent corruption
          - Add error handling for malformed input

          New file to create:
          - hooks/sprint-activity-hook.sh

          Reference:
          - Claude Code hook documentation for PostToolCall format
          - Existing hook examples in the codebase
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Track C - Step 1: Create Sprint Activity Hook Script

              Implement PostToolCall hook for sprint activity logging.

              Requirements:
              - Create hooks/sprint-activity-hook.sh shell script
              - Hook receives sprint directory path as argument
              - Parse Claude Code tool call information from stdin (JSON format)
              - Extract: tool name, file paths, key parameters, timestamps
              - Write activity events to <sprint-dir>/.sprint-activity.jsonl in JSONL format
              - Support verbosity levels: minimal, basic, detailed, verbose
              - Event format: {"ts":"ISO-timestamp","type":"tool","tool":"ToolName","file":"path","level":"basic"}
              - Handle different tool types: Read, Write, Edit, Bash, Grep, Glob, etc.
              - Ensure atomic writes to prevent corruption
              - Add error handling for malformed input

              New file to create:
              - hooks/sprint-activity-hook.sh

              Reference:
              - Claude Code hook documentation for PostToolCall format
              - Existing hook examples in the codebase


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-4-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-4

              ## Step Task
              Track C - Step 1: Create Sprint Activity Hook Script

              Implement PostToolCall hook for sprint activity logging.

              Requirements:
              - Create hooks/sprint-activity-hook.sh shell script
              - Hook receives sprint directory path as argument
              - Parse Claude Code tool call information from stdin (JSON format)
              - Extract: tool name, file paths, key parameters, timestamps
              - Write activity events to <sprint-dir>/.sprint-activity.jsonl in JSONL format
              - Support verbosity levels: minimal, basic, detailed, verbose
              - Event format: {"ts":"ISO-timestamp","type":"tool","tool":"ToolName","file":"path","level":"basic"}
              - Handle different tool types: Read, Write, Edit, Bash, Grep, Glob, etc.
              - Ensure atomic writes to prevent corruption
              - Add error handling for malformed input

              New file to create:
              - hooks/sprint-activity-hook.sh

              Reference:
              - Claude Code hook documentation for PostToolCall format
              - Existing hook examples in the codebase


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-4-gherkin.md
              git commit -m "plan(step-4): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Track C - Step 1: Create Sprint Activity Hook Script

              Implement PostToolCall hook for sprint activity logging.

              Requirements:
              - Create hooks/sprint-activity-hook.sh shell script
              - Hook receives sprint directory path as argument
              - Parse Claude Code tool call information from stdin (JSON format)
              - Extract: tool name, file paths, key parameters, timestamps
              - Write activity events to <sprint-dir>/.sprint-activity.jsonl in JSONL format
              - Support verbosity levels: minimal, basic, detailed, verbose
              - Event format: {"ts":"ISO-timestamp","type":"tool","tool":"ToolName","file":"path","level":"basic"}
              - Handle different tool types: Read, Write, Edit, Bash, Grep, Glob, etc.
              - Ensure atomic writes to prevent corruption
              - Add error handling for malformed input

              New file to create:
              - hooks/sprint-activity-hook.sh

              Reference:
              - Claude Code hook documentation for PostToolCall format
              - Existing hook examples in the codebase


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-4-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-4-context.md

              ```markdown
              # Step Context: step-4

              ## Task
              Track C - Step 1: Create Sprint Activity Hook Script

              Implement PostToolCall hook for sprint activity logging.

              Requirements:
              - Create hooks/sprint-activity-hook.sh shell script
              - Hook receives sprint directory path as argument
              - Parse Claude Code tool call information from stdin (JSON format)
              - Extract: tool name, file paths, key parameters, timestamps
              - Write activity events to <sprint-dir>/.sprint-activity.jsonl in JSONL format
              - Support verbosity levels: minimal, basic, detailed, verbose
              - Event format: {"ts":"ISO-timestamp","type":"tool","tool":"ToolName","file":"path","level":"basic"}
              - Handle different tool types: Read, Write, Edit, Bash, Grep, Glob, etc.
              - Ensure atomic writes to prevent corruption
              - Add error handling for malformed input

              New file to create:
              - hooks/sprint-activity-hook.sh

              Reference:
              - Claude Code hook documentation for PostToolCall format
              - Existing hook examples in the codebase


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-4-context.md
              git commit -m "context(step-4): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Track C - Step 1: Create Sprint Activity Hook Script

              Implement PostToolCall hook for sprint activity logging.

              Requirements:
              - Create hooks/sprint-activity-hook.sh shell script
              - Hook receives sprint directory path as argument
              - Parse Claude Code tool call information from stdin (JSON format)
              - Extract: tool name, file paths, key parameters, timestamps
              - Write activity events to <sprint-dir>/.sprint-activity.jsonl in JSONL format
              - Support verbosity levels: minimal, basic, detailed, verbose
              - Event format: {"ts":"ISO-timestamp","type":"tool","tool":"ToolName","file":"path","level":"basic"}
              - Handle different tool types: Read, Write, Edit, Bash, Grep, Glob, etc.
              - Ensure atomic writes to prevent corruption
              - Add error handling for malformed input

              New file to create:
              - hooks/sprint-activity-hook.sh

              Reference:
              - Claude Code hook documentation for PostToolCall format
              - Existing hook examples in the codebase


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-4-gherkin.md (scenarios to satisfy)
              4. context/step-4-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-4): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-4-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-4-qa-report.md

              ```markdown
              # QA Report: step-4

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-4-qa-report.md
                 git commit -m "qa(step-4): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-4.\n\n## Context\nRead: artifacts/step-4-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-4-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-4-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-4 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Track C - Step 1: Create Sprint Activity Hook Script

              Implement PostToolCall hook for sprint activity logging.

              Requirements:
              - Create hooks/sprint-activity-hook.sh shell script
              - Hook receives sprint directory path as argument
              - Parse Claude Code tool call information from stdin (JSON format)
              - Extract: tool name, file paths, key parameters, timestamps
              - Write activity events to <sprint-dir>/.sprint-activity.jsonl in JSONL format
              - Support verbosity levels: minimal, basic, detailed, verbose
              - Event format: {"ts":"ISO-timestamp","type":"tool","tool":"ToolName","file":"path","level":"basic"}
              - Handle different tool types: Read, Write, Edit, Bash, Grep, Glob, etc.
              - Ensure atomic writes to prevent corruption
              - Add error handling for malformed input

              New file to create:
              - hooks/sprint-activity-hook.sh

              Reference:
              - Claude Code hook documentation for PostToolCall format
              - Existing hook examples in the codebase


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-4-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-4): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-5
        prompt: |
          Track C - Step 2: Implement Activity Watcher in Status Server

          Add activity log watching and SSE streaming to status server.

          Requirements:
          - Create compiler/src/status-server/activity-watcher.ts module
          - Create compiler/src/status-server/activity-types.ts with TypeScript types
          - Watch .sprint-activity.jsonl file for changes using fs.watch or chokidar
          - Parse JSONL events and validate against activity types
          - Stream activity events via SSE to status page clients
          - Filter events based on verbosity level (stored in client preference)
          - Handle log rotation and large files efficiently
          - Add error recovery for corrupted log entries
          - Export ActivityWatcher class for integration with server.ts

          New files to create:
          - compiler/src/status-server/activity-watcher.ts
          - compiler/src/status-server/activity-types.ts

          Files to modify:
          - compiler/src/status-server/server.ts (integrate ActivityWatcher)
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Track C - Step 2: Implement Activity Watcher in Status Server

              Add activity log watching and SSE streaming to status server.

              Requirements:
              - Create compiler/src/status-server/activity-watcher.ts module
              - Create compiler/src/status-server/activity-types.ts with TypeScript types
              - Watch .sprint-activity.jsonl file for changes using fs.watch or chokidar
              - Parse JSONL events and validate against activity types
              - Stream activity events via SSE to status page clients
              - Filter events based on verbosity level (stored in client preference)
              - Handle log rotation and large files efficiently
              - Add error recovery for corrupted log entries
              - Export ActivityWatcher class for integration with server.ts

              New files to create:
              - compiler/src/status-server/activity-watcher.ts
              - compiler/src/status-server/activity-types.ts

              Files to modify:
              - compiler/src/status-server/server.ts (integrate ActivityWatcher)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-5-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-5

              ## Step Task
              Track C - Step 2: Implement Activity Watcher in Status Server

              Add activity log watching and SSE streaming to status server.

              Requirements:
              - Create compiler/src/status-server/activity-watcher.ts module
              - Create compiler/src/status-server/activity-types.ts with TypeScript types
              - Watch .sprint-activity.jsonl file for changes using fs.watch or chokidar
              - Parse JSONL events and validate against activity types
              - Stream activity events via SSE to status page clients
              - Filter events based on verbosity level (stored in client preference)
              - Handle log rotation and large files efficiently
              - Add error recovery for corrupted log entries
              - Export ActivityWatcher class for integration with server.ts

              New files to create:
              - compiler/src/status-server/activity-watcher.ts
              - compiler/src/status-server/activity-types.ts

              Files to modify:
              - compiler/src/status-server/server.ts (integrate ActivityWatcher)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-5-gherkin.md
              git commit -m "plan(step-5): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Track C - Step 2: Implement Activity Watcher in Status Server

              Add activity log watching and SSE streaming to status server.

              Requirements:
              - Create compiler/src/status-server/activity-watcher.ts module
              - Create compiler/src/status-server/activity-types.ts with TypeScript types
              - Watch .sprint-activity.jsonl file for changes using fs.watch or chokidar
              - Parse JSONL events and validate against activity types
              - Stream activity events via SSE to status page clients
              - Filter events based on verbosity level (stored in client preference)
              - Handle log rotation and large files efficiently
              - Add error recovery for corrupted log entries
              - Export ActivityWatcher class for integration with server.ts

              New files to create:
              - compiler/src/status-server/activity-watcher.ts
              - compiler/src/status-server/activity-types.ts

              Files to modify:
              - compiler/src/status-server/server.ts (integrate ActivityWatcher)


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-5-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-5-context.md

              ```markdown
              # Step Context: step-5

              ## Task
              Track C - Step 2: Implement Activity Watcher in Status Server

              Add activity log watching and SSE streaming to status server.

              Requirements:
              - Create compiler/src/status-server/activity-watcher.ts module
              - Create compiler/src/status-server/activity-types.ts with TypeScript types
              - Watch .sprint-activity.jsonl file for changes using fs.watch or chokidar
              - Parse JSONL events and validate against activity types
              - Stream activity events via SSE to status page clients
              - Filter events based on verbosity level (stored in client preference)
              - Handle log rotation and large files efficiently
              - Add error recovery for corrupted log entries
              - Export ActivityWatcher class for integration with server.ts

              New files to create:
              - compiler/src/status-server/activity-watcher.ts
              - compiler/src/status-server/activity-types.ts

              Files to modify:
              - compiler/src/status-server/server.ts (integrate ActivityWatcher)


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-5-context.md
              git commit -m "context(step-5): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Track C - Step 2: Implement Activity Watcher in Status Server

              Add activity log watching and SSE streaming to status server.

              Requirements:
              - Create compiler/src/status-server/activity-watcher.ts module
              - Create compiler/src/status-server/activity-types.ts with TypeScript types
              - Watch .sprint-activity.jsonl file for changes using fs.watch or chokidar
              - Parse JSONL events and validate against activity types
              - Stream activity events via SSE to status page clients
              - Filter events based on verbosity level (stored in client preference)
              - Handle log rotation and large files efficiently
              - Add error recovery for corrupted log entries
              - Export ActivityWatcher class for integration with server.ts

              New files to create:
              - compiler/src/status-server/activity-watcher.ts
              - compiler/src/status-server/activity-types.ts

              Files to modify:
              - compiler/src/status-server/server.ts (integrate ActivityWatcher)


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-5-gherkin.md (scenarios to satisfy)
              4. context/step-5-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-5): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-5-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-5-qa-report.md

              ```markdown
              # QA Report: step-5

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-5-qa-report.md
                 git commit -m "qa(step-5): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-5.\n\n## Context\nRead: artifacts/step-5-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-5-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-5-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-5 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Track C - Step 2: Implement Activity Watcher in Status Server

              Add activity log watching and SSE streaming to status server.

              Requirements:
              - Create compiler/src/status-server/activity-watcher.ts module
              - Create compiler/src/status-server/activity-types.ts with TypeScript types
              - Watch .sprint-activity.jsonl file for changes using fs.watch or chokidar
              - Parse JSONL events and validate against activity types
              - Stream activity events via SSE to status page clients
              - Filter events based on verbosity level (stored in client preference)
              - Handle log rotation and large files efficiently
              - Add error recovery for corrupted log entries
              - Export ActivityWatcher class for integration with server.ts

              New files to create:
              - compiler/src/status-server/activity-watcher.ts
              - compiler/src/status-server/activity-types.ts

              Files to modify:
              - compiler/src/status-server/server.ts (integrate ActivityWatcher)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-5-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-5): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-6
        prompt: "Track C - Step 3: Add Live Activity UI Panel to Status Page\n\nImplement Live Activity display panel in the status page.\n\nRequirements:\n- Add \"Live Activity\" panel below current task section\n- Subscribe to activity SSE events from server\n- Display activity entries with timestamps, icons, and descriptions\n- Add verbosity dropdown selector (Minimal/Basic/Detailed/Verbose)\n- Store verbosity preference in localStorage\n- Implement auto-scroll behavior with manual scroll lock\n- Add \"Clear Activity\" button to reset display\n- Use appropriate icons for different tool types (Read=\U0001F4D6, Write=✏️, Bash=⚡, etc.)\n- Limit displayed entries (e.g., last 100) for performance\n- Style consistently with existing GitHub dark theme\n\nFiles to modify:\n- compiler/src/status-server/page.ts\n\nDesign considerations:\n- Activity panel should be collapsible to save space\n- Timestamps should be relative (e.g., \"2s ago\") with tooltip showing absolute time\n- Long file paths should be truncated with tooltip showing full path\n"
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: "Generate binary-verifiable gherkin scenarios for this step.\n\n## Your Task\nTrack C - Step 3: Add Live Activity UI Panel to Status Page\n\nImplement Live Activity display panel in the status page.\n\nRequirements:\n- Add \"Live Activity\" panel below current task section\n- Subscribe to activity SSE events from server\n- Display activity entries with timestamps, icons, and descriptions\n- Add verbosity dropdown selector (Minimal/Basic/Detailed/Verbose)\n- Store verbosity preference in localStorage\n- Implement auto-scroll behavior with manual scroll lock\n- Add \"Clear Activity\" button to reset display\n- Use appropriate icons for different tool types (Read=\U0001F4D6, Write=✏️, Bash=⚡, etc.)\n- Limit displayed entries (e.g., last 100) for performance\n- Style consistently with existing GitHub dark theme\n\nFiles to modify:\n- compiler/src/status-server/page.ts\n\nDesign considerations:\n- Activity panel should be collapsible to save space\n- Timestamps should be relative (e.g., \"2s ago\") with tooltip showing absolute time\n- Long file paths should be truncated with tooltip showing full path\n\n\n## Shared Context\nRead: context/_shared-context.md (project patterns, conventions, commands)\nRead: context/sprint-plan.md (how this step fits in the sprint)\n\n## Instructions\nCreate 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.\nEach scenario MUST have:\n1. Clear Given/When/Then structure\n2. An explicit verification command that returns exit code 0 on success\n3. Binary outcome: exactly 1 (pass) or 0 (fail)\n\n## Gherkin Format\nEach scenario follows this exact structure:\n\n```gherkin\nScenario: [Descriptive name]\n  Given [precondition or context]\n  When [action taken]\n  Then [expected outcome]\n\nVerification: `[shell command that exits 0 on success, non-zero on failure]`\nPass: Exit code = 0 → Score 1\nFail: Exit code ≠ 0 → Score 0\n```\n\n## Example Scenarios\n\n### File Existence\n```gherkin\nScenario: Source file exists\n  Given the project structure is set up\n  When I check for the module file\n  Then src/auth/service.ts exists\n\nVerification: `test -f src/auth/service.ts`\nPass: Exit code = 0 → Score 1\nFail: Exit code ≠ 0 → Score 0\n```\n\n### TypeScript Compilation\n```gherkin\nScenario: TypeScript compiles without errors\n  Given the file src/auth/service.ts exists\n  When I run the TypeScript compiler\n  Then no compilation errors occur\n\nVerification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`\nPass: Last line = 0 → Score 1\nFail: Last line ≠ 0 → Score 0\n```\n\n### Function Export\n```gherkin\nScenario: Login function is exported\n  Given src/auth/service.ts exists\n  When I check for the login export\n  Then the function is publicly available\n\nVerification: `grep -q \"export.*function login\\|export.*const login\\|export { login\" src/auth/service.ts`\nPass: Exit code = 0 → Score 1\nFail: Exit code ≠ 0 → Score 0\n```\n\n### Test Execution\n```gherkin\nScenario: Unit tests pass\n  Given tests exist in src/auth/service.test.ts\n  When I run the test suite\n  Then all tests pass\n\nVerification: `npm test -- --testPathPattern=\"auth/service\" --passWithNoTests 2>&1; echo $?`\nPass: Last line = 0 → Score 1\nFail: Last line ≠ 0 → Score 0\n```\n\n### Lint Check\n```gherkin\nScenario: Code passes linting\n  Given the implementation is complete\n  When I run the linter\n  Then no lint errors in new files\n\nVerification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`\nPass: Last line = 0 → Score 1\nFail: Last line ≠ 0 → Score 0\n```\n\n## Output\nCreate: artifacts/step-6-gherkin.md\n\n```markdown\n# Gherkin Scenarios: step-6\n\n## Step Task\nTrack C - Step 3: Add Live Activity UI Panel to Status Page\n\nImplement Live Activity display panel in the status page.\n\nRequirements:\n- Add \"Live Activity\" panel below current task section\n- Subscribe to activity SSE events from server\n- Display activity entries with timestamps, icons, and descriptions\n- Add verbosity dropdown selector (Minimal/Basic/Detailed/Verbose)\n- Store verbosity preference in localStorage\n- Implement auto-scroll behavior with manual scroll lock\n- Add \"Clear Activity\" button to reset display\n- Use appropriate icons for different tool types (Read=\U0001F4D6, Write=✏️, Bash=⚡, etc.)\n- Limit displayed entries (e.g., last 100) for performance\n- Style consistently with existing GitHub dark theme\n\nFiles to modify:\n- compiler/src/status-server/page.ts\n\nDesign considerations:\n- Activity panel should be collapsible to save space\n- Timestamps should be relative (e.g., \"2s ago\") with tooltip showing absolute time\n- Long file paths should be truncated with tooltip showing full path\n\n\n## Success Criteria\nAll scenarios must pass (score = 1) for the step to be complete.\nTotal scenarios: [N]\nRequired score: [N]/[N]\n\n---\n\n## Scenario 1: [Name]\n[Full gherkin with verification as shown above]\n\n---\n\n## Scenario 2: [Name]\n...\n\n[Continue for 4-8 scenarios]\n```\n\n## Commit\n```bash\ngit add artifacts/step-6-gherkin.md\ngit commit -m \"plan(step-6): define gherkin scenarios\"\n```\n"
          - id: context
            status: pending
            prompt: "Gather step-specific context for implementation.\n\n## Your Task\nTrack C - Step 3: Add Live Activity UI Panel to Status Page\n\nImplement Live Activity display panel in the status page.\n\nRequirements:\n- Add \"Live Activity\" panel below current task section\n- Subscribe to activity SSE events from server\n- Display activity entries with timestamps, icons, and descriptions\n- Add verbosity dropdown selector (Minimal/Basic/Detailed/Verbose)\n- Store verbosity preference in localStorage\n- Implement auto-scroll behavior with manual scroll lock\n- Add \"Clear Activity\" button to reset display\n- Use appropriate icons for different tool types (Read=\U0001F4D6, Write=✏️, Bash=⚡, etc.)\n- Limit displayed entries (e.g., last 100) for performance\n- Style consistently with existing GitHub dark theme\n\nFiles to modify:\n- compiler/src/status-server/page.ts\n\nDesign considerations:\n- Activity panel should be collapsible to save space\n- Timestamps should be relative (e.g., \"2s ago\") with tooltip showing absolute time\n- Long file paths should be truncated with tooltip showing full path\n\n\n## Shared Context\nRead: context/_shared-context.md (already has project-wide patterns)\nRead: artifacts/step-6-gherkin.md (scenarios to implement)\n\n## Instructions\nResearch the specific code areas this step will touch:\n\n1. **Related Existing Code**\n   - Find similar implementations to follow as patterns\n   - Identify modules this step will import from\n   - Note any interfaces/types to implement or extend\n\n2. **Dependencies**\n   - List imports needed from internal modules\n   - List any new external packages needed\n   - Check for peer dependencies or version constraints\n\n3. **Integration Points**\n   - How will this code be called/used?\n   - What modules will import from this step's output?\n   - Are there existing tests to extend?\n\n4. **Specific Patterns**\n   - Error handling patterns used in similar code\n   - Naming conventions for this area\n   - File organization patterns\n\n## Output\nCreate: context/step-6-context.md\n\n```markdown\n# Step Context: step-6\n\n## Task\nTrack C - Step 3: Add Live Activity UI Panel to Status Page\n\nImplement Live Activity display panel in the status page.\n\nRequirements:\n- Add \"Live Activity\" panel below current task section\n- Subscribe to activity SSE events from server\n- Display activity entries with timestamps, icons, and descriptions\n- Add verbosity dropdown selector (Minimal/Basic/Detailed/Verbose)\n- Store verbosity preference in localStorage\n- Implement auto-scroll behavior with manual scroll lock\n- Add \"Clear Activity\" button to reset display\n- Use appropriate icons for different tool types (Read=\U0001F4D6, Write=✏️, Bash=⚡, etc.)\n- Limit displayed entries (e.g., last 100) for performance\n- Style consistently with existing GitHub dark theme\n\nFiles to modify:\n- compiler/src/status-server/page.ts\n\nDesign considerations:\n- Activity panel should be collapsible to save space\n- Timestamps should be relative (e.g., \"2s ago\") with tooltip showing absolute time\n- Long file paths should be truncated with tooltip showing full path\n\n\n## Related Code Patterns\n\n### Similar Implementation: [path]\n```typescript\n// Key pattern to follow\n[relevant code snippet]\n```\n\n### Similar Implementation: [path]\n[continue as needed]\n\n## Required Imports\n### Internal\n- `[module]`: [what to import]\n\n### External\n- `[package]`: [what to import]\n\n## Types/Interfaces to Use\n```typescript\n// From [source]\ninterface [Name] {\n  [relevant fields]\n}\n```\n\n## Integration Points\n- Called by: [who will use this]\n- Calls: [what this will call]\n- Tests: [related test files]\n\n## Implementation Notes\n- [Specific note 1]\n- [Specific note 2]\n```\n\n## Commit\n```bash\ngit add context/step-6-context.md\ngit commit -m \"context(step-6): gather implementation context\"\n```\n"
          - id: execute
            status: pending
            prompt: "Implement the step following gherkin scenarios and context.\n\n## Your Task\nTrack C - Step 3: Add Live Activity UI Panel to Status Page\n\nImplement Live Activity display panel in the status page.\n\nRequirements:\n- Add \"Live Activity\" panel below current task section\n- Subscribe to activity SSE events from server\n- Display activity entries with timestamps, icons, and descriptions\n- Add verbosity dropdown selector (Minimal/Basic/Detailed/Verbose)\n- Store verbosity preference in localStorage\n- Implement auto-scroll behavior with manual scroll lock\n- Add \"Clear Activity\" button to reset display\n- Use appropriate icons for different tool types (Read=\U0001F4D6, Write=✏️, Bash=⚡, etc.)\n- Limit displayed entries (e.g., last 100) for performance\n- Style consistently with existing GitHub dark theme\n\nFiles to modify:\n- compiler/src/status-server/page.ts\n\nDesign considerations:\n- Activity panel should be collapsible to save space\n- Timestamps should be relative (e.g., \"2s ago\") with tooltip showing absolute time\n- Long file paths should be truncated with tooltip showing full path\n\n\n## MUST READ BEFORE IMPLEMENTING\nRead these files in order:\n1. context/_shared-context.md (project patterns, conventions)\n2. context/sprint-plan.md (how this fits in sprint)\n3. artifacts/step-6-gherkin.md (scenarios to satisfy)\n4. context/step-6-context.md (specific patterns, imports)\n\n## Implementation Rules\n\n### Follow the Gherkin\nYour implementation MUST satisfy ALL gherkin scenarios.\nEach scenario has a verification command - mentally run it to check your work.\n\n### Follow the Context\n- Use patterns from similar implementations\n- Import from specified modules\n- Implement required interfaces\n- Follow naming conventions\n\n### Code Quality\n- Keep code simple and focused\n- Follow existing patterns exactly\n- No over-engineering or extra abstractions\n- Only implement what's needed for the scenarios\n\n### Commits\nMake atomic commits for logical units:\n```bash\n# After each logical piece\ngit add [files]\ngit commit -m \"[type](step-6): [description]\"\n```\n\nTypes: feat, fix, refactor, test, docs\n\n## Implementation Checklist\nBefore marking complete, verify:\n- [ ] All files from gherkin scenarios exist\n- [ ] Code follows patterns from context\n- [ ] Imports are correct\n- [ ] No TypeScript errors (run typecheck mentally)\n- [ ] Each scenario's verification should pass\n\n## If Blocked\nIf you encounter an issue that prevents completion:\n- Document the blocker clearly\n- Set status to needs-human\n- Do NOT leave partial/broken implementation\n"
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-6-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-6-qa-report.md

              ```markdown
              # QA Report: step-6

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-6-qa-report.md
                 git commit -m "qa(step-6): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-6.\n\n## Context\nRead: artifacts/step-6-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-6-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-6-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-6 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: "Final integration verification for the step.\n\n## Your Task\nTrack C - Step 3: Add Live Activity UI Panel to Status Page\n\nImplement Live Activity display panel in the status page.\n\nRequirements:\n- Add \"Live Activity\" panel below current task section\n- Subscribe to activity SSE events from server\n- Display activity entries with timestamps, icons, and descriptions\n- Add verbosity dropdown selector (Minimal/Basic/Detailed/Verbose)\n- Store verbosity preference in localStorage\n- Implement auto-scroll behavior with manual scroll lock\n- Add \"Clear Activity\" button to reset display\n- Use appropriate icons for different tool types (Read=\U0001F4D6, Write=✏️, Bash=⚡, etc.)\n- Limit displayed entries (e.g., last 100) for performance\n- Style consistently with existing GitHub dark theme\n\nFiles to modify:\n- compiler/src/status-server/page.ts\n\nDesign considerations:\n- Activity panel should be collapsible to save space\n- Timestamps should be relative (e.g., \"2s ago\") with tooltip showing absolute time\n- Long file paths should be truncated with tooltip showing full path\n\n\n## Context\nRead: context/_shared-context.md (build commands)\nRead: artifacts/step-6-qa-report.md (should show PASS)\n\n## Step 1: Build Verification\nRun the project build to ensure this step integrates:\n```bash\n# Use commands from _shared-context.md, typically:\nnpm run build\nnpm run typecheck\n```\n\n## Step 2: Integration Check\nVerify this step works with the rest of the sprint:\n- Check imports resolve correctly\n- Verify no circular dependencies\n- Ensure types are compatible\n\n## Step 3: Smoke Test\nIf possible, manually verify the functionality:\n- Run the code path that uses this step's output\n- Check expected behavior matches gherkin scenarios\n\n## Step 4: Final Commit\nIf all verification passes:\n```bash\ngit add -A\ngit status  # Check for any uncommitted changes\n# Only commit if there are changes\ngit diff --cached --quiet || git commit -m \"verify(step-6): integration verified\"\n```\n\n## Outcome\n- If integration passes: Mark step as complete\n- If integration fails: Document the issue and set status to needs-human\n\n## Important\nThis is the final gate before moving to the next step.\nThe step's gherkin scenarios already passed in QA.\nThis phase ensures the step works in the broader context.\n"
      - id: step-7
        prompt: >
          Track C - Step 4: Integrate Hook Auto-Configuration in run-sprint


          Automatically configure and inject sprint activity hook during sprint execution.


          Requirements:

          - Modify .claude/commands/m42-sprint/run-sprint command

          - Generate .sprint-hooks.json in sprint directory before execution

          - Hook config format: {"hooks":{"PostToolCall":[{"command":"bash $PLUGIN_DIR/hooks/sprint-activity-hook.sh $SPRINT_DIR"}]}}

          - Pass --hook-config flag to claude -p invocations in sprint-loop.sh

          - Clean up hook config file on sprint completion/stop

          - Ensure PLUGIN_DIR environment variable is available to hook

          - Add verbosity level detection from status page preferences (or default to "basic")

          - Document hook configuration in USER-GUIDE.md


          Files to modify:

          - .claude/commands/m42-sprint/run-sprint

          - scripts/sprint-loop.sh (add --hook-config flag to claude invocations)


          Reference:

          - Existing sprint-loop.sh for claude -p invocation pattern

          - Claude Code --hook-config documentation

        status: pending
        phases:
          - id: plan
            status: pending
            prompt: >
              Generate binary-verifiable gherkin scenarios for this step.


              ## Your Task

              Track C - Step 4: Integrate Hook Auto-Configuration in run-sprint


              Automatically configure and inject sprint activity hook during sprint execution.


              Requirements:

              - Modify .claude/commands/m42-sprint/run-sprint command

              - Generate .sprint-hooks.json in sprint directory before execution

              - Hook config format: {"hooks":{"PostToolCall":[{"command":"bash $PLUGIN_DIR/hooks/sprint-activity-hook.sh $SPRINT_DIR"}]}}

              - Pass --hook-config flag to claude -p invocations in sprint-loop.sh

              - Clean up hook config file on sprint completion/stop

              - Ensure PLUGIN_DIR environment variable is available to hook

              - Add verbosity level detection from status page preferences (or default to "basic")

              - Document hook configuration in USER-GUIDE.md


              Files to modify:

              - .claude/commands/m42-sprint/run-sprint

              - scripts/sprint-loop.sh (add --hook-config flag to claude invocations)


              Reference:

              - Existing sprint-loop.sh for claude -p invocation pattern

              - Claude Code --hook-config documentation



              ## Shared Context

              Read: context/_shared-context.md (project patterns, conventions, commands)

              Read: context/sprint-plan.md (how this step fits in the sprint)


              ## Instructions

              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.

              Each scenario MUST have:

              1. Clear Given/When/Then structure

              2. An explicit verification command that returns exit code 0 on success

              3. Binary outcome: exactly 1 (pass) or 0 (fail)


              ## Gherkin Format

              Each scenario follows this exact structure:


              ```gherkin

              Scenario: [Descriptive name]



















                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ## Example Scenarios


              ### File Existence

              ```gherkin

              Scenario: Source file exists



















                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ### TypeScript Compilation

              ```gherkin

              Scenario: TypeScript compiles without errors



















                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ### Function Export

              ```gherkin

              Scenario: Login function is exported



















                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ### Test Execution

              ```gherkin

              Scenario: Unit tests pass



















                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ### Lint Check

              ```gherkin

              Scenario: Code passes linting



















                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ## Output

              Create: artifacts/step-7-gherkin.md


              ```markdown

              # Gherkin Scenarios: step-7


              ## Step Task

              Track C - Step 4: Integrate Hook Auto-Configuration in run-sprint


              Automatically configure and inject sprint activity hook during sprint execution.


              Requirements:

              - Modify .claude/commands/m42-sprint/run-sprint command

              - Generate .sprint-hooks.json in sprint directory before execution

              - Hook config format: {"hooks":{"PostToolCall":[{"command":"bash $PLUGIN_DIR/hooks/sprint-activity-hook.sh $SPRINT_DIR"}]}}

              - Pass --hook-config flag to claude -p invocations in sprint-loop.sh

              - Clean up hook config file on sprint completion/stop

              - Ensure PLUGIN_DIR environment variable is available to hook

              - Add verbosity level detection from status page preferences (or default to "basic")

              - Document hook configuration in USER-GUIDE.md


              Files to modify:

              - .claude/commands/m42-sprint/run-sprint

              - scripts/sprint-loop.sh (add --hook-config flag to claude invocations)


              Reference:

              - Existing sprint-loop.sh for claude -p invocation pattern

              - Claude Code --hook-config documentation



              ## Success Criteria

              All scenarios must pass (score = 1) for the step to be complete.

              Total scenarios: [N]

              Required score: [N]/[N]


              ---


              ## Scenario 1: [Name]

              [Full gherkin with verification as shown above]


              ---


              ## Scenario 2: [Name]

              ...


              [Continue for 4-8 scenarios]

              ```


              ## Commit

              ```bash

              git add artifacts/step-7-gherkin.md

              git commit -m "plan(step-7): define gherkin scenarios"

              ```

          - id: context
            status: pending
            prompt: >
              Gather step-specific context for implementation.


              ## Your Task

              Track C - Step 4: Integrate Hook Auto-Configuration in run-sprint


              Automatically configure and inject sprint activity hook during sprint execution.


              Requirements:

              - Modify .claude/commands/m42-sprint/run-sprint command

              - Generate .sprint-hooks.json in sprint directory before execution

              - Hook config format: {"hooks":{"PostToolCall":[{"command":"bash $PLUGIN_DIR/hooks/sprint-activity-hook.sh $SPRINT_DIR"}]}}

              - Pass --hook-config flag to claude -p invocations in sprint-loop.sh

              - Clean up hook config file on sprint completion/stop

              - Ensure PLUGIN_DIR environment variable is available to hook

              - Add verbosity level detection from status page preferences (or default to "basic")

              - Document hook configuration in USER-GUIDE.md


              Files to modify:

              - .claude/commands/m42-sprint/run-sprint

              - scripts/sprint-loop.sh (add --hook-config flag to claude invocations)


              Reference:

              - Existing sprint-loop.sh for claude -p invocation pattern

              - Claude Code --hook-config documentation



              ## Shared Context

              Read: context/_shared-context.md (already has project-wide patterns)

              Read: artifacts/step-7-gherkin.md (scenarios to implement)


              ## Instructions

              Research the specific code areas this step will touch:


              1. **Related Existing Code**



















                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**



















                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**



















                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**



















                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output

              Create: context/step-7-context.md


              ```markdown

              # Step Context: step-7


              ## Task

              Track C - Step 4: Integrate Hook Auto-Configuration in run-sprint


              Automatically configure and inject sprint activity hook during sprint execution.


              Requirements:

              - Modify .claude/commands/m42-sprint/run-sprint command

              - Generate .sprint-hooks.json in sprint directory before execution

              - Hook config format: {"hooks":{"PostToolCall":[{"command":"bash $PLUGIN_DIR/hooks/sprint-activity-hook.sh $SPRINT_DIR"}]}}

              - Pass --hook-config flag to claude -p invocations in sprint-loop.sh

              - Clean up hook config file on sprint completion/stop

              - Ensure PLUGIN_DIR environment variable is available to hook

              - Add verbosity level detection from status page preferences (or default to "basic")

              - Document hook configuration in USER-GUIDE.md


              Files to modify:

              - .claude/commands/m42-sprint/run-sprint

              - scripts/sprint-loop.sh (add --hook-config flag to claude invocations)


              Reference:

              - Existing sprint-loop.sh for claude -p invocation pattern

              - Claude Code --hook-config documentation



              ## Related Code Patterns


              ### Similar Implementation: [path]

              ```typescript

              // Key pattern to follow

              [relevant code snippet]

              ```


              ### Similar Implementation: [path]

              [continue as needed]


              ## Required Imports

              ### Internal

              - `[module]`: [what to import]


              ### External

              - `[package]`: [what to import]


              ## Types/Interfaces to Use

              ```typescript

              // From [source]

              interface [Name] {



















                [relevant fields]
              }

              ```


              ## Integration Points

              - Called by: [who will use this]

              - Calls: [what this will call]

              - Tests: [related test files]


              ## Implementation Notes

              - [Specific note 1]

              - [Specific note 2]

              ```


              ## Commit

              ```bash

              git add context/step-7-context.md

              git commit -m "context(step-7): gather implementation context"

              ```

          - id: execute
            status: pending
            prompt: >
              Implement the step following gherkin scenarios and context.


              ## Your Task

              Track C - Step 4: Integrate Hook Auto-Configuration in run-sprint


              Automatically configure and inject sprint activity hook during sprint execution.


              Requirements:

              - Modify .claude/commands/m42-sprint/run-sprint command

              - Generate .sprint-hooks.json in sprint directory before execution

              - Hook config format: {"hooks":{"PostToolCall":[{"command":"bash $PLUGIN_DIR/hooks/sprint-activity-hook.sh $SPRINT_DIR"}]}}

              - Pass --hook-config flag to claude -p invocations in sprint-loop.sh

              - Clean up hook config file on sprint completion/stop

              - Ensure PLUGIN_DIR environment variable is available to hook

              - Add verbosity level detection from status page preferences (or default to "basic")

              - Document hook configuration in USER-GUIDE.md


              Files to modify:

              - .claude/commands/m42-sprint/run-sprint

              - scripts/sprint-loop.sh (add --hook-config flag to claude invocations)


              Reference:

              - Existing sprint-loop.sh for claude -p invocation pattern

              - Claude Code --hook-config documentation



              ## MUST READ BEFORE IMPLEMENTING

              Read these files in order:

              1. context/_shared-context.md (project patterns, conventions)

              2. context/sprint-plan.md (how this fits in sprint)

              3. artifacts/step-7-gherkin.md (scenarios to satisfy)

              4. context/step-7-context.md (specific patterns, imports)


              ## Implementation Rules


              ### Follow the Gherkin

              Your implementation MUST satisfy ALL gherkin scenarios.

              Each scenario has a verification command - mentally run it to check your work.


              ### Follow the Context

              - Use patterns from similar implementations

              - Import from specified modules

              - Implement required interfaces

              - Follow naming conventions


              ### Code Quality

              - Keep code simple and focused

              - Follow existing patterns exactly

              - No over-engineering or extra abstractions

              - Only implement what's needed for the scenarios


              ### Commits

              Make atomic commits for logical units:

              ```bash

              # After each logical piece

              git add [files]

              git commit -m "[type](step-7): [description]"

              ```


              Types: feat, fix, refactor, test, docs


              ## Implementation Checklist

              Before marking complete, verify:

              - [ ] All files from gherkin scenarios exist

              - [ ] Code follows patterns from context

              - [ ] Imports are correct

              - [ ] No TypeScript errors (run typecheck mentally)

              - [ ] Each scenario's verification should pass


              ## If Blocked

              If you encounter an issue that prevents completion:

              - Document the blocker clearly

              - Set status to needs-human

              - Do NOT leave partial/broken implementation

          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-7-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-7-qa-report.md

              ```markdown
              # QA Report: step-7

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-7-qa-report.md
                 git commit -m "qa(step-7): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-7.\n\n## Context\nRead: artifacts/step-7-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-7-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-7-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-7 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: >
              Final integration verification for the step.


              ## Your Task

              Track C - Step 4: Integrate Hook Auto-Configuration in run-sprint


              Automatically configure and inject sprint activity hook during sprint execution.


              Requirements:

              - Modify .claude/commands/m42-sprint/run-sprint command

              - Generate .sprint-hooks.json in sprint directory before execution

              - Hook config format: {"hooks":{"PostToolCall":[{"command":"bash $PLUGIN_DIR/hooks/sprint-activity-hook.sh $SPRINT_DIR"}]}}

              - Pass --hook-config flag to claude -p invocations in sprint-loop.sh

              - Clean up hook config file on sprint completion/stop

              - Ensure PLUGIN_DIR environment variable is available to hook

              - Add verbosity level detection from status page preferences (or default to "basic")

              - Document hook configuration in USER-GUIDE.md


              Files to modify:

              - .claude/commands/m42-sprint/run-sprint

              - scripts/sprint-loop.sh (add --hook-config flag to claude invocations)


              Reference:

              - Existing sprint-loop.sh for claude -p invocation pattern

              - Claude Code --hook-config documentation



              ## Context

              Read: context/_shared-context.md (build commands)

              Read: artifacts/step-7-qa-report.md (should show PASS)


              ## Step 1: Build Verification

              Run the project build to ensure this step integrates:

              ```bash

              # Use commands from _shared-context.md, typically:

              npm run build

              npm run typecheck

              ```


              ## Step 2: Integration Check

              Verify this step works with the rest of the sprint:

              - Check imports resolve correctly

              - Verify no circular dependencies

              - Ensure types are compatible


              ## Step 3: Smoke Test

              If possible, manually verify the functionality:

              - Run the code path that uses this step's output

              - Check expected behavior matches gherkin scenarios


              ## Step 4: Final Commit

              If all verification passes:

              ```bash

              git add -A

              git status  # Check for any uncommitted changes

              # Only commit if there are changes

              git diff --cached --quiet || git commit -m "verify(step-7): integration verified"

              ```


              ## Outcome

              - If integration passes: Mark step as complete

              - If integration fails: Document the issue and set status to needs-human


              ## Important

              This is the final gate before moving to the next step.

              The step's gherkin scenarios already passed in QA.

              This phase ensures the step works in the broader context.

      - id: step-8
        prompt: |
          Track D - Step 1: Add Skip/Retry Phase Buttons

          Implement Skip and Retry buttons for individual phases in the status page.

          Requirements:
          - Add POST /api/skip/:phaseId endpoint to skip blocked/stuck phases
          - Add POST /api/retry/:phaseId endpoint to retry failed phases without full restart
          - Skip endpoint should:
            - Mark current phase as "skipped" in PROGRESS.yaml
            - Advance to next phase
            - Show confirmation dialog with data loss warning
          - Retry endpoint should:
            - Reset phase status to "pending" in PROGRESS.yaml
            - Re-queue phase for execution
            - Preserve any partial work if possible
          - Add contextual buttons in phase cards (Skip visible for stuck/blocked, Retry for failed)
          - Include confirmation modal for Skip with warning about incomplete work
          - Update SSE to reflect phase status changes immediately

          Files to modify:
          - compiler/src/status-server/server.ts (add API endpoints)
          - compiler/src/status-server/page.ts (add contextual buttons per phase)
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Track D - Step 1: Add Skip/Retry Phase Buttons

              Implement Skip and Retry buttons for individual phases in the status page.

              Requirements:
              - Add POST /api/skip/:phaseId endpoint to skip blocked/stuck phases
              - Add POST /api/retry/:phaseId endpoint to retry failed phases without full restart
              - Skip endpoint should:
                - Mark current phase as "skipped" in PROGRESS.yaml
                - Advance to next phase
                - Show confirmation dialog with data loss warning
              - Retry endpoint should:
                - Reset phase status to "pending" in PROGRESS.yaml
                - Re-queue phase for execution
                - Preserve any partial work if possible
              - Add contextual buttons in phase cards (Skip visible for stuck/blocked, Retry for failed)
              - Include confirmation modal for Skip with warning about incomplete work
              - Update SSE to reflect phase status changes immediately

              Files to modify:
              - compiler/src/status-server/server.ts (add API endpoints)
              - compiler/src/status-server/page.ts (add contextual buttons per phase)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-8-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-8

              ## Step Task
              Track D - Step 1: Add Skip/Retry Phase Buttons

              Implement Skip and Retry buttons for individual phases in the status page.

              Requirements:
              - Add POST /api/skip/:phaseId endpoint to skip blocked/stuck phases
              - Add POST /api/retry/:phaseId endpoint to retry failed phases without full restart
              - Skip endpoint should:
                - Mark current phase as "skipped" in PROGRESS.yaml
                - Advance to next phase
                - Show confirmation dialog with data loss warning
              - Retry endpoint should:
                - Reset phase status to "pending" in PROGRESS.yaml
                - Re-queue phase for execution
                - Preserve any partial work if possible
              - Add contextual buttons in phase cards (Skip visible for stuck/blocked, Retry for failed)
              - Include confirmation modal for Skip with warning about incomplete work
              - Update SSE to reflect phase status changes immediately

              Files to modify:
              - compiler/src/status-server/server.ts (add API endpoints)
              - compiler/src/status-server/page.ts (add contextual buttons per phase)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-8-gherkin.md
              git commit -m "plan(step-8): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Track D - Step 1: Add Skip/Retry Phase Buttons

              Implement Skip and Retry buttons for individual phases in the status page.

              Requirements:
              - Add POST /api/skip/:phaseId endpoint to skip blocked/stuck phases
              - Add POST /api/retry/:phaseId endpoint to retry failed phases without full restart
              - Skip endpoint should:
                - Mark current phase as "skipped" in PROGRESS.yaml
                - Advance to next phase
                - Show confirmation dialog with data loss warning
              - Retry endpoint should:
                - Reset phase status to "pending" in PROGRESS.yaml
                - Re-queue phase for execution
                - Preserve any partial work if possible
              - Add contextual buttons in phase cards (Skip visible for stuck/blocked, Retry for failed)
              - Include confirmation modal for Skip with warning about incomplete work
              - Update SSE to reflect phase status changes immediately

              Files to modify:
              - compiler/src/status-server/server.ts (add API endpoints)
              - compiler/src/status-server/page.ts (add contextual buttons per phase)


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-8-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-8-context.md

              ```markdown
              # Step Context: step-8

              ## Task
              Track D - Step 1: Add Skip/Retry Phase Buttons

              Implement Skip and Retry buttons for individual phases in the status page.

              Requirements:
              - Add POST /api/skip/:phaseId endpoint to skip blocked/stuck phases
              - Add POST /api/retry/:phaseId endpoint to retry failed phases without full restart
              - Skip endpoint should:
                - Mark current phase as "skipped" in PROGRESS.yaml
                - Advance to next phase
                - Show confirmation dialog with data loss warning
              - Retry endpoint should:
                - Reset phase status to "pending" in PROGRESS.yaml
                - Re-queue phase for execution
                - Preserve any partial work if possible
              - Add contextual buttons in phase cards (Skip visible for stuck/blocked, Retry for failed)
              - Include confirmation modal for Skip with warning about incomplete work
              - Update SSE to reflect phase status changes immediately

              Files to modify:
              - compiler/src/status-server/server.ts (add API endpoints)
              - compiler/src/status-server/page.ts (add contextual buttons per phase)


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-8-context.md
              git commit -m "context(step-8): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Track D - Step 1: Add Skip/Retry Phase Buttons

              Implement Skip and Retry buttons for individual phases in the status page.

              Requirements:
              - Add POST /api/skip/:phaseId endpoint to skip blocked/stuck phases
              - Add POST /api/retry/:phaseId endpoint to retry failed phases without full restart
              - Skip endpoint should:
                - Mark current phase as "skipped" in PROGRESS.yaml
                - Advance to next phase
                - Show confirmation dialog with data loss warning
              - Retry endpoint should:
                - Reset phase status to "pending" in PROGRESS.yaml
                - Re-queue phase for execution
                - Preserve any partial work if possible
              - Add contextual buttons in phase cards (Skip visible for stuck/blocked, Retry for failed)
              - Include confirmation modal for Skip with warning about incomplete work
              - Update SSE to reflect phase status changes immediately

              Files to modify:
              - compiler/src/status-server/server.ts (add API endpoints)
              - compiler/src/status-server/page.ts (add contextual buttons per phase)


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-8-gherkin.md (scenarios to satisfy)
              4. context/step-8-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-8): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-8-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-8-qa-report.md

              ```markdown
              # QA Report: step-8

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-8-qa-report.md
                 git commit -m "qa(step-8): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-8.\n\n## Context\nRead: artifacts/step-8-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-8-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-8-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-8 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Track D - Step 1: Add Skip/Retry Phase Buttons

              Implement Skip and Retry buttons for individual phases in the status page.

              Requirements:
              - Add POST /api/skip/:phaseId endpoint to skip blocked/stuck phases
              - Add POST /api/retry/:phaseId endpoint to retry failed phases without full restart
              - Skip endpoint should:
                - Mark current phase as "skipped" in PROGRESS.yaml
                - Advance to next phase
                - Show confirmation dialog with data loss warning
              - Retry endpoint should:
                - Reset phase status to "pending" in PROGRESS.yaml
                - Re-queue phase for execution
                - Preserve any partial work if possible
              - Add contextual buttons in phase cards (Skip visible for stuck/blocked, Retry for failed)
              - Include confirmation modal for Skip with warning about incomplete work
              - Update SSE to reflect phase status changes immediately

              Files to modify:
              - compiler/src/status-server/server.ts (add API endpoints)
              - compiler/src/status-server/page.ts (add contextual buttons per phase)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-8-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-8): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-9
        prompt: |
          Track D - Step 2: Implement Phase Log Viewer

          Add expandable log viewer for each phase showing Claude's actual output.

          Requirements:
          - Capture stdout/stderr from each `claude -p` invocation in sprint-loop.sh
          - Store phase logs in <sprint-dir>/logs/<phase-id>.log
          - Create logs/ directory in sprint directory structure
          - Modify sprint-loop.sh to tee output to log files while displaying
          - Add expandable "View Log" section in each phase card
          - Implement syntax highlighting for code blocks in output
          - Add search/filter functionality within logs
          - Add "Download Log" button for individual phase logs
          - Add "Download All Logs" button (zip archive) in sprint header
          - Handle large log files efficiently (lazy loading, virtualized scrolling)
          - Preserve ANSI color codes and convert to HTML for display

          Files to modify:
          - scripts/sprint-loop.sh (add logging to files)
          - compiler/src/status-server/server.ts (add log serving endpoints)
          - compiler/src/status-server/page.ts (add log viewer UI)

          New endpoints:
          - GET /api/logs/:phaseId - Get log content for a phase
          - GET /api/logs/download/:phaseId - Download individual log
          - GET /api/logs/download-all - Download all logs as zip
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Track D - Step 2: Implement Phase Log Viewer

              Add expandable log viewer for each phase showing Claude's actual output.

              Requirements:
              - Capture stdout/stderr from each `claude -p` invocation in sprint-loop.sh
              - Store phase logs in <sprint-dir>/logs/<phase-id>.log
              - Create logs/ directory in sprint directory structure
              - Modify sprint-loop.sh to tee output to log files while displaying
              - Add expandable "View Log" section in each phase card
              - Implement syntax highlighting for code blocks in output
              - Add search/filter functionality within logs
              - Add "Download Log" button for individual phase logs
              - Add "Download All Logs" button (zip archive) in sprint header
              - Handle large log files efficiently (lazy loading, virtualized scrolling)
              - Preserve ANSI color codes and convert to HTML for display

              Files to modify:
              - scripts/sprint-loop.sh (add logging to files)
              - compiler/src/status-server/server.ts (add log serving endpoints)
              - compiler/src/status-server/page.ts (add log viewer UI)

              New endpoints:
              - GET /api/logs/:phaseId - Get log content for a phase
              - GET /api/logs/download/:phaseId - Download individual log
              - GET /api/logs/download-all - Download all logs as zip


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-9-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-9

              ## Step Task
              Track D - Step 2: Implement Phase Log Viewer

              Add expandable log viewer for each phase showing Claude's actual output.

              Requirements:
              - Capture stdout/stderr from each `claude -p` invocation in sprint-loop.sh
              - Store phase logs in <sprint-dir>/logs/<phase-id>.log
              - Create logs/ directory in sprint directory structure
              - Modify sprint-loop.sh to tee output to log files while displaying
              - Add expandable "View Log" section in each phase card
              - Implement syntax highlighting for code blocks in output
              - Add search/filter functionality within logs
              - Add "Download Log" button for individual phase logs
              - Add "Download All Logs" button (zip archive) in sprint header
              - Handle large log files efficiently (lazy loading, virtualized scrolling)
              - Preserve ANSI color codes and convert to HTML for display

              Files to modify:
              - scripts/sprint-loop.sh (add logging to files)
              - compiler/src/status-server/server.ts (add log serving endpoints)
              - compiler/src/status-server/page.ts (add log viewer UI)

              New endpoints:
              - GET /api/logs/:phaseId - Get log content for a phase
              - GET /api/logs/download/:phaseId - Download individual log
              - GET /api/logs/download-all - Download all logs as zip


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-9-gherkin.md
              git commit -m "plan(step-9): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Track D - Step 2: Implement Phase Log Viewer

              Add expandable log viewer for each phase showing Claude's actual output.

              Requirements:
              - Capture stdout/stderr from each `claude -p` invocation in sprint-loop.sh
              - Store phase logs in <sprint-dir>/logs/<phase-id>.log
              - Create logs/ directory in sprint directory structure
              - Modify sprint-loop.sh to tee output to log files while displaying
              - Add expandable "View Log" section in each phase card
              - Implement syntax highlighting for code blocks in output
              - Add search/filter functionality within logs
              - Add "Download Log" button for individual phase logs
              - Add "Download All Logs" button (zip archive) in sprint header
              - Handle large log files efficiently (lazy loading, virtualized scrolling)
              - Preserve ANSI color codes and convert to HTML for display

              Files to modify:
              - scripts/sprint-loop.sh (add logging to files)
              - compiler/src/status-server/server.ts (add log serving endpoints)
              - compiler/src/status-server/page.ts (add log viewer UI)

              New endpoints:
              - GET /api/logs/:phaseId - Get log content for a phase
              - GET /api/logs/download/:phaseId - Download individual log
              - GET /api/logs/download-all - Download all logs as zip


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-9-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-9-context.md

              ```markdown
              # Step Context: step-9

              ## Task
              Track D - Step 2: Implement Phase Log Viewer

              Add expandable log viewer for each phase showing Claude's actual output.

              Requirements:
              - Capture stdout/stderr from each `claude -p` invocation in sprint-loop.sh
              - Store phase logs in <sprint-dir>/logs/<phase-id>.log
              - Create logs/ directory in sprint directory structure
              - Modify sprint-loop.sh to tee output to log files while displaying
              - Add expandable "View Log" section in each phase card
              - Implement syntax highlighting for code blocks in output
              - Add search/filter functionality within logs
              - Add "Download Log" button for individual phase logs
              - Add "Download All Logs" button (zip archive) in sprint header
              - Handle large log files efficiently (lazy loading, virtualized scrolling)
              - Preserve ANSI color codes and convert to HTML for display

              Files to modify:
              - scripts/sprint-loop.sh (add logging to files)
              - compiler/src/status-server/server.ts (add log serving endpoints)
              - compiler/src/status-server/page.ts (add log viewer UI)

              New endpoints:
              - GET /api/logs/:phaseId - Get log content for a phase
              - GET /api/logs/download/:phaseId - Download individual log
              - GET /api/logs/download-all - Download all logs as zip


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-9-context.md
              git commit -m "context(step-9): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Track D - Step 2: Implement Phase Log Viewer

              Add expandable log viewer for each phase showing Claude's actual output.

              Requirements:
              - Capture stdout/stderr from each `claude -p` invocation in sprint-loop.sh
              - Store phase logs in <sprint-dir>/logs/<phase-id>.log
              - Create logs/ directory in sprint directory structure
              - Modify sprint-loop.sh to tee output to log files while displaying
              - Add expandable "View Log" section in each phase card
              - Implement syntax highlighting for code blocks in output
              - Add search/filter functionality within logs
              - Add "Download Log" button for individual phase logs
              - Add "Download All Logs" button (zip archive) in sprint header
              - Handle large log files efficiently (lazy loading, virtualized scrolling)
              - Preserve ANSI color codes and convert to HTML for display

              Files to modify:
              - scripts/sprint-loop.sh (add logging to files)
              - compiler/src/status-server/server.ts (add log serving endpoints)
              - compiler/src/status-server/page.ts (add log viewer UI)

              New endpoints:
              - GET /api/logs/:phaseId - Get log content for a phase
              - GET /api/logs/download/:phaseId - Download individual log
              - GET /api/logs/download-all - Download all logs as zip


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-9-gherkin.md (scenarios to satisfy)
              4. context/step-9-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-9): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-9-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-9-qa-report.md

              ```markdown
              # QA Report: step-9

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-9-qa-report.md
                 git commit -m "qa(step-9): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-9.\n\n## Context\nRead: artifacts/step-9-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-9-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-9-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-9 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Track D - Step 2: Implement Phase Log Viewer

              Add expandable log viewer for each phase showing Claude's actual output.

              Requirements:
              - Capture stdout/stderr from each `claude -p` invocation in sprint-loop.sh
              - Store phase logs in <sprint-dir>/logs/<phase-id>.log
              - Create logs/ directory in sprint directory structure
              - Modify sprint-loop.sh to tee output to log files while displaying
              - Add expandable "View Log" section in each phase card
              - Implement syntax highlighting for code blocks in output
              - Add search/filter functionality within logs
              - Add "Download Log" button for individual phase logs
              - Add "Download All Logs" button (zip archive) in sprint header
              - Handle large log files efficiently (lazy loading, virtualized scrolling)
              - Preserve ANSI color codes and convert to HTML for display

              Files to modify:
              - scripts/sprint-loop.sh (add logging to files)
              - compiler/src/status-server/server.ts (add log serving endpoints)
              - compiler/src/status-server/page.ts (add log viewer UI)

              New endpoints:
              - GET /api/logs/:phaseId - Get log content for a phase
              - GET /api/logs/download/:phaseId - Download individual log
              - GET /api/logs/download-all - Download all logs as zip


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-9-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-9): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-10
        prompt: |
          Track D - Step 3: Add Desktop Notifications

          Implement browser desktop notifications for sprint events.

          Requirements:
          - Use Browser Notification API for desktop alerts
          - Notify on the following events:
            - Sprint completed (success)
            - Sprint failed
            - Phase blocked/stuck
            - Human intervention needed
          - Add notification permission request flow on first visit
          - Add optional sound alerts (configurable)
          - Create notification settings panel in status page:
            - Enable/disable notifications toggle
            - Per-event notification toggles
            - Sound on/off toggle
            - Sound selection dropdown
          - Persist notification preferences in localStorage
          - Include sprint/phase info in notification body
          - Add click handler to focus status page tab

          Files to modify:
          - compiler/src/status-server/page.ts (notification logic and settings UI)

          Assets to add:
          - compiler/src/status-server/assets/notification-sounds/ (optional sound files)
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Track D - Step 3: Add Desktop Notifications

              Implement browser desktop notifications for sprint events.

              Requirements:
              - Use Browser Notification API for desktop alerts
              - Notify on the following events:
                - Sprint completed (success)
                - Sprint failed
                - Phase blocked/stuck
                - Human intervention needed
              - Add notification permission request flow on first visit
              - Add optional sound alerts (configurable)
              - Create notification settings panel in status page:
                - Enable/disable notifications toggle
                - Per-event notification toggles
                - Sound on/off toggle
                - Sound selection dropdown
              - Persist notification preferences in localStorage
              - Include sprint/phase info in notification body
              - Add click handler to focus status page tab

              Files to modify:
              - compiler/src/status-server/page.ts (notification logic and settings UI)

              Assets to add:
              - compiler/src/status-server/assets/notification-sounds/ (optional sound files)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-10-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-10

              ## Step Task
              Track D - Step 3: Add Desktop Notifications

              Implement browser desktop notifications for sprint events.

              Requirements:
              - Use Browser Notification API for desktop alerts
              - Notify on the following events:
                - Sprint completed (success)
                - Sprint failed
                - Phase blocked/stuck
                - Human intervention needed
              - Add notification permission request flow on first visit
              - Add optional sound alerts (configurable)
              - Create notification settings panel in status page:
                - Enable/disable notifications toggle
                - Per-event notification toggles
                - Sound on/off toggle
                - Sound selection dropdown
              - Persist notification preferences in localStorage
              - Include sprint/phase info in notification body
              - Add click handler to focus status page tab

              Files to modify:
              - compiler/src/status-server/page.ts (notification logic and settings UI)

              Assets to add:
              - compiler/src/status-server/assets/notification-sounds/ (optional sound files)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-10-gherkin.md
              git commit -m "plan(step-10): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Track D - Step 3: Add Desktop Notifications

              Implement browser desktop notifications for sprint events.

              Requirements:
              - Use Browser Notification API for desktop alerts
              - Notify on the following events:
                - Sprint completed (success)
                - Sprint failed
                - Phase blocked/stuck
                - Human intervention needed
              - Add notification permission request flow on first visit
              - Add optional sound alerts (configurable)
              - Create notification settings panel in status page:
                - Enable/disable notifications toggle
                - Per-event notification toggles
                - Sound on/off toggle
                - Sound selection dropdown
              - Persist notification preferences in localStorage
              - Include sprint/phase info in notification body
              - Add click handler to focus status page tab

              Files to modify:
              - compiler/src/status-server/page.ts (notification logic and settings UI)

              Assets to add:
              - compiler/src/status-server/assets/notification-sounds/ (optional sound files)


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-10-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-10-context.md

              ```markdown
              # Step Context: step-10

              ## Task
              Track D - Step 3: Add Desktop Notifications

              Implement browser desktop notifications for sprint events.

              Requirements:
              - Use Browser Notification API for desktop alerts
              - Notify on the following events:
                - Sprint completed (success)
                - Sprint failed
                - Phase blocked/stuck
                - Human intervention needed
              - Add notification permission request flow on first visit
              - Add optional sound alerts (configurable)
              - Create notification settings panel in status page:
                - Enable/disable notifications toggle
                - Per-event notification toggles
                - Sound on/off toggle
                - Sound selection dropdown
              - Persist notification preferences in localStorage
              - Include sprint/phase info in notification body
              - Add click handler to focus status page tab

              Files to modify:
              - compiler/src/status-server/page.ts (notification logic and settings UI)

              Assets to add:
              - compiler/src/status-server/assets/notification-sounds/ (optional sound files)


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-10-context.md
              git commit -m "context(step-10): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Track D - Step 3: Add Desktop Notifications

              Implement browser desktop notifications for sprint events.

              Requirements:
              - Use Browser Notification API for desktop alerts
              - Notify on the following events:
                - Sprint completed (success)
                - Sprint failed
                - Phase blocked/stuck
                - Human intervention needed
              - Add notification permission request flow on first visit
              - Add optional sound alerts (configurable)
              - Create notification settings panel in status page:
                - Enable/disable notifications toggle
                - Per-event notification toggles
                - Sound on/off toggle
                - Sound selection dropdown
              - Persist notification preferences in localStorage
              - Include sprint/phase info in notification body
              - Add click handler to focus status page tab

              Files to modify:
              - compiler/src/status-server/page.ts (notification logic and settings UI)

              Assets to add:
              - compiler/src/status-server/assets/notification-sounds/ (optional sound files)


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-10-gherkin.md (scenarios to satisfy)
              4. context/step-10-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-10): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-10-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-10-qa-report.md

              ```markdown
              # QA Report: step-10

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-10-qa-report.md
                 git commit -m "qa(step-10): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-10.\n\n## Context\nRead: artifacts/step-10-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-10-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-10-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-10 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Track D - Step 3: Add Desktop Notifications

              Implement browser desktop notifications for sprint events.

              Requirements:
              - Use Browser Notification API for desktop alerts
              - Notify on the following events:
                - Sprint completed (success)
                - Sprint failed
                - Phase blocked/stuck
                - Human intervention needed
              - Add notification permission request flow on first visit
              - Add optional sound alerts (configurable)
              - Create notification settings panel in status page:
                - Enable/disable notifications toggle
                - Per-event notification toggles
                - Sound on/off toggle
                - Sound selection dropdown
              - Persist notification preferences in localStorage
              - Include sprint/phase info in notification body
              - Add click handler to focus status page tab

              Files to modify:
              - compiler/src/status-server/page.ts (notification logic and settings UI)

              Assets to add:
              - compiler/src/status-server/assets/notification-sounds/ (optional sound files)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-10-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-10): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-11
        prompt: >
          Track D - Step 4: Implement Progress Estimation


          Add time estimation and progress tracking for sprints and phases.


          Requirements:

          - Track historical phase durations in <sprint-dir>/timing.jsonl

          - Record format: {"phaseId":"string","workflow":"string","startTime":"ISO","endTime":"ISO","durationMs":number}

          - Create timing database aggregating data from all past sprints

          - Store in .claude/sprints/.timing-history.jsonl

          - Calculate rolling averages per workflow/phase type

          - Display in status page:



















            - "Estimated time remaining" in sprint header
            - Per-phase ETA based on similar past phases
            - Visual timeline showing projected completion
            - Actual vs estimated comparison for completed phases
          - Handle first-run case (no historical data) gracefully

          - Update estimates in real-time as phases complete

          - Show confidence level based on sample size


          Files to modify:

          - scripts/sprint-loop.sh (record phase timing)

          - compiler/src/status-server/server.ts (timing aggregation endpoints)

          - compiler/src/status-server/page.ts (estimation UI)


          New files:

          - compiler/src/status-server/timing-tracker.ts (timing logic)

        status: pending
        phases:
          - id: plan
            status: pending
            prompt: >
              Generate binary-verifiable gherkin scenarios for this step.


              ## Your Task

              Track D - Step 4: Implement Progress Estimation


              Add time estimation and progress tracking for sprints and phases.


              Requirements:

              - Track historical phase durations in <sprint-dir>/timing.jsonl

              - Record format: {"phaseId":"string","workflow":"string","startTime":"ISO","endTime":"ISO","durationMs":number}

              - Create timing database aggregating data from all past sprints

              - Store in .claude/sprints/.timing-history.jsonl

              - Calculate rolling averages per workflow/phase type

              - Display in status page:



















                - "Estimated time remaining" in sprint header
                - Per-phase ETA based on similar past phases
                - Visual timeline showing projected completion
                - Actual vs estimated comparison for completed phases
              - Handle first-run case (no historical data) gracefully

              - Update estimates in real-time as phases complete

              - Show confidence level based on sample size


              Files to modify:

              - scripts/sprint-loop.sh (record phase timing)

              - compiler/src/status-server/server.ts (timing aggregation endpoints)

              - compiler/src/status-server/page.ts (estimation UI)


              New files:

              - compiler/src/status-server/timing-tracker.ts (timing logic)



              ## Shared Context

              Read: context/_shared-context.md (project patterns, conventions, commands)

              Read: context/sprint-plan.md (how this step fits in the sprint)


              ## Instructions

              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.

              Each scenario MUST have:

              1. Clear Given/When/Then structure

              2. An explicit verification command that returns exit code 0 on success

              3. Binary outcome: exactly 1 (pass) or 0 (fail)


              ## Gherkin Format

              Each scenario follows this exact structure:


              ```gherkin

              Scenario: [Descriptive name]



















                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ## Example Scenarios


              ### File Existence

              ```gherkin

              Scenario: Source file exists



















                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ### TypeScript Compilation

              ```gherkin

              Scenario: TypeScript compiles without errors



















                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ### Function Export

              ```gherkin

              Scenario: Login function is exported



















                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ### Test Execution

              ```gherkin

              Scenario: Unit tests pass



















                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ### Lint Check

              ```gherkin

              Scenario: Code passes linting



















                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ## Output

              Create: artifacts/step-11-gherkin.md


              ```markdown

              # Gherkin Scenarios: step-11


              ## Step Task

              Track D - Step 4: Implement Progress Estimation


              Add time estimation and progress tracking for sprints and phases.


              Requirements:

              - Track historical phase durations in <sprint-dir>/timing.jsonl

              - Record format: {"phaseId":"string","workflow":"string","startTime":"ISO","endTime":"ISO","durationMs":number}

              - Create timing database aggregating data from all past sprints

              - Store in .claude/sprints/.timing-history.jsonl

              - Calculate rolling averages per workflow/phase type

              - Display in status page:



















                - "Estimated time remaining" in sprint header
                - Per-phase ETA based on similar past phases
                - Visual timeline showing projected completion
                - Actual vs estimated comparison for completed phases
              - Handle first-run case (no historical data) gracefully

              - Update estimates in real-time as phases complete

              - Show confidence level based on sample size


              Files to modify:

              - scripts/sprint-loop.sh (record phase timing)

              - compiler/src/status-server/server.ts (timing aggregation endpoints)

              - compiler/src/status-server/page.ts (estimation UI)


              New files:

              - compiler/src/status-server/timing-tracker.ts (timing logic)



              ## Success Criteria

              All scenarios must pass (score = 1) for the step to be complete.

              Total scenarios: [N]

              Required score: [N]/[N]


              ---


              ## Scenario 1: [Name]

              [Full gherkin with verification as shown above]


              ---


              ## Scenario 2: [Name]

              ...


              [Continue for 4-8 scenarios]

              ```


              ## Commit

              ```bash

              git add artifacts/step-11-gherkin.md

              git commit -m "plan(step-11): define gherkin scenarios"

              ```

          - id: context
            status: pending
            prompt: >
              Gather step-specific context for implementation.


              ## Your Task

              Track D - Step 4: Implement Progress Estimation


              Add time estimation and progress tracking for sprints and phases.


              Requirements:

              - Track historical phase durations in <sprint-dir>/timing.jsonl

              - Record format: {"phaseId":"string","workflow":"string","startTime":"ISO","endTime":"ISO","durationMs":number}

              - Create timing database aggregating data from all past sprints

              - Store in .claude/sprints/.timing-history.jsonl

              - Calculate rolling averages per workflow/phase type

              - Display in status page:



















                - "Estimated time remaining" in sprint header
                - Per-phase ETA based on similar past phases
                - Visual timeline showing projected completion
                - Actual vs estimated comparison for completed phases
              - Handle first-run case (no historical data) gracefully

              - Update estimates in real-time as phases complete

              - Show confidence level based on sample size


              Files to modify:

              - scripts/sprint-loop.sh (record phase timing)

              - compiler/src/status-server/server.ts (timing aggregation endpoints)

              - compiler/src/status-server/page.ts (estimation UI)


              New files:

              - compiler/src/status-server/timing-tracker.ts (timing logic)



              ## Shared Context

              Read: context/_shared-context.md (already has project-wide patterns)

              Read: artifacts/step-11-gherkin.md (scenarios to implement)


              ## Instructions

              Research the specific code areas this step will touch:


              1. **Related Existing Code**



















                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**



















                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**



















                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**



















                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output

              Create: context/step-11-context.md


              ```markdown

              # Step Context: step-11


              ## Task

              Track D - Step 4: Implement Progress Estimation


              Add time estimation and progress tracking for sprints and phases.


              Requirements:

              - Track historical phase durations in <sprint-dir>/timing.jsonl

              - Record format: {"phaseId":"string","workflow":"string","startTime":"ISO","endTime":"ISO","durationMs":number}

              - Create timing database aggregating data from all past sprints

              - Store in .claude/sprints/.timing-history.jsonl

              - Calculate rolling averages per workflow/phase type

              - Display in status page:



















                - "Estimated time remaining" in sprint header
                - Per-phase ETA based on similar past phases
                - Visual timeline showing projected completion
                - Actual vs estimated comparison for completed phases
              - Handle first-run case (no historical data) gracefully

              - Update estimates in real-time as phases complete

              - Show confidence level based on sample size


              Files to modify:

              - scripts/sprint-loop.sh (record phase timing)

              - compiler/src/status-server/server.ts (timing aggregation endpoints)

              - compiler/src/status-server/page.ts (estimation UI)


              New files:

              - compiler/src/status-server/timing-tracker.ts (timing logic)



              ## Related Code Patterns


              ### Similar Implementation: [path]

              ```typescript

              // Key pattern to follow

              [relevant code snippet]

              ```


              ### Similar Implementation: [path]

              [continue as needed]


              ## Required Imports

              ### Internal

              - `[module]`: [what to import]


              ### External

              - `[package]`: [what to import]


              ## Types/Interfaces to Use

              ```typescript

              // From [source]

              interface [Name] {



















                [relevant fields]
              }

              ```


              ## Integration Points

              - Called by: [who will use this]

              - Calls: [what this will call]

              - Tests: [related test files]


              ## Implementation Notes

              - [Specific note 1]

              - [Specific note 2]

              ```


              ## Commit

              ```bash

              git add context/step-11-context.md

              git commit -m "context(step-11): gather implementation context"

              ```

          - id: execute
            status: pending
            prompt: >
              Implement the step following gherkin scenarios and context.


              ## Your Task

              Track D - Step 4: Implement Progress Estimation


              Add time estimation and progress tracking for sprints and phases.


              Requirements:

              - Track historical phase durations in <sprint-dir>/timing.jsonl

              - Record format: {"phaseId":"string","workflow":"string","startTime":"ISO","endTime":"ISO","durationMs":number}

              - Create timing database aggregating data from all past sprints

              - Store in .claude/sprints/.timing-history.jsonl

              - Calculate rolling averages per workflow/phase type

              - Display in status page:



















                - "Estimated time remaining" in sprint header
                - Per-phase ETA based on similar past phases
                - Visual timeline showing projected completion
                - Actual vs estimated comparison for completed phases
              - Handle first-run case (no historical data) gracefully

              - Update estimates in real-time as phases complete

              - Show confidence level based on sample size


              Files to modify:

              - scripts/sprint-loop.sh (record phase timing)

              - compiler/src/status-server/server.ts (timing aggregation endpoints)

              - compiler/src/status-server/page.ts (estimation UI)


              New files:

              - compiler/src/status-server/timing-tracker.ts (timing logic)



              ## MUST READ BEFORE IMPLEMENTING

              Read these files in order:

              1. context/_shared-context.md (project patterns, conventions)

              2. context/sprint-plan.md (how this fits in sprint)

              3. artifacts/step-11-gherkin.md (scenarios to satisfy)

              4. context/step-11-context.md (specific patterns, imports)


              ## Implementation Rules


              ### Follow the Gherkin

              Your implementation MUST satisfy ALL gherkin scenarios.

              Each scenario has a verification command - mentally run it to check your work.


              ### Follow the Context

              - Use patterns from similar implementations

              - Import from specified modules

              - Implement required interfaces

              - Follow naming conventions


              ### Code Quality

              - Keep code simple and focused

              - Follow existing patterns exactly

              - No over-engineering or extra abstractions

              - Only implement what's needed for the scenarios


              ### Commits

              Make atomic commits for logical units:

              ```bash

              # After each logical piece

              git add [files]

              git commit -m "[type](step-11): [description]"

              ```


              Types: feat, fix, refactor, test, docs


              ## Implementation Checklist

              Before marking complete, verify:

              - [ ] All files from gherkin scenarios exist

              - [ ] Code follows patterns from context

              - [ ] Imports are correct

              - [ ] No TypeScript errors (run typecheck mentally)

              - [ ] Each scenario's verification should pass


              ## If Blocked

              If you encounter an issue that prevents completion:

              - Document the blocker clearly

              - Set status to needs-human

              - Do NOT leave partial/broken implementation

          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-11-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-11-qa-report.md

              ```markdown
              # QA Report: step-11

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-11-qa-report.md
                 git commit -m "qa(step-11): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-11.\n\n## Context\nRead: artifacts/step-11-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-11-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-11-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-11 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: >
              Final integration verification for the step.


              ## Your Task

              Track D - Step 4: Implement Progress Estimation


              Add time estimation and progress tracking for sprints and phases.


              Requirements:

              - Track historical phase durations in <sprint-dir>/timing.jsonl

              - Record format: {"phaseId":"string","workflow":"string","startTime":"ISO","endTime":"ISO","durationMs":number}

              - Create timing database aggregating data from all past sprints

              - Store in .claude/sprints/.timing-history.jsonl

              - Calculate rolling averages per workflow/phase type

              - Display in status page:



















                - "Estimated time remaining" in sprint header
                - Per-phase ETA based on similar past phases
                - Visual timeline showing projected completion
                - Actual vs estimated comparison for completed phases
              - Handle first-run case (no historical data) gracefully

              - Update estimates in real-time as phases complete

              - Show confidence level based on sample size


              Files to modify:

              - scripts/sprint-loop.sh (record phase timing)

              - compiler/src/status-server/server.ts (timing aggregation endpoints)

              - compiler/src/status-server/page.ts (estimation UI)


              New files:

              - compiler/src/status-server/timing-tracker.ts (timing logic)



              ## Context

              Read: context/_shared-context.md (build commands)

              Read: artifacts/step-11-qa-report.md (should show PASS)


              ## Step 1: Build Verification

              Run the project build to ensure this step integrates:

              ```bash

              # Use commands from _shared-context.md, typically:

              npm run build

              npm run typecheck

              ```


              ## Step 2: Integration Check

              Verify this step works with the rest of the sprint:

              - Check imports resolve correctly

              - Verify no circular dependencies

              - Ensure types are compatible


              ## Step 3: Smoke Test

              If possible, manually verify the functionality:

              - Run the code path that uses this step's output

              - Check expected behavior matches gherkin scenarios


              ## Step 4: Final Commit

              If all verification passes:

              ```bash

              git add -A

              git status  # Check for any uncommitted changes

              # Only commit if there are changes

              git diff --cached --quiet || git commit -m "verify(step-11): integration verified"

              ```


              ## Outcome

              - If integration passes: Mark step as complete

              - If integration fails: Document the issue and set status to needs-human


              ## Important

              This is the final gate before moving to the next step.

              The step's gherkin scenarios already passed in QA.

              This phase ensures the step works in the broader context.

      - id: step-12
        prompt: |
          Track D - Step 5: Implement Improved Error Recovery

          Add automatic retry with backoff and smart failure detection.

          Requirements:
          - Implement automatic retry with configurable exponential backoff (1s, 5s, 30s)
          - Add retry configuration to SPRINT.yaml:
            ```yaml
            retry:
              maxAttempts: 3
              backoffMs: [1000, 5000, 30000]
              retryOn: [network, rate-limit, timeout]
            ```
          - Classify errors into categories:
            - network: Connection failures, DNS issues
            - rate-limit: API rate limiting (429 errors)
            - timeout: Execution timeout exceeded
            - validation: Schema/input validation failures
            - logic: Claude reasoning/execution errors
          - Implement recovery strategies per error type:
            - network/rate-limit/timeout: Auto-retry with backoff
            - validation: Log and skip (or block for human review)
            - logic: Capture context and queue for human intervention
          - Preserve partial completion on failure (don't lose work)
          - Add "intervention queue" for unrecoverable errors
          - Display retry status in phase cards (attempt 2/3, next retry in Xs)
          - Add manual "Force Retry" button that bypasses backoff

          Files to modify:
          - scripts/sprint-loop.sh (retry logic)
          - compiler/src/compiler.ts (retry config parsing)
          - compiler/src/status-server/page.ts (retry status UI)

          New files:
          - compiler/src/error-classifier.ts (error classification logic)
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Track D - Step 5: Implement Improved Error Recovery

              Add automatic retry with backoff and smart failure detection.

              Requirements:
              - Implement automatic retry with configurable exponential backoff (1s, 5s, 30s)
              - Add retry configuration to SPRINT.yaml:
                ```yaml
                retry:
                  maxAttempts: 3
                  backoffMs: [1000, 5000, 30000]
                  retryOn: [network, rate-limit, timeout]
                ```
              - Classify errors into categories:
                - network: Connection failures, DNS issues
                - rate-limit: API rate limiting (429 errors)
                - timeout: Execution timeout exceeded
                - validation: Schema/input validation failures
                - logic: Claude reasoning/execution errors
              - Implement recovery strategies per error type:
                - network/rate-limit/timeout: Auto-retry with backoff
                - validation: Log and skip (or block for human review)
                - logic: Capture context and queue for human intervention
              - Preserve partial completion on failure (don't lose work)
              - Add "intervention queue" for unrecoverable errors
              - Display retry status in phase cards (attempt 2/3, next retry in Xs)
              - Add manual "Force Retry" button that bypasses backoff

              Files to modify:
              - scripts/sprint-loop.sh (retry logic)
              - compiler/src/compiler.ts (retry config parsing)
              - compiler/src/status-server/page.ts (retry status UI)

              New files:
              - compiler/src/error-classifier.ts (error classification logic)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-12-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-12

              ## Step Task
              Track D - Step 5: Implement Improved Error Recovery

              Add automatic retry with backoff and smart failure detection.

              Requirements:
              - Implement automatic retry with configurable exponential backoff (1s, 5s, 30s)
              - Add retry configuration to SPRINT.yaml:
                ```yaml
                retry:
                  maxAttempts: 3
                  backoffMs: [1000, 5000, 30000]
                  retryOn: [network, rate-limit, timeout]
                ```
              - Classify errors into categories:
                - network: Connection failures, DNS issues
                - rate-limit: API rate limiting (429 errors)
                - timeout: Execution timeout exceeded
                - validation: Schema/input validation failures
                - logic: Claude reasoning/execution errors
              - Implement recovery strategies per error type:
                - network/rate-limit/timeout: Auto-retry with backoff
                - validation: Log and skip (or block for human review)
                - logic: Capture context and queue for human intervention
              - Preserve partial completion on failure (don't lose work)
              - Add "intervention queue" for unrecoverable errors
              - Display retry status in phase cards (attempt 2/3, next retry in Xs)
              - Add manual "Force Retry" button that bypasses backoff

              Files to modify:
              - scripts/sprint-loop.sh (retry logic)
              - compiler/src/compiler.ts (retry config parsing)
              - compiler/src/status-server/page.ts (retry status UI)

              New files:
              - compiler/src/error-classifier.ts (error classification logic)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-12-gherkin.md
              git commit -m "plan(step-12): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Track D - Step 5: Implement Improved Error Recovery

              Add automatic retry with backoff and smart failure detection.

              Requirements:
              - Implement automatic retry with configurable exponential backoff (1s, 5s, 30s)
              - Add retry configuration to SPRINT.yaml:
                ```yaml
                retry:
                  maxAttempts: 3
                  backoffMs: [1000, 5000, 30000]
                  retryOn: [network, rate-limit, timeout]
                ```
              - Classify errors into categories:
                - network: Connection failures, DNS issues
                - rate-limit: API rate limiting (429 errors)
                - timeout: Execution timeout exceeded
                - validation: Schema/input validation failures
                - logic: Claude reasoning/execution errors
              - Implement recovery strategies per error type:
                - network/rate-limit/timeout: Auto-retry with backoff
                - validation: Log and skip (or block for human review)
                - logic: Capture context and queue for human intervention
              - Preserve partial completion on failure (don't lose work)
              - Add "intervention queue" for unrecoverable errors
              - Display retry status in phase cards (attempt 2/3, next retry in Xs)
              - Add manual "Force Retry" button that bypasses backoff

              Files to modify:
              - scripts/sprint-loop.sh (retry logic)
              - compiler/src/compiler.ts (retry config parsing)
              - compiler/src/status-server/page.ts (retry status UI)

              New files:
              - compiler/src/error-classifier.ts (error classification logic)


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-12-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-12-context.md

              ```markdown
              # Step Context: step-12

              ## Task
              Track D - Step 5: Implement Improved Error Recovery

              Add automatic retry with backoff and smart failure detection.

              Requirements:
              - Implement automatic retry with configurable exponential backoff (1s, 5s, 30s)
              - Add retry configuration to SPRINT.yaml:
                ```yaml
                retry:
                  maxAttempts: 3
                  backoffMs: [1000, 5000, 30000]
                  retryOn: [network, rate-limit, timeout]
                ```
              - Classify errors into categories:
                - network: Connection failures, DNS issues
                - rate-limit: API rate limiting (429 errors)
                - timeout: Execution timeout exceeded
                - validation: Schema/input validation failures
                - logic: Claude reasoning/execution errors
              - Implement recovery strategies per error type:
                - network/rate-limit/timeout: Auto-retry with backoff
                - validation: Log and skip (or block for human review)
                - logic: Capture context and queue for human intervention
              - Preserve partial completion on failure (don't lose work)
              - Add "intervention queue" for unrecoverable errors
              - Display retry status in phase cards (attempt 2/3, next retry in Xs)
              - Add manual "Force Retry" button that bypasses backoff

              Files to modify:
              - scripts/sprint-loop.sh (retry logic)
              - compiler/src/compiler.ts (retry config parsing)
              - compiler/src/status-server/page.ts (retry status UI)

              New files:
              - compiler/src/error-classifier.ts (error classification logic)


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-12-context.md
              git commit -m "context(step-12): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Track D - Step 5: Implement Improved Error Recovery

              Add automatic retry with backoff and smart failure detection.

              Requirements:
              - Implement automatic retry with configurable exponential backoff (1s, 5s, 30s)
              - Add retry configuration to SPRINT.yaml:
                ```yaml
                retry:
                  maxAttempts: 3
                  backoffMs: [1000, 5000, 30000]
                  retryOn: [network, rate-limit, timeout]
                ```
              - Classify errors into categories:
                - network: Connection failures, DNS issues
                - rate-limit: API rate limiting (429 errors)
                - timeout: Execution timeout exceeded
                - validation: Schema/input validation failures
                - logic: Claude reasoning/execution errors
              - Implement recovery strategies per error type:
                - network/rate-limit/timeout: Auto-retry with backoff
                - validation: Log and skip (or block for human review)
                - logic: Capture context and queue for human intervention
              - Preserve partial completion on failure (don't lose work)
              - Add "intervention queue" for unrecoverable errors
              - Display retry status in phase cards (attempt 2/3, next retry in Xs)
              - Add manual "Force Retry" button that bypasses backoff

              Files to modify:
              - scripts/sprint-loop.sh (retry logic)
              - compiler/src/compiler.ts (retry config parsing)
              - compiler/src/status-server/page.ts (retry status UI)

              New files:
              - compiler/src/error-classifier.ts (error classification logic)


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-12-gherkin.md (scenarios to satisfy)
              4. context/step-12-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-12): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-12-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-12-qa-report.md

              ```markdown
              # QA Report: step-12

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-12-qa-report.md
                 git commit -m "qa(step-12): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-12.\n\n## Context\nRead: artifacts/step-12-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-12-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-12-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-12 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Track D - Step 5: Implement Improved Error Recovery

              Add automatic retry with backoff and smart failure detection.

              Requirements:
              - Implement automatic retry with configurable exponential backoff (1s, 5s, 30s)
              - Add retry configuration to SPRINT.yaml:
                ```yaml
                retry:
                  maxAttempts: 3
                  backoffMs: [1000, 5000, 30000]
                  retryOn: [network, rate-limit, timeout]
                ```
              - Classify errors into categories:
                - network: Connection failures, DNS issues
                - rate-limit: API rate limiting (429 errors)
                - timeout: Execution timeout exceeded
                - validation: Schema/input validation failures
                - logic: Claude reasoning/execution errors
              - Implement recovery strategies per error type:
                - network/rate-limit/timeout: Auto-retry with backoff
                - validation: Log and skip (or block for human review)
                - logic: Capture context and queue for human intervention
              - Preserve partial completion on failure (don't lose work)
              - Add "intervention queue" for unrecoverable errors
              - Display retry status in phase cards (attempt 2/3, next retry in Xs)
              - Add manual "Force Retry" button that bypasses backoff

              Files to modify:
              - scripts/sprint-loop.sh (retry logic)
              - compiler/src/compiler.ts (retry config parsing)
              - compiler/src/status-server/page.ts (retry status UI)

              New files:
              - compiler/src/error-classifier.ts (error classification logic)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-12-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-12): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
    started-at: "2026-01-16T13:04:34Z"
  - id: final-qa
    status: pending
    prompt: |
      Comprehensive Quality Assurance for the entire sprint.

      ## Context
      Read: context/_shared-context.md for build/test commands
      Read: context/sprint-plan.md for success criteria

      ## Step 1: Full Build Verification
      Run ALL build checks:
      ```bash
      # Identify commands from _shared-context.md, typically:
      npm run build
      npm run typecheck
      npm run lint
      ```

      Record each result in the QA report.

      ## Step 2: Complete Test Suite
      Run the full test suite:
      ```bash
      npm test
      ```

      Record test results and any failures.

      ## Step 3: Integration Verification
      Verify all steps work together:
      - Check that modules properly import each other
      - Verify no circular dependencies introduced
      - Test end-to-end flow if applicable

      ## Step 4: Regression Check
      Compare against main branch:
      ```bash
      git diff main...HEAD --stat
      ```

      Verify:
      - No unintended changes to existing functionality
      - All modified files are expected per sprint-plan.md
      - No temporary/debug code left in

      ## Step 5: Review All Step QA Reports
      Read all artifacts/step-*-qa-report.md files
      - Verify all steps show PASS status
      - Consolidate any warnings or notes

      ## Step 6: Generate Sprint QA Report
      Create: artifacts/sprint-qa-report.md

      ```markdown
      # Sprint QA Report: 2026-01-16_plugin-enhancements

      ## Build Verification
      | Check | Result | Output |
      |-------|--------|--------|
      | Build | PASS/FAIL | [summary] |
      | TypeCheck | PASS/FAIL | [summary] |
      | Lint | PASS/FAIL | [summary] |

      ## Test Suite
      | Metric | Value |
      |--------|-------|
      | Tests Run | [count] |
      | Passed | [count] |
      | Failed | [count] |
      | Skipped | [count] |

      ## Integration Verification
      - [ ] Modules import correctly
      - [ ] No circular dependencies
      - [ ] End-to-end flow works

      ## Step QA Summary
      | Step | Status | Notes |
      |------|--------|-------|
      | step-0 | PASS | [brief note] |
      | step-1 | PASS | [brief note] |
      ...

      ## Regression Analysis
      [Summary of changes vs main branch]

      ## Issues Found
      [List any issues, or "None"]

      ## Overall Status: PASS / FAIL
      ```

      ## Step 7: Handle Outcome

      ### If PASS:
      - Commit the QA report:
        ```bash
        git add artifacts/sprint-qa-report.md
        git commit -m "qa: sprint-level verification passed"
        ```

      ### If FAIL:
      - Document specific failures in the report
      - Set status to needs-human with details of what failed
      - The sprint cannot proceed to summary/PR until issues are resolved
  - id: summary
    status: pending
    prompt: |
      Generate sprint summary deliverable for user review.

      ## Context
      Read: context/sprint-plan.md for original goals
      Read: artifacts/sprint-qa-report.md for verification results
      Read: All artifacts/step-*-qa-report.md for step details

      ## Step 1: Collect Commit History
      ```bash
      git log main..HEAD --oneline --no-decorate
      ```

      ## Step 2: Collect File Changes
      ```bash
      git diff main..HEAD --stat
      ```

      ## Step 3: Generate Sprint Summary
      Create: artifacts/sprint-summary.md

      ```markdown
      # Sprint Summary: 2026-01-16_plugin-enhancements

      ## What Was Accomplished

      ### Step 0: [Step title]
      - [Key accomplishment 1]
      - [Key accomplishment 2]
      **Files**: [list of files created/modified]

      ### Step 1: [Step title]
      ...

      ## Files Changed
      | File | Change Type | Description |
      |------|-------------|-------------|
      | [path] | Created/Modified/Deleted | [brief description] |

      ## Commits Made
      | Hash | Message |
      |------|---------|
      | [short hash] | [commit message] |

      ## Test Coverage
      [Summary from QA report]

      ## Verification Status
      - Build: PASS
      - TypeCheck: PASS
      - Lint: PASS
      - Tests: [X/Y passed]
      - Integration: PASS

      ## Known Issues / Follow-ups
      [List any, or "None identified"]

      ## Sprint Statistics
      - Steps completed: [X/Y]
      - Total commits: [count]
      - Files changed: [count]
      - Lines added: [count]
      - Lines removed: [count]
      ```

      ## Step 4: Commit Summary
      ```bash
      git add artifacts/sprint-summary.md
      git commit -m "docs: add sprint summary"
      ```
  - id: pr-create
    status: pending
    prompt: "Push the sprint branch and create a pull request.\n\n## Context\nRead: artifacts/sprint-summary.md for PR body content\nRead: artifacts/sprint-qa-report.md for verification checklist\n\n## Step 1: Ensure All Changes Committed\n```bash\ngit status\n```\nIf there are uncommitted changes, commit them appropriately.\n\n## Step 2: Push Branch\n```bash\ngit push -u origin sprint/2026-01-16_plugin-enhancements\n```\n\n## Step 3: Create Pull Request\nUse the sprint summary to create a well-structured PR:\n\n```bash\ngh pr create \\\n  --title \"Sprint: 2026-01-16_plugin-enhancements\" \\\n  --body \"$(cat <<'EOF'\n## Summary\n[Extract key points from sprint-summary.md]\n\n## Changes\n[List of major changes from summary]\n\n## Verification Checklist\n- [x] Build passes\n- [x] TypeCheck passes\n- [x] Lint passes\n- [x] Tests pass\n- [x] Integration verified\n- [x] No regressions\n\n## Test Results\n[Extract from sprint-qa-report.md]\n\n## Files Changed\n[File list from summary]\n\n---\nFull details in `artifacts/sprint-summary.md`\n\n\U0001F916 Generated with Sprint Workflow\nEOF\n)\"\n```\n\n## Step 4: Output PR URL\nCapture and display the PR URL:\n```bash\ngh pr view --json url -q '.url'\n```\n\n## Output\n- Branch pushed to remote\n- Pull request created\n- PR URL displayed for user\n"
current:
  phase: 1
  step: 0
  sub-phase: 1
stats:
  started-at: "2026-01-16T13:01:18Z"
  total-phases: 70
  completed-phases: 0
  total-steps: 13
  completed-steps: 0
