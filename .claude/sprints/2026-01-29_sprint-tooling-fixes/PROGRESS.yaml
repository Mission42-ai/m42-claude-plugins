sprint-id: 2026-01-29_sprint-tooling-fixes
status: completed
phases:
  - id: preflight
    status: completed
    prompt: |
      Prepare sprint context and development plan.

      ## Your Role
      You are the sprint OPERATOR. Your job is to:
      1. Understand the sprint scope
      2. Research the codebase
      3. Create shared context for development phases

      ## Step 1: Read Sprint Definition
      Read the SPRINT.yaml to understand:
      - All steps and their requirements
      - Dependencies between steps
      - Overall sprint goal

      ## Step 2: Research Codebase
      Use the Explore subagent to investigate:
      - Project architecture and patterns
      - Test framework and conventions
      - Build/test/lint commands
      - Related existing code

      ## Step 3: Create Shared Context
      Create: context/_shared-context.md

      ```markdown
      # Sprint Context

      ## Project Info
      - Test framework: [vitest/jest/etc]
      - Test location: [pattern]
      - Build command: `[command]`
      - Test command: `[command]`
      - Lint command: `[command]`

      ## Patterns to Follow
      [Key patterns discovered in codebase]

      ## Sprint Steps Overview
      [Brief summary of each step and dependencies]
      ```

      ## Step 4: Commit
      ```bash
      git add context/
      git commit -m "preflight: sprint context prepared"
      ```
    started-at: '2026-01-29T16:57:36.655Z'
    completed-at: '2026-01-29T17:00:42.365Z'
  - id: development
    status: completed
    steps:
      - id: worktree-config-inheritance
        prompt: |
          Fix: Worktree config not inherited from workflow definition

          ## Problem
          When `run-sprint` loads a SPRINT.yaml that references a workflow with
          `worktree.enabled: true`, it does NOT automatically create a worktree.
          The worktree config in the workflow is completely ignored.

          ## Context
          Read: context/issue-1-worktree-integration.md for full problem analysis.

          ## Expected Behavior
          1. `run-sprint` loads SPRINT.yaml → sees `workflow: plugin-development`
          2. Loads workflow definition → finds `worktree.enabled: true`
          3. Before compilation, checks if worktree exists
          4. If not, creates branch and worktree automatically
          5. Runs sprint IN the worktree

          ## Test Cases (RED phase)
          File: plugins/m42-sprint/compiler/src/worktree.test.ts

          1. `extractWorktreeConfig` - extracts worktree config from workflow
             - Input: workflow with `worktree: { enabled: true, branch-prefix: "sprint/" }`
             - Expected: returns the worktree config object

          2. `shouldCreateWorktree` - returns true when workflow has worktree.enabled
             - Input: SPRINT.yaml referencing workflow with worktree.enabled: true
             - Expected: returns true

          3. `shouldCreateWorktree` - returns false when no worktree config
             - Input: SPRINT.yaml referencing workflow without worktree section
             - Expected: returns false

          4. Integration: workflow worktree config flows to sprint resolution

          ## Implementation (GREEN phase)
          File: plugins/m42-sprint/compiler/src/worktree.ts
          - `extractWorktreeConfig(workflow)` - extract worktree section
          - `shouldCreateWorktree(sprintYaml, workflowsDir)` - check if needed
          - `resolveWorktreePath(sprintId, config)` - compute path

          File: plugins/m42-sprint/commands/run-sprint.md
          - Load referenced workflow before compilation
          - Extract and apply worktree config
          - Create worktree if enabled and doesn't exist

          ## Edge Cases
          - Worktree already exists → reuse it
          - No workflow reference → skip worktree setup
          - Workflow has worktree.enabled: false → skip
        status: completed
        phases:
          - id: execute
            status: completed
            prompt: |
              Fix: Worktree config not inherited from workflow definition

              ## Problem
              When `run-sprint` loads a SPRINT.yaml that references a workflow with
              `worktree.enabled: true`, it does NOT automatically create a worktree.
              The worktree config in the workflow is completely ignored.

              ## Context
              Read: context/issue-1-worktree-integration.md for full problem analysis.

              ## Expected Behavior
              1. `run-sprint` loads SPRINT.yaml → sees `workflow: plugin-development`
              2. Loads workflow definition → finds `worktree.enabled: true`
              3. Before compilation, checks if worktree exists
              4. If not, creates branch and worktree automatically
              5. Runs sprint IN the worktree

              ## Test Cases (RED phase)
              File: plugins/m42-sprint/compiler/src/worktree.test.ts

              1. `extractWorktreeConfig` - extracts worktree config from workflow
                 - Input: workflow with `worktree: { enabled: true, branch-prefix: "sprint/" }`
                 - Expected: returns the worktree config object

              2. `shouldCreateWorktree` - returns true when workflow has worktree.enabled
                 - Input: SPRINT.yaml referencing workflow with worktree.enabled: true
                 - Expected: returns true

              3. `shouldCreateWorktree` - returns false when no worktree config
                 - Input: SPRINT.yaml referencing workflow without worktree section
                 - Expected: returns false

              4. Integration: workflow worktree config flows to sprint resolution

              ## Implementation (GREEN phase)
              File: plugins/m42-sprint/compiler/src/worktree.ts
              - `extractWorktreeConfig(workflow)` - extract worktree section
              - `shouldCreateWorktree(sprintYaml, workflowsDir)` - check if needed
              - `resolveWorktreePath(sprintId, config)` - compute path

              File: plugins/m42-sprint/commands/run-sprint.md
              - Load referenced workflow before compilation
              - Extract and apply worktree config
              - Create worktree if enabled and doesn't exist

              ## Edge Cases
              - Worktree already exists → reuse it
              - No workflow reference → skip worktree setup
              - Workflow has worktree.enabled: false → skip
            started-at: '2026-01-29T17:00:44.397Z'
            completed-at: '2026-01-29T17:06:32.339Z'
        started-at: '2026-01-29T17:00:44.397Z'
        completed-at: '2026-01-29T17:06:32.339Z'
      - id: remove-activity-hook
        prompt: |
          Remove activity hook from /run-sprint command

          ## Problem
          The `/run-sprint` command registers a PostToolUse hook in `.claude/settings.json`
          to capture real-time activity. This adds unnecessary complexity:

          1. Mutates shared `.claude/settings.json` file
          2. Requires backup/restore dance (`.pre-sprint` files)
          3. Causes conflicts when running parallel sprints
          4. Hook script maintenance overhead
          5. `SPRINT_ACTIVITY_VERBOSITY` env var complexity

          ## Why It's Unnecessary
          We already have full transcripts from each `claude -p` invocation. The sprint
          runtime captures these. The status server can:
          1. Watch PROGRESS.yaml for phase/step changes
          2. Tail the current task's output file for live progress
          3. Show completed task summaries from transcripts

          ## Changes Required

          ### 1. Remove from run-sprint.md
          File: `plugins/m42-sprint/commands/run-sprint.md`

          Delete these sections:
          - "Register Sprint Hooks in Settings" (Step 1 in task instructions)
          - All references to `.sprint-hooks.json`
          - All references to `.claude/settings.json.pre-sprint`
          - `--hook-config` flag from the runtime CLI invocation
          - `SPRINT_ACTIVITY_VERBOSITY` documentation

          ### 2. Remove hook script
          Delete: `plugins/m42-sprint/hooks/sprint-activity-hook.sh`

          ### 3. Update runtime CLI
          File: `plugins/m42-sprint/runtime/src/cli.ts`
          - Remove `--hook-config` option if present

          ### 4. Update status server (optional enhancement)
          File: `plugins/m42-sprint/compiler/src/status-server/`
          - Instead of reading `.sprint-activity.jsonl`, tail task output files
          - Or simply show PROGRESS.yaml status without granular activity

          ## Verification
          - `/run-sprint` no longer modifies `.claude/settings.json`
          - No `.sprint-hooks.json` or `.pre-sprint` files created
          - Status server still shows sprint progress
          - Sprint execution works normally
        status: completed
        phases:
          - id: execute
            status: completed
            prompt: |
              Remove activity hook from /run-sprint command

              ## Problem
              The `/run-sprint` command registers a PostToolUse hook in `.claude/settings.json`
              to capture real-time activity. This adds unnecessary complexity:

              1. Mutates shared `.claude/settings.json` file
              2. Requires backup/restore dance (`.pre-sprint` files)
              3. Causes conflicts when running parallel sprints
              4. Hook script maintenance overhead
              5. `SPRINT_ACTIVITY_VERBOSITY` env var complexity

              ## Why It's Unnecessary
              We already have full transcripts from each `claude -p` invocation. The sprint
              runtime captures these. The status server can:
              1. Watch PROGRESS.yaml for phase/step changes
              2. Tail the current task's output file for live progress
              3. Show completed task summaries from transcripts

              ## Changes Required

              ### 1. Remove from run-sprint.md
              File: `plugins/m42-sprint/commands/run-sprint.md`

              Delete these sections:
              - "Register Sprint Hooks in Settings" (Step 1 in task instructions)
              - All references to `.sprint-hooks.json`
              - All references to `.claude/settings.json.pre-sprint`
              - `--hook-config` flag from the runtime CLI invocation
              - `SPRINT_ACTIVITY_VERBOSITY` documentation

              ### 2. Remove hook script
              Delete: `plugins/m42-sprint/hooks/sprint-activity-hook.sh`

              ### 3. Update runtime CLI
              File: `plugins/m42-sprint/runtime/src/cli.ts`
              - Remove `--hook-config` option if present

              ### 4. Update status server (optional enhancement)
              File: `plugins/m42-sprint/compiler/src/status-server/`
              - Instead of reading `.sprint-activity.jsonl`, tail task output files
              - Or simply show PROGRESS.yaml status without granular activity

              ## Verification
              - `/run-sprint` no longer modifies `.claude/settings.json`
              - No `.sprint-hooks.json` or `.pre-sprint` files created
              - Status server still shows sprint progress
              - Sprint execution works normally
            started-at: '2026-01-29T17:06:34.358Z'
            completed-at: '2026-01-29T17:11:36.805Z'
        started-at: '2026-01-29T17:06:34.358Z'
        completed-at: '2026-01-29T17:11:36.805Z'
      - id: human-breakpoints
        prompt: |
          Add breakpoint support for human-in-the-loop review cycles

          ## Problem
          Currently, sprints run fully autonomously. There's no way to pause
          execution at specific points for human review before continuing.

          ## Use Case Example
          ```yaml
          phases:
            - id: plan-features
              for-each: feature
              prompt: "Plan implementation for {{item.name}}"

            - id: review-plans
              break: true  # <-- PAUSE HERE for human review

            - id: implement-features
              for-each: feature # Same collection, second pass
              prompt: "Implement {{item.name}} according to plan"
          ```

          ## Design Requirements

          ### 1. New Phase Property: `break`
          ```yaml
          - id: review-checkpoint
            break: true
          ```

          When `break: true`:
          - Sprint execution pauses AFTER this phase completes
          - PROGRESS.yaml status set to `paused-at-breakpoint`
          - Human reviews output, can edit files if needed
          - Human runs `/resume-sprint` to continue

          ### 2. Schema Changes
          File: `plugins/m42-sprint/compiler/src/types.ts`
          - Add `break?: boolean` to Phase interface

          File: `plugins/m42-sprint/compiler/src/validate.ts`
          - Validate `break` is boolean if present

          ### 3. Runtime Changes
          File: `plugins/m42-sprint/runtime/src/runner.ts` or equivalent
          - Check `phase.break` after phase completion
          - If true, set status to `paused-at-breakpoint` and exit gracefully
          - Store breakpoint phase ID in PROGRESS.yaml for resume

          ### 4. Resume Command Update
          File: `plugins/m42-sprint/commands/resume-sprint.md`
          - Detect `paused-at-breakpoint` status
          - Continue from the phase AFTER the breakpoint

          ## Test Cases
          1. Sprint with `break: true` pauses at correct phase
          2. PROGRESS.yaml shows `paused-at-breakpoint` status
          3. `/resume-sprint` continues from next phase
          4. Multiple breakpoints work correctly
          5. Breakpoint in for-each completes all iterations before pausing

          ## Edge Cases
          - Breakpoint on last phase → sprint completes normally
          - Breakpoint with `for-each` → all iterations complete, then pause
          - Already paused sprint → don't double-pause
        status: completed
        phases:
          - id: execute
            status: completed
            prompt: |
              Add breakpoint support for human-in-the-loop review cycles

              ## Problem
              Currently, sprints run fully autonomously. There's no way to pause
              execution at specific points for human review before continuing.

              ## Use Case Example
              ```yaml
              phases:
                - id: plan-features
                  for-each: feature
                  prompt: "Plan implementation for {{item.name}}"

                - id: review-plans
                  break: true  # <-- PAUSE HERE for human review

                - id: implement-features
                  for-each: feature # Same collection, second pass
                  prompt: "Implement {{item.name}} according to plan"
              ```

              ## Design Requirements

              ### 1. New Phase Property: `break`
              ```yaml
              - id: review-checkpoint
                break: true
              ```

              When `break: true`:
              - Sprint execution pauses AFTER this phase completes
              - PROGRESS.yaml status set to `paused-at-breakpoint`
              - Human reviews output, can edit files if needed
              - Human runs `/resume-sprint` to continue

              ### 2. Schema Changes
              File: `plugins/m42-sprint/compiler/src/types.ts`
              - Add `break?: boolean` to Phase interface

              File: `plugins/m42-sprint/compiler/src/validate.ts`
              - Validate `break` is boolean if present

              ### 3. Runtime Changes
              File: `plugins/m42-sprint/runtime/src/runner.ts` or equivalent
              - Check `phase.break` after phase completion
              - If true, set status to `paused-at-breakpoint` and exit gracefully
              - Store breakpoint phase ID in PROGRESS.yaml for resume

              ### 4. Resume Command Update
              File: `plugins/m42-sprint/commands/resume-sprint.md`
              - Detect `paused-at-breakpoint` status
              - Continue from the phase AFTER the breakpoint

              ## Test Cases
              1. Sprint with `break: true` pauses at correct phase
              2. PROGRESS.yaml shows `paused-at-breakpoint` status
              3. `/resume-sprint` continues from next phase
              4. Multiple breakpoints work correctly
              5. Breakpoint in for-each completes all iterations before pausing

              ## Edge Cases
              - Breakpoint on last phase → sprint completes normally
              - Breakpoint with `for-each` → all iterations complete, then pause
              - Already paused sprint → don't double-pause
            started-at: '2026-01-29T17:11:38.822Z'
            completed-at: '2026-01-29T17:19:11.693Z'
        started-at: '2026-01-29T17:11:38.822Z'
        completed-at: '2026-01-29T17:19:11.693Z'
      - id: quality-gates
        prompt: |
          Add quality gate checks with retry-on-fail capability

          ## Problem
          Need a way to run validation scripts at specific points in a sprint.
          If validation fails, trigger a fix iteration before continuing.

          ## Use Case Example
          ```yaml
          phases:
            - id: implement-feature
              prompt: "Implement the feature"

            - id: verify-tests
              gate:
                script: "npm test -- --grep 'auth'"
                on-fail:
                  prompt: |
                    Tests are failing. Fix the issues:
                    1. Read the test output above
                    2. Identify failing tests
                    3. Fix implementation to pass tests
                  max-retries: 3
          ```

          ## Design Requirements

          ### 1. New Phase Property: `gate`
          ```yaml
          gate:
            script: "bash command returning 0 (pass) or non-0 (fail)"
            on-fail:
              prompt: "Instructions for fixing the failure"
              max-retries: 3  # default: 3, max attempts before escalating
          ```

          ### 2. Schema Changes
          File: `plugins/m42-sprint/compiler/src/types.ts`
          ```typescript
          interface GateCheck {
            script: string;
            'on-fail': {
              prompt: string;
              'max-retries'?: number;  // default 3
            };
          }

          interface Phase {
            // ... existing fields
            gate?: GateCheck;
          }
          ```

          File: `plugins/m42-sprint/compiler/src/validate.ts`
          - Validate gate.script is non-empty string
          - Validate gate.on-fail.prompt is non-empty string
          - Validate max-retries is positive integer if present

          ### 3. Runtime Behavior
          File: `plugins/m42-sprint/runtime/src/runner.ts`

          After phase prompt execution:
          1. If `gate` defined, run `gate.script`
          2. If script returns 0 → continue to next phase
          3. If script returns non-0:
             a. Log: "Gate check failed, attempt N/max-retries"
             b. Execute `on-fail.prompt` as a fix iteration
             c. Re-run gate script
             d. Repeat until pass or max-retries exceeded
          4. If max-retries exceeded → set status `blocked` with reason

          ### 4. PROGRESS.yaml Tracking
          ```yaml
          current-phase: verify-tests
          gate-attempts: 2
          gate-status: retrying  # or: passed, failed, blocked
          ```

          ## Test Cases
          1. Gate with passing script → continues normally
          2. Gate fails once, fix works → retry passes
          3. Gate fails max-retries times → status becomes `blocked`
          4. on-fail.prompt is executed with correct context
          5. Script output is captured and available to fix prompt

          ## Script Environment
          - Working directory: sprint directory
          - Env vars: SPRINT_ID, PHASE_ID, ATTEMPT_NUMBER
          - Stdout/stderr captured for fix prompt context
          - Timeout: 60 seconds (configurable?)

          ## Example Scripts
          ```yaml
          # Run specific tests
          script: "npm test -- --grep 'auth'"

          # Check build succeeds
          script: "npm run build"

          # Custom validation
          script: "./scripts/validate-api-contracts.sh"

          # Multiple checks
          script: "npm run lint && npm run typecheck && npm test"
          ```
        status: completed
        phases:
          - id: execute
            status: completed
            prompt: |
              Add quality gate checks with retry-on-fail capability

              ## Problem
              Need a way to run validation scripts at specific points in a sprint.
              If validation fails, trigger a fix iteration before continuing.

              ## Use Case Example
              ```yaml
              phases:
                - id: implement-feature
                  prompt: "Implement the feature"

                - id: verify-tests
                  gate:
                    script: "npm test -- --grep 'auth'"
                    on-fail:
                      prompt: |
                        Tests are failing. Fix the issues:
                        1. Read the test output above
                        2. Identify failing tests
                        3. Fix implementation to pass tests
                      max-retries: 3
              ```

              ## Design Requirements

              ### 1. New Phase Property: `gate`
              ```yaml
              gate:
                script: "bash command returning 0 (pass) or non-0 (fail)"
                on-fail:
                  prompt: "Instructions for fixing the failure"
                  max-retries: 3  # default: 3, max attempts before escalating
              ```

              ### 2. Schema Changes
              File: `plugins/m42-sprint/compiler/src/types.ts`
              ```typescript
              interface GateCheck {
                script: string;
                'on-fail': {
                  prompt: string;
                  'max-retries'?: number;  // default 3
                };
              }

              interface Phase {
                // ... existing fields
                gate?: GateCheck;
              }
              ```

              File: `plugins/m42-sprint/compiler/src/validate.ts`
              - Validate gate.script is non-empty string
              - Validate gate.on-fail.prompt is non-empty string
              - Validate max-retries is positive integer if present

              ### 3. Runtime Behavior
              File: `plugins/m42-sprint/runtime/src/runner.ts`

              After phase prompt execution:
              1. If `gate` defined, run `gate.script`
              2. If script returns 0 → continue to next phase
              3. If script returns non-0:
                 a. Log: "Gate check failed, attempt N/max-retries"
                 b. Execute `on-fail.prompt` as a fix iteration
                 c. Re-run gate script
                 d. Repeat until pass or max-retries exceeded
              4. If max-retries exceeded → set status `blocked` with reason

              ### 4. PROGRESS.yaml Tracking
              ```yaml
              current-phase: verify-tests
              gate-attempts: 2
              gate-status: retrying  # or: passed, failed, blocked
              ```

              ## Test Cases
              1. Gate with passing script → continues normally
              2. Gate fails once, fix works → retry passes
              3. Gate fails max-retries times → status becomes `blocked`
              4. on-fail.prompt is executed with correct context
              5. Script output is captured and available to fix prompt

              ## Script Environment
              - Working directory: sprint directory
              - Env vars: SPRINT_ID, PHASE_ID, ATTEMPT_NUMBER
              - Stdout/stderr captured for fix prompt context
              - Timeout: 60 seconds (configurable?)

              ## Example Scripts
              ```yaml
              # Run specific tests
              script: "npm test -- --grep 'auth'"

              # Check build succeeds
              script: "npm run build"

              # Custom validation
              script: "./scripts/validate-api-contracts.sh"

              # Multiple checks
              script: "npm run lint && npm run typecheck && npm test"
              ```
            started-at: '2026-01-29T17:19:13.722Z'
            completed-at: '2026-01-29T17:26:16.405Z'
        started-at: '2026-01-29T17:19:13.722Z'
        completed-at: '2026-01-29T17:26:16.405Z'
    started-at: '2026-01-29T17:00:44.397Z'
    completed-at: '2026-01-29T17:26:16.405Z'
  - id: documentation
    status: completed
    prompt: |
      ## Your Role: Documentation OPERATOR

      Update documentation by spawning subagents for each category.

      ## Step 1: Analyze Changes
      ```bash
      git diff main..HEAD --name-only
      git diff main..HEAD --stat
      ```

      Create a list of what changed and needs documenting.

      ## Step 2: Spawn Subagents (in parallel if independent)

      ### User Guide Subagent
      ```
      Task: Update user guide documentation

      Changes made in this sprint:
      [List relevant changes]

      Instructions:
      1. Find existing user guide (docs/USER-GUIDE.md or docs/user-guide/)
      2. Add/update sections for new features
      3. Update examples if behavior changed
      4. Keep it task-oriented and example-rich
      5. Commit: git commit -m "docs(user-guide): update for sprint changes"

      Skip if: No user-facing feature changes
      ```

      ### Getting Started Subagent
      ```
      Task: Update getting started / quickstart docs

      Changes made in this sprint:
      [List relevant changes]

      Instructions:
      1. Find quickstart docs (README.md, docs/getting-started/)
      2. Update installation steps if changed
      3. Update first-steps examples if affected
      4. Ensure copy-paste commands work
      5. Commit: git commit -m "docs(getting-started): update for sprint changes"

      Skip if: No changes affect onboarding flow
      ```

      ### Reference Docs Subagent
      ```
      Task: Update reference documentation

      Changes made in this sprint:
      [List relevant changes]

      Instructions:
      1. Find reference docs (docs/reference/, API docs)
      2. Update command/function signatures
      3. Update configuration options
      4. Update type definitions
      5. Commit: git commit -m "docs(reference): update for sprint changes"

      Skip if: No API/config/type changes
      ```

      ## Step 3: Verify All Documentation
      - Run code examples from docs to verify they work
      - Check internal links are valid
      - Ensure consistency across all doc updates

      ## Output
      Create: artifacts/docs-summary.md

      ```markdown
      # Documentation Summary

      ## Changes Analyzed
      [What changed in the sprint]

      ## Updates Made
      | Category | Status | Changes |
      |----------|--------|---------|
      | User Guide | Updated/Skipped | [summary] |
      | Getting Started | Updated/Skipped | [summary] |
      | Reference | Updated/Skipped | [summary] |

      ## Verification
      - [ ] Code examples tested
      - [ ] Links validated
      ```
    started-at: '2026-01-29T17:26:18.455Z'
    completed-at: '2026-01-29T17:29:12.188Z'
  - id: tooling-update
    status: completed
    prompt: |
      ## Your Role: Tooling OPERATOR

      Ensure all Commands and Skills are up-to-date with implementation changes.

      ## Step 1: Identify Affected Plugin
      ```bash
      git diff main..HEAD --name-only | grep "^plugins/" | cut -d'/' -f2 | sort -u
      ```

      ## Step 2: List All Commands and Skills
      For each affected plugin:
      ```bash
      # List commands
      ls plugins/<plugin>/commands/*.md 2>/dev/null

      # List skills
      ls plugins/<plugin>/skills/*.md 2>/dev/null
      ```

      ## Step 3: Analyze Changes
      ```bash
      git diff main..HEAD --name-only
      git diff main..HEAD --stat
      ```

      Determine which Commands/Skills might be affected by the changes.

      ## Step 4: Spawn Review Subagents (in parallel)

      For EACH Command file, spawn a subagent:
      ```
      Task: Review and update Command - <command-name>

      Implementation changes in this sprint:
      [Summary of relevant changes]

      Instructions:
      1. Read the command file: plugins/<plugin>/commands/<command>.md
      2. Compare against current implementation
      3. Check if examples, descriptions, or behavior changed
      4. Update ONLY if necessary - no cosmetic changes
      5. If updated: git commit -m "docs(<command>): sync with implementation"

      Skip if: Command is unaffected by changes
      ```

      For EACH Skill file, spawn a subagent:
      ```
      Task: Review and update Skill - <skill-name>

      Implementation changes in this sprint:
      [Summary of relevant changes]

      Instructions:
      1. Read the skill file: plugins/<plugin>/skills/<skill>.md
      2. Compare against current implementation
      3. Check if triggers, examples, or capabilities changed
      4. Update ONLY if necessary - no cosmetic changes
      5. If updated: git commit -m "docs(<skill>): sync with implementation"

      Skip if: Skill is unaffected by changes
      ```

      ## Step 5: Generate Tooling Report
      Create: artifacts/tooling-update-summary.md

      ```markdown
      # Tooling Update Summary

      ## Commands Reviewed
      | Command | Status | Changes |
      |---------|--------|---------|
      | <name> | Updated/Unchanged | [summary] |

      ## Skills Reviewed
      | Skill | Status | Changes |
      |-------|--------|---------|
      | <name> | Updated/Unchanged | [summary] |

      ## Verification
      - All commands reflect current implementation
      - All skills reflect current capabilities
      ```

      Commit:
      ```bash
      git add artifacts/tooling-update-summary.md
      git commit -m "tooling: commands and skills synced"
      ```
    started-at: '2026-01-29T17:29:14.208Z'
    completed-at: '2026-01-29T17:35:53.422Z'
  - id: version-bump
    status: completed
    prompt: |
      ## Your Role: Version OPERATOR

      Update plugin version based on sprint changes following semantic versioning.

      ## Step 1: Identify Affected Plugin
      ```bash
      git diff main..HEAD --name-only | grep "^plugins/" | cut -d'/' -f2 | sort -u
      ```

      For each affected plugin, perform steps 2-5.

      ## Step 2: Analyze Changes for Version Type

      Examine all changes to determine version bump type:
      ```bash
      git log main..HEAD --oneline
      git diff main..HEAD --stat
      ```

      ### Version Bump Rules (Semantic Versioning)

      **MAJOR (x.0.0)** - Breaking changes:
      - Schema changes that break existing SPRINT.yaml/workflow files
      - Removed commands or required flags
      - Changed behavior that breaks existing usage
      - API changes requiring user migration

      **MINOR (0.x.0)** - New features (backwards compatible):
      - New commands or skills added
      - New optional configuration options
      - New workflow phases or capabilities
      - New validation rules (non-breaking)

      **PATCH (0.0.x)** - Bug fixes and maintenance:
      - Bug fixes
      - Documentation updates only
      - Test additions/fixes
      - Performance improvements
      - Internal refactoring (no API changes)

      ## Step 3: Read Current Version
      ```bash
      cat plugins/<plugin>/.claude-plugin/plugin.json | grep '"version"'
      ```

      Calculate new version based on bump type.

      ## Step 4: Update plugin.json

      Edit `plugins/<plugin>/.claude-plugin/plugin.json`:
      - Update the `version` field to the new version

      ## Step 5: Update CHANGELOG.md

      Create or update `plugins/<plugin>/CHANGELOG.md`:

      ```markdown
      # Changelog

      All notable changes to this plugin will be documented in this file.

      ## [X.Y.Z] - YYYY-MM-DD

      ### Added
      - [New features added in this sprint]

      ### Changed
      - [Changes to existing functionality]

      ### Fixed
      - [Bug fixes]

      ### Removed
      - [Removed features]

      ---
      [Previous versions below...]
      ```

      Guidelines:
      - Use today's date
      - Keep entries concise (one line per change)
      - Group by category (Added/Changed/Fixed/Removed)
      - Only include user-facing changes
      - Reference issue numbers if applicable

      ## Step 6: Commit Version Bump
      ```bash
      git add plugins/<plugin>/.claude-plugin/plugin.json
      git add plugins/<plugin>/CHANGELOG.md
      git commit -m "chore: bump <plugin> version to X.Y.Z"
      ```

      ## Output
      Report version changes made:
      ```
      Version bump: <plugin> v1.2.3 → v1.3.0 (MINOR)
      Reason: Added new for-each collection feature
      ```
    started-at: '2026-01-29T17:35:55.453Z'
    completed-at: '2026-01-29T17:37:35.053Z'
  - id: final-qa
    status: completed
    prompt: |
      ## Your Role: QA OPERATOR

      Verify the entire sprint meets quality standards.

      ## Step 1: Build Verification
      ```bash
      npm run build
      npm run typecheck
      npm run lint
      ```

      All must pass. If any fail, spawn fix subagent.

      ## Step 2: Full Test Suite
      ```bash
      npm test
      ```

      All tests must pass. Record coverage if available.

      ## Step 3: Review All Step Artifacts
      Read each artifacts/{{item.id}}-complete.md to verify all steps finished.

      ## Step 4: Integration Check
      - Verify modules import correctly
      - Check for circular dependencies
      - Run any integration tests

      ## Step 5: Generate QA Report
      Create: artifacts/sprint-qa-report.md

      ```markdown
      # Sprint QA Report

      ## Build Status
      | Check | Status |
      |-------|--------|
      | Build | PASS/FAIL |
      | TypeCheck | PASS/FAIL |
      | Lint | PASS/FAIL |

      ## Test Results
      - Total: [N]
      - Passed: [N]
      - Failed: [N]
      - Coverage: [%]

      ## Step Verification
      | Step | Status |
      |------|--------|
      | [step-id] | COMPLETE |

      ## Overall: PASS / FAIL
      ```

      ## Handle Failures
      If any check fails:
      1. Spawn fix subagent with specific error details
      2. Re-run verification
      3. If still failing, escalate to human

      Commit:
      ```bash
      git add artifacts/sprint-qa-report.md
      git commit -m "qa: sprint verification complete"
      ```
    started-at: '2026-01-29T17:37:37.075Z'
    completed-at: '2026-01-29T17:40:57.741Z'
  - id: summary
    status: completed
    prompt: |
      Generate sprint summary for PR.

      ## Collect Information
      - Read all artifacts/*-complete.md
      - Read artifacts/sprint-qa-report.md
      - Get commit history: `git log main..HEAD --oneline`
      - Get file changes: `git diff main..HEAD --stat`

      ## Create Summary
      Create: artifacts/sprint-summary.md

      ```markdown
      # Sprint Summary: 2026-01-29_sprint-tooling-fixes

      ## Completed Steps
      [For each step: what was accomplished]

      ## Test Coverage
      - Tests added: [N]
      - All tests passing: Yes

      ## Files Changed
      [Summary of changes]

      ## Commits
      [List of commits]

      ## Ready for Review
      - Build: PASS
      - Tests: PASS
      - Lint: PASS
      - Docs: Updated
      ```

      Commit:
      ```bash
      git add artifacts/sprint-summary.md
      git commit -m "docs: sprint summary"
      ```
    started-at: '2026-01-29T17:40:59.755Z'
    completed-at: '2026-01-29T17:42:21.188Z'
  - id: pr-create
    status: completed
    prompt: |
      Push branch and create pull request.

      ## Step 1: Verify Clean State
      ```bash
      git status
      ```

      ## Step 2: Push Branch
      ```bash
      git push -u origin HEAD
      ```

      ## Step 3: Create PR
      Read artifacts/sprint-summary.md for PR body content.

      ```bash
      gh pr create \
        --title "2026-01-29_sprint-tooling-fixes" \
        --body "$(cat <<'EOF'
      ## Summary
      [Key points from sprint-summary.md]

      ## Changes
      [List major changes]

      ## Verification
      - [x] Build passes
      - [x] All tests pass
      - [x] Lint passes
      - [x] Documentation updated

      ---
      See `artifacts/sprint-summary.md` for full details.
      EOF
      )"
      ```

      ## Step 4: Output PR URL
      ```bash
      gh pr view --json url -q '.url'
      ```
    started-at: '2026-01-29T17:42:23.201Z'
    completed-at: '2026-01-29T17:43:22.765Z'
current:
  phase: 7
  step: null
  sub-phase: null
stats:
  started-at: '2026-01-29T16:57:36.638Z'
  total-phases: 12
  completed-phases: 0
  total-steps: 4
  completed-steps: 0
  current-iteration: 11
  completed-at: '2026-01-29T17:43:22.765Z'
  elapsed: 45m 46s
parallel-tasks: []
last-activity: '2026-01-29T17:42:23.197Z'
summary: Phase completed
