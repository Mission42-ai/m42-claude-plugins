sprint-id: 2026-01-18_parallel-execution
status: in-progress
phases:
  - id: preflight
    status: completed
    prompt: >
      Create comprehensive sprint context that ALL subsequent phases will reference.


      ## Your Task

      Analyze the entire sprint scope and generate shared context documents.


      ## Step 1: Create Sprint Branch

      ```bash

      git checkout -b sprint/2026-01-18_parallel-execution 2>/dev/null || git checkout sprint/2026-01-18_parallel-execution

      ```


      ## Step 2: Analyze Sprint Scope

      Read SPRINT.yaml to understand:

      - All steps and their relationships

      - Overall sprint goal

      - Technical requirements across all steps

      - Potential dependencies between steps


      ## Step 3: Research Project Context

      Investigate the codebase to understand:

      - Project architecture and structure

      - Key patterns and conventions used

      - Relevant types and interfaces

      - Build/test/lint commands

      - Dependencies (internal modules, external packages)


      ## Step 4: Generate Shared Context

      Create: context/_shared-context.md


      ```markdown

      # Shared Sprint Context


      ## Project Architecture

      [High-level architecture overview relevant to this sprint]


      ## Key Patterns

      - [Pattern 1]: [Where and how it's used]

      - [Pattern 2]: [Where and how it's used]

      ...


      ## Conventions

      - Naming: [Naming conventions]

      - File structure: [File organization patterns]

      - Testing: [Testing patterns and frameworks]

      - Error handling: [Error handling patterns]


      ## Commands

      - Build: `[build command]`

      - Test: `[test command]`

      - Lint: `[lint command]`

      - TypeCheck: `[typecheck command]`


      ## Dependencies

      ### Internal Modules

      - [Module]: [Purpose]


      ### External Packages

      - [Package]: [Usage]


      ## Types and Interfaces

      [Key types relevant to this sprint]

      ```


      ## Step 5: Generate Sprint Plan

      Create: context/sprint-plan.md


      ```markdown

      # Sprint Plan: 2026-01-18_parallel-execution


      ## Goal

      [One paragraph describing what this sprint accomplishes]


      ## Success Criteria

      - [ ] [Measurable criterion 1]

      - [ ] [Measurable criterion 2]

      ...


      ## Step Breakdown


      ### Step 0: [Step title from prompt]

      **Scope**: [What this step does]

      **Files**: [Expected files to create/modify]

      **Dependencies**: [What it depends on]

      **Risk**: Low/Medium/High - [reason]


      ### Step 1: ...

      [Continue for all steps]


      ## Step Dependency Graph

      ```

      step-0 → step-1 → step-2






















































































                ↓
              step-3
      ```

      [Or describe dependencies textually]


      ## Risk Assessment

      | Risk | Impact | Mitigation |

      |------|--------|------------|

      | [Risk 1] | [Impact] | [How to mitigate] |


      ## Estimated Complexity

      | Step | Complexity | Reason |

      |------|------------|--------|

      | step-0 | Low/Medium/High | [Brief reason] |

      ```


      ## Output

      - Sprint branch created/checked out

      - context/_shared-context.md with project patterns

      - context/sprint-plan.md with step analysis

      - Commit preflight artifacts:






















































































        ```bash
        git add context/
        git commit -m "preflight: add shared context and sprint plan"
        ```
    started-at: "2026-01-17T23:57:42Z"
    completed-at: "2026-01-18T00:00:19Z"
    elapsed: 00:02:37
  - id: development
    status: in-progress
    steps:
      - id: step-0
        prompt: |
          Add parallel execution types to compiler/src/types.ts:

          1. Add `parallel?: boolean` to WorkflowPhase interface (lines 68-77)
          2. Add `wait-for-parallel?: boolean` to WorkflowPhase interface
          3. Create new ParallelTask interface with fields:
             - id, step-id, phase-id
             - status: 'spawned' | 'running' | 'completed' | 'failed'
             - pid, log-file, spawned-at, completed-at, exit-code, error
          4. Add `parallel-tasks?: ParallelTask[]` to CompiledProgress (lines 202-211)
          5. Add `parallel?: boolean` and `parallel-task-id?: string` to CompiledPhase (lines 101-119)
          6. Add `wait-for-parallel?: boolean` to CompiledTopPhase (lines 148-168)

          Reference: context/implementation-plan.md sections 4.A and 5
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Add parallel execution types to compiler/src/types.ts:

              1. Add `parallel?: boolean` to WorkflowPhase interface (lines 68-77)
              2. Add `wait-for-parallel?: boolean` to WorkflowPhase interface
              3. Create new ParallelTask interface with fields:
                 - id, step-id, phase-id
                 - status: 'spawned' | 'running' | 'completed' | 'failed'
                 - pid, log-file, spawned-at, completed-at, exit-code, error
              4. Add `parallel-tasks?: ParallelTask[]` to CompiledProgress (lines 202-211)
              5. Add `parallel?: boolean` and `parallel-task-id?: string` to CompiledPhase (lines 101-119)
              6. Add `wait-for-parallel?: boolean` to CompiledTopPhase (lines 148-168)

              Reference: context/implementation-plan.md sections 4.A and 5


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-0-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-0

              ## Step Task
              Add parallel execution types to compiler/src/types.ts:

              1. Add `parallel?: boolean` to WorkflowPhase interface (lines 68-77)
              2. Add `wait-for-parallel?: boolean` to WorkflowPhase interface
              3. Create new ParallelTask interface with fields:
                 - id, step-id, phase-id
                 - status: 'spawned' | 'running' | 'completed' | 'failed'
                 - pid, log-file, spawned-at, completed-at, exit-code, error
              4. Add `parallel-tasks?: ParallelTask[]` to CompiledProgress (lines 202-211)
              5. Add `parallel?: boolean` and `parallel-task-id?: string` to CompiledPhase (lines 101-119)
              6. Add `wait-for-parallel?: boolean` to CompiledTopPhase (lines 148-168)

              Reference: context/implementation-plan.md sections 4.A and 5


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-0-gherkin.md
              git commit -m "plan(step-0): define gherkin scenarios"
              ```
            started-at: "2026-01-18T00:00:22Z"
            completed-at: "2026-01-18T00:01:18Z"
            elapsed: 00:00:56
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Add parallel execution types to compiler/src/types.ts:

              1. Add `parallel?: boolean` to WorkflowPhase interface (lines 68-77)
              2. Add `wait-for-parallel?: boolean` to WorkflowPhase interface
              3. Create new ParallelTask interface with fields:
                 - id, step-id, phase-id
                 - status: 'spawned' | 'running' | 'completed' | 'failed'
                 - pid, log-file, spawned-at, completed-at, exit-code, error
              4. Add `parallel-tasks?: ParallelTask[]` to CompiledProgress (lines 202-211)
              5. Add `parallel?: boolean` and `parallel-task-id?: string` to CompiledPhase (lines 101-119)
              6. Add `wait-for-parallel?: boolean` to CompiledTopPhase (lines 148-168)

              Reference: context/implementation-plan.md sections 4.A and 5


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-0-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-0-context.md

              ```markdown
              # Step Context: step-0

              ## Task
              Add parallel execution types to compiler/src/types.ts:

              1. Add `parallel?: boolean` to WorkflowPhase interface (lines 68-77)
              2. Add `wait-for-parallel?: boolean` to WorkflowPhase interface
              3. Create new ParallelTask interface with fields:
                 - id, step-id, phase-id
                 - status: 'spawned' | 'running' | 'completed' | 'failed'
                 - pid, log-file, spawned-at, completed-at, exit-code, error
              4. Add `parallel-tasks?: ParallelTask[]` to CompiledProgress (lines 202-211)
              5. Add `parallel?: boolean` and `parallel-task-id?: string` to CompiledPhase (lines 101-119)
              6. Add `wait-for-parallel?: boolean` to CompiledTopPhase (lines 148-168)

              Reference: context/implementation-plan.md sections 4.A and 5


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-0-context.md
              git commit -m "context(step-0): gather implementation context"
              ```
            started-at: "2026-01-18T00:01:22Z"
            completed-at: "2026-01-18T00:02:17Z"
            elapsed: 00:00:55
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Add parallel execution types to compiler/src/types.ts:

              1. Add `parallel?: boolean` to WorkflowPhase interface (lines 68-77)
              2. Add `wait-for-parallel?: boolean` to WorkflowPhase interface
              3. Create new ParallelTask interface with fields:
                 - id, step-id, phase-id
                 - status: 'spawned' | 'running' | 'completed' | 'failed'
                 - pid, log-file, spawned-at, completed-at, exit-code, error
              4. Add `parallel-tasks?: ParallelTask[]` to CompiledProgress (lines 202-211)
              5. Add `parallel?: boolean` and `parallel-task-id?: string` to CompiledPhase (lines 101-119)
              6. Add `wait-for-parallel?: boolean` to CompiledTopPhase (lines 148-168)

              Reference: context/implementation-plan.md sections 4.A and 5


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-0-gherkin.md (scenarios to satisfy)
              4. context/step-0-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-0): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-18T00:02:20Z"
            completed-at: "2026-01-18T00:05:01Z"
            elapsed: 00:02:41
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-0-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-0-qa-report.md

              ```markdown
              # QA Report: step-0

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-0-qa-report.md
                 git commit -m "qa(step-0): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-0.\n\n## Context\nRead: artifacts/step-0-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-0-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-0-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-0 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-18T00:05:04Z"
            completed-at: "2026-01-18T00:06:54Z"
            elapsed: 00:01:50
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Add parallel execution types to compiler/src/types.ts:

              1. Add `parallel?: boolean` to WorkflowPhase interface (lines 68-77)
              2. Add `wait-for-parallel?: boolean` to WorkflowPhase interface
              3. Create new ParallelTask interface with fields:
                 - id, step-id, phase-id
                 - status: 'spawned' | 'running' | 'completed' | 'failed'
                 - pid, log-file, spawned-at, completed-at, exit-code, error
              4. Add `parallel-tasks?: ParallelTask[]` to CompiledProgress (lines 202-211)
              5. Add `parallel?: boolean` and `parallel-task-id?: string` to CompiledPhase (lines 101-119)
              6. Add `wait-for-parallel?: boolean` to CompiledTopPhase (lines 148-168)

              Reference: context/implementation-plan.md sections 4.A and 5


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-0-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-0): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-18T00:06:58Z"
            completed-at: "2026-01-18T00:08:46Z"
            elapsed: 00:01:48
      - id: step-1
        prompt: |
          Update compiler/src/expand-foreach.ts to propagate parallel flag:

          1. In expandStep() function (lines 84-130)
          2. When creating CompiledPhase objects in the map (line 117-121)
          3. Add: `parallel: phase.parallel` to propagate the flag from WorkflowPhase to CompiledPhase

          This ensures sub-phases marked as parallel in workflow definitions are compiled with the parallel flag.

          Reference: context/implementation-plan.md section 4.B
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Update compiler/src/expand-foreach.ts to propagate parallel flag:

              1. In expandStep() function (lines 84-130)
              2. When creating CompiledPhase objects in the map (line 117-121)
              3. Add: `parallel: phase.parallel` to propagate the flag from WorkflowPhase to CompiledPhase

              This ensures sub-phases marked as parallel in workflow definitions are compiled with the parallel flag.

              Reference: context/implementation-plan.md section 4.B


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-1-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-1

              ## Step Task
              Update compiler/src/expand-foreach.ts to propagate parallel flag:

              1. In expandStep() function (lines 84-130)
              2. When creating CompiledPhase objects in the map (line 117-121)
              3. Add: `parallel: phase.parallel` to propagate the flag from WorkflowPhase to CompiledPhase

              This ensures sub-phases marked as parallel in workflow definitions are compiled with the parallel flag.

              Reference: context/implementation-plan.md section 4.B


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-1-gherkin.md
              git commit -m "plan(step-1): define gherkin scenarios"
              ```
            started-at: "2026-01-18T00:08:50Z"
            completed-at: "2026-01-18T00:09:45Z"
            elapsed: 00:00:55
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Update compiler/src/expand-foreach.ts to propagate parallel flag:

              1. In expandStep() function (lines 84-130)
              2. When creating CompiledPhase objects in the map (line 117-121)
              3. Add: `parallel: phase.parallel` to propagate the flag from WorkflowPhase to CompiledPhase

              This ensures sub-phases marked as parallel in workflow definitions are compiled with the parallel flag.

              Reference: context/implementation-plan.md section 4.B


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-1-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-1-context.md

              ```markdown
              # Step Context: step-1

              ## Task
              Update compiler/src/expand-foreach.ts to propagate parallel flag:

              1. In expandStep() function (lines 84-130)
              2. When creating CompiledPhase objects in the map (line 117-121)
              3. Add: `parallel: phase.parallel` to propagate the flag from WorkflowPhase to CompiledPhase

              This ensures sub-phases marked as parallel in workflow definitions are compiled with the parallel flag.

              Reference: context/implementation-plan.md section 4.B


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-1-context.md
              git commit -m "context(step-1): gather implementation context"
              ```
            started-at: "2026-01-18T00:09:49Z"
            completed-at: "2026-01-18T00:10:53Z"
            elapsed: 00:01:04
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Update compiler/src/expand-foreach.ts to propagate parallel flag:

              1. In expandStep() function (lines 84-130)
              2. When creating CompiledPhase objects in the map (line 117-121)
              3. Add: `parallel: phase.parallel` to propagate the flag from WorkflowPhase to CompiledPhase

              This ensures sub-phases marked as parallel in workflow definitions are compiled with the parallel flag.

              Reference: context/implementation-plan.md section 4.B


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-1-gherkin.md (scenarios to satisfy)
              4. context/step-1-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-1): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-18T00:10:54Z"
            completed-at: "2026-01-18T00:12:11Z"
            elapsed: 00:01:17
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-1-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-1-qa-report.md

              ```markdown
              # QA Report: step-1

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-1-qa-report.md
                 git commit -m "qa(step-1): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-1.\n\n## Context\nRead: artifacts/step-1-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-1-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-1-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-1 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-18T00:12:15Z"
            completed-at: "2026-01-18T00:14:45Z"
            elapsed: 00:02:30
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Update compiler/src/expand-foreach.ts to propagate parallel flag:

              1. In expandStep() function (lines 84-130)
              2. When creating CompiledPhase objects in the map (line 117-121)
              3. Add: `parallel: phase.parallel` to propagate the flag from WorkflowPhase to CompiledPhase

              This ensures sub-phases marked as parallel in workflow definitions are compiled with the parallel flag.

              Reference: context/implementation-plan.md section 4.B


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-1-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-1): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-2
        prompt: >
          Update compiler/src/compile.ts to initialize parallel-tasks array:


          1. In the compile() function around line 209 where CompiledProgress is built

          2. Add initialization: `'parallel-tasks': []`

          3. Propagate `wait-for-parallel` from WorkflowPhase to CompiledTopPhase in expandForEach and compileSimplePhase


          Reference: context/implementation-plan.md section 4.C

        status: pending
        phases:
          - id: plan
            status: pending
            prompt: >
              Generate binary-verifiable gherkin scenarios for this step.


              ## Your Task

              Update compiler/src/compile.ts to initialize parallel-tasks array:


              1. In the compile() function around line 209 where CompiledProgress is built

              2. Add initialization: `'parallel-tasks': []`

              3. Propagate `wait-for-parallel` from WorkflowPhase to CompiledTopPhase in expandForEach and compileSimplePhase


              Reference: context/implementation-plan.md section 4.C



              ## Shared Context

              Read: context/_shared-context.md (project patterns, conventions, commands)

              Read: context/sprint-plan.md (how this step fits in the sprint)


              ## Instructions

              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.

              Each scenario MUST have:

              1. Clear Given/When/Then structure

              2. An explicit verification command that returns exit code 0 on success

              3. Binary outcome: exactly 1 (pass) or 0 (fail)


              ## Gherkin Format

              Each scenario follows this exact structure:


              ```gherkin

              Scenario: [Descriptive name]






















































































                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ## Example Scenarios


              ### File Existence

              ```gherkin

              Scenario: Source file exists






















































































                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ### TypeScript Compilation

              ```gherkin

              Scenario: TypeScript compiles without errors






















































































                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ### Function Export

              ```gherkin

              Scenario: Login function is exported






















































































                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ### Test Execution

              ```gherkin

              Scenario: Unit tests pass






















































































                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ### Lint Check

              ```gherkin

              Scenario: Code passes linting






















































































                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ## Output

              Create: artifacts/step-2-gherkin.md


              ```markdown

              # Gherkin Scenarios: step-2


              ## Step Task

              Update compiler/src/compile.ts to initialize parallel-tasks array:


              1. In the compile() function around line 209 where CompiledProgress is built

              2. Add initialization: `'parallel-tasks': []`

              3. Propagate `wait-for-parallel` from WorkflowPhase to CompiledTopPhase in expandForEach and compileSimplePhase


              Reference: context/implementation-plan.md section 4.C



              ## Success Criteria

              All scenarios must pass (score = 1) for the step to be complete.

              Total scenarios: [N]

              Required score: [N]/[N]


              ---


              ## Scenario 1: [Name]

              [Full gherkin with verification as shown above]


              ---


              ## Scenario 2: [Name]

              ...


              [Continue for 4-8 scenarios]

              ```


              ## Commit

              ```bash

              git add artifacts/step-2-gherkin.md

              git commit -m "plan(step-2): define gherkin scenarios"

              ```

          - id: context
            status: pending
            prompt: >
              Gather step-specific context for implementation.


              ## Your Task

              Update compiler/src/compile.ts to initialize parallel-tasks array:


              1. In the compile() function around line 209 where CompiledProgress is built

              2. Add initialization: `'parallel-tasks': []`

              3. Propagate `wait-for-parallel` from WorkflowPhase to CompiledTopPhase in expandForEach and compileSimplePhase


              Reference: context/implementation-plan.md section 4.C



              ## Shared Context

              Read: context/_shared-context.md (already has project-wide patterns)

              Read: artifacts/step-2-gherkin.md (scenarios to implement)


              ## Instructions

              Research the specific code areas this step will touch:


              1. **Related Existing Code**






















































































                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**






















































































                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**






















































































                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**






















































































                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output

              Create: context/step-2-context.md


              ```markdown

              # Step Context: step-2


              ## Task

              Update compiler/src/compile.ts to initialize parallel-tasks array:


              1. In the compile() function around line 209 where CompiledProgress is built

              2. Add initialization: `'parallel-tasks': []`

              3. Propagate `wait-for-parallel` from WorkflowPhase to CompiledTopPhase in expandForEach and compileSimplePhase


              Reference: context/implementation-plan.md section 4.C



              ## Related Code Patterns


              ### Similar Implementation: [path]

              ```typescript

              // Key pattern to follow

              [relevant code snippet]

              ```


              ### Similar Implementation: [path]

              [continue as needed]


              ## Required Imports

              ### Internal

              - `[module]`: [what to import]


              ### External

              - `[package]`: [what to import]


              ## Types/Interfaces to Use

              ```typescript

              // From [source]

              interface [Name] {






















































































                [relevant fields]
              }

              ```


              ## Integration Points

              - Called by: [who will use this]

              - Calls: [what this will call]

              - Tests: [related test files]


              ## Implementation Notes

              - [Specific note 1]

              - [Specific note 2]

              ```


              ## Commit

              ```bash

              git add context/step-2-context.md

              git commit -m "context(step-2): gather implementation context"

              ```

          - id: execute
            status: pending
            prompt: >
              Implement the step following gherkin scenarios and context.


              ## Your Task

              Update compiler/src/compile.ts to initialize parallel-tasks array:


              1. In the compile() function around line 209 where CompiledProgress is built

              2. Add initialization: `'parallel-tasks': []`

              3. Propagate `wait-for-parallel` from WorkflowPhase to CompiledTopPhase in expandForEach and compileSimplePhase


              Reference: context/implementation-plan.md section 4.C



              ## MUST READ BEFORE IMPLEMENTING

              Read these files in order:

              1. context/_shared-context.md (project patterns, conventions)

              2. context/sprint-plan.md (how this fits in sprint)

              3. artifacts/step-2-gherkin.md (scenarios to satisfy)

              4. context/step-2-context.md (specific patterns, imports)


              ## Implementation Rules


              ### Follow the Gherkin

              Your implementation MUST satisfy ALL gherkin scenarios.

              Each scenario has a verification command - mentally run it to check your work.


              ### Follow the Context

              - Use patterns from similar implementations

              - Import from specified modules

              - Implement required interfaces

              - Follow naming conventions


              ### Code Quality

              - Keep code simple and focused

              - Follow existing patterns exactly

              - No over-engineering or extra abstractions

              - Only implement what's needed for the scenarios


              ### Commits

              Make atomic commits for logical units:

              ```bash

              # After each logical piece

              git add [files]

              git commit -m "[type](step-2): [description]"

              ```


              Types: feat, fix, refactor, test, docs


              ## Implementation Checklist

              Before marking complete, verify:

              - [ ] All files from gherkin scenarios exist

              - [ ] Code follows patterns from context

              - [ ] Imports are correct

              - [ ] No TypeScript errors (run typecheck mentally)

              - [ ] Each scenario's verification should pass


              ## If Blocked

              If you encounter an issue that prevents completion:

              - Document the blocker clearly

              - Set status to needs-human

              - Do NOT leave partial/broken implementation

          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-2-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-2-qa-report.md

              ```markdown
              # QA Report: step-2

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-2-qa-report.md
                 git commit -m "qa(step-2): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-2.\n\n## Context\nRead: artifacts/step-2-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-2-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-2-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-2 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: >
              Final integration verification for the step.


              ## Your Task

              Update compiler/src/compile.ts to initialize parallel-tasks array:


              1. In the compile() function around line 209 where CompiledProgress is built

              2. Add initialization: `'parallel-tasks': []`

              3. Propagate `wait-for-parallel` from WorkflowPhase to CompiledTopPhase in expandForEach and compileSimplePhase


              Reference: context/implementation-plan.md section 4.C



              ## Context

              Read: context/_shared-context.md (build commands)

              Read: artifacts/step-2-qa-report.md (should show PASS)


              ## Step 1: Build Verification

              Run the project build to ensure this step integrates:

              ```bash

              # Use commands from _shared-context.md, typically:

              npm run build

              npm run typecheck

              ```


              ## Step 2: Integration Check

              Verify this step works with the rest of the sprint:

              - Check imports resolve correctly

              - Verify no circular dependencies

              - Ensure types are compatible


              ## Step 3: Smoke Test

              If possible, manually verify the functionality:

              - Run the code path that uses this step's output

              - Check expected behavior matches gherkin scenarios


              ## Step 4: Final Commit

              If all verification passes:

              ```bash

              git add -A

              git status  # Check for any uncommitted changes

              # Only commit if there are changes

              git diff --cached --quiet || git commit -m "verify(step-2): integration verified"

              ```


              ## Outcome

              - If integration passes: Mark step as complete

              - If integration fails: Document the issue and set status to needs-human


              ## Important

              This is the final gate before moving to the next step.

              The step's gherkin scenarios already passed in QA.

              This phase ensures the step works in the broader context.

      - id: step-3
        prompt: >
          Update compiler/src/validate.ts with parallel validation:


          1. In validateWorkflowPhase() function (lines 174-235)

          2. Add validation for `parallel` property (must be boolean if present)

          3. Add validation for `wait-for-parallel` property (must be boolean if present)

          4. Add warning if `parallel: true` is used on a for-each phase (not supported - should be used in step workflows only)


          Reference: context/implementation-plan.md section 4.D

        status: pending
        phases:
          - id: plan
            status: pending
            prompt: >
              Generate binary-verifiable gherkin scenarios for this step.


              ## Your Task

              Update compiler/src/validate.ts with parallel validation:


              1. In validateWorkflowPhase() function (lines 174-235)

              2. Add validation for `parallel` property (must be boolean if present)

              3. Add validation for `wait-for-parallel` property (must be boolean if present)

              4. Add warning if `parallel: true` is used on a for-each phase (not supported - should be used in step workflows only)


              Reference: context/implementation-plan.md section 4.D



              ## Shared Context

              Read: context/_shared-context.md (project patterns, conventions, commands)

              Read: context/sprint-plan.md (how this step fits in the sprint)


              ## Instructions

              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.

              Each scenario MUST have:

              1. Clear Given/When/Then structure

              2. An explicit verification command that returns exit code 0 on success

              3. Binary outcome: exactly 1 (pass) or 0 (fail)


              ## Gherkin Format

              Each scenario follows this exact structure:


              ```gherkin

              Scenario: [Descriptive name]






















































































                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ## Example Scenarios


              ### File Existence

              ```gherkin

              Scenario: Source file exists






















































































                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ### TypeScript Compilation

              ```gherkin

              Scenario: TypeScript compiles without errors






















































































                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ### Function Export

              ```gherkin

              Scenario: Login function is exported






















































































                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ### Test Execution

              ```gherkin

              Scenario: Unit tests pass






















































































                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ### Lint Check

              ```gherkin

              Scenario: Code passes linting






















































































                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ## Output

              Create: artifacts/step-3-gherkin.md


              ```markdown

              # Gherkin Scenarios: step-3


              ## Step Task

              Update compiler/src/validate.ts with parallel validation:


              1. In validateWorkflowPhase() function (lines 174-235)

              2. Add validation for `parallel` property (must be boolean if present)

              3. Add validation for `wait-for-parallel` property (must be boolean if present)

              4. Add warning if `parallel: true` is used on a for-each phase (not supported - should be used in step workflows only)


              Reference: context/implementation-plan.md section 4.D



              ## Success Criteria

              All scenarios must pass (score = 1) for the step to be complete.

              Total scenarios: [N]

              Required score: [N]/[N]


              ---


              ## Scenario 1: [Name]

              [Full gherkin with verification as shown above]


              ---


              ## Scenario 2: [Name]

              ...


              [Continue for 4-8 scenarios]

              ```


              ## Commit

              ```bash

              git add artifacts/step-3-gherkin.md

              git commit -m "plan(step-3): define gherkin scenarios"

              ```

          - id: context
            status: pending
            prompt: >
              Gather step-specific context for implementation.


              ## Your Task

              Update compiler/src/validate.ts with parallel validation:


              1. In validateWorkflowPhase() function (lines 174-235)

              2. Add validation for `parallel` property (must be boolean if present)

              3. Add validation for `wait-for-parallel` property (must be boolean if present)

              4. Add warning if `parallel: true` is used on a for-each phase (not supported - should be used in step workflows only)


              Reference: context/implementation-plan.md section 4.D



              ## Shared Context

              Read: context/_shared-context.md (already has project-wide patterns)

              Read: artifacts/step-3-gherkin.md (scenarios to implement)


              ## Instructions

              Research the specific code areas this step will touch:


              1. **Related Existing Code**






















































































                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**






















































































                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**






















































































                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**






















































































                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output

              Create: context/step-3-context.md


              ```markdown

              # Step Context: step-3


              ## Task

              Update compiler/src/validate.ts with parallel validation:


              1. In validateWorkflowPhase() function (lines 174-235)

              2. Add validation for `parallel` property (must be boolean if present)

              3. Add validation for `wait-for-parallel` property (must be boolean if present)

              4. Add warning if `parallel: true` is used on a for-each phase (not supported - should be used in step workflows only)


              Reference: context/implementation-plan.md section 4.D



              ## Related Code Patterns


              ### Similar Implementation: [path]

              ```typescript

              // Key pattern to follow

              [relevant code snippet]

              ```


              ### Similar Implementation: [path]

              [continue as needed]


              ## Required Imports

              ### Internal

              - `[module]`: [what to import]


              ### External

              - `[package]`: [what to import]


              ## Types/Interfaces to Use

              ```typescript

              // From [source]

              interface [Name] {






















































































                [relevant fields]
              }

              ```


              ## Integration Points

              - Called by: [who will use this]

              - Calls: [what this will call]

              - Tests: [related test files]


              ## Implementation Notes

              - [Specific note 1]

              - [Specific note 2]

              ```


              ## Commit

              ```bash

              git add context/step-3-context.md

              git commit -m "context(step-3): gather implementation context"

              ```

          - id: execute
            status: pending
            prompt: >
              Implement the step following gherkin scenarios and context.


              ## Your Task

              Update compiler/src/validate.ts with parallel validation:


              1. In validateWorkflowPhase() function (lines 174-235)

              2. Add validation for `parallel` property (must be boolean if present)

              3. Add validation for `wait-for-parallel` property (must be boolean if present)

              4. Add warning if `parallel: true` is used on a for-each phase (not supported - should be used in step workflows only)


              Reference: context/implementation-plan.md section 4.D



              ## MUST READ BEFORE IMPLEMENTING

              Read these files in order:

              1. context/_shared-context.md (project patterns, conventions)

              2. context/sprint-plan.md (how this fits in sprint)

              3. artifacts/step-3-gherkin.md (scenarios to satisfy)

              4. context/step-3-context.md (specific patterns, imports)


              ## Implementation Rules


              ### Follow the Gherkin

              Your implementation MUST satisfy ALL gherkin scenarios.

              Each scenario has a verification command - mentally run it to check your work.


              ### Follow the Context

              - Use patterns from similar implementations

              - Import from specified modules

              - Implement required interfaces

              - Follow naming conventions


              ### Code Quality

              - Keep code simple and focused

              - Follow existing patterns exactly

              - No over-engineering or extra abstractions

              - Only implement what's needed for the scenarios


              ### Commits

              Make atomic commits for logical units:

              ```bash

              # After each logical piece

              git add [files]

              git commit -m "[type](step-3): [description]"

              ```


              Types: feat, fix, refactor, test, docs


              ## Implementation Checklist

              Before marking complete, verify:

              - [ ] All files from gherkin scenarios exist

              - [ ] Code follows patterns from context

              - [ ] Imports are correct

              - [ ] No TypeScript errors (run typecheck mentally)

              - [ ] Each scenario's verification should pass


              ## If Blocked

              If you encounter an issue that prevents completion:

              - Document the blocker clearly

              - Set status to needs-human

              - Do NOT leave partial/broken implementation

          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-3-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-3-qa-report.md

              ```markdown
              # QA Report: step-3

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-3-qa-report.md
                 git commit -m "qa(step-3): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-3.\n\n## Context\nRead: artifacts/step-3-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-3-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-3-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-3 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: >
              Final integration verification for the step.


              ## Your Task

              Update compiler/src/validate.ts with parallel validation:


              1. In validateWorkflowPhase() function (lines 174-235)

              2. Add validation for `parallel` property (must be boolean if present)

              3. Add validation for `wait-for-parallel` property (must be boolean if present)

              4. Add warning if `parallel: true` is used on a for-each phase (not supported - should be used in step workflows only)


              Reference: context/implementation-plan.md section 4.D



              ## Context

              Read: context/_shared-context.md (build commands)

              Read: artifacts/step-3-qa-report.md (should show PASS)


              ## Step 1: Build Verification

              Run the project build to ensure this step integrates:

              ```bash

              # Use commands from _shared-context.md, typically:

              npm run build

              npm run typecheck

              ```


              ## Step 2: Integration Check

              Verify this step works with the rest of the sprint:

              - Check imports resolve correctly

              - Verify no circular dependencies

              - Ensure types are compatible


              ## Step 3: Smoke Test

              If possible, manually verify the functionality:

              - Run the code path that uses this step's output

              - Check expected behavior matches gherkin scenarios


              ## Step 4: Final Commit

              If all verification passes:

              ```bash

              git add -A

              git status  # Check for any uncommitted changes

              # Only commit if there are changes

              git diff --cached --quiet || git commit -m "verify(step-3): integration verified"

              ```


              ## Outcome

              - If integration passes: Mark step as complete

              - If integration fails: Document the issue and set status to needs-human


              ## Important

              This is the final gate before moving to the next step.

              The step's gherkin scenarios already passed in QA.

              This phase ensures the step works in the broader context.

      - id: step-4
        prompt: |
          Create new script: scripts/build-parallel-prompt.sh

          This script builds the prompt for parallel tasks spawned in background.

          Parameters:
          - SPRINT_DIR, PHASE_IDX, STEP_IDX, SUB_IDX, TASK_ID

          Output format:
          ```
          # Parallel Task Execution
          Task ID: $TASK_ID

          ## Context
          Step: [step prompt from PROGRESS.yaml]

          ## Your Task: [sub-phase-id]
          [sub-phase prompt from PROGRESS.yaml]

          ## Instructions
          1. Execute this task independently
          2. This runs in background - main workflow continues without waiting
          3. Focus on completing this specific task
          4. Commit changes when done

          Note: Do NOT modify PROGRESS.yaml - the main loop tracks completion via process exit.
          ```

          Reference: context/implementation-plan.md section 4.F
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Create new script: scripts/build-parallel-prompt.sh

              This script builds the prompt for parallel tasks spawned in background.

              Parameters:
              - SPRINT_DIR, PHASE_IDX, STEP_IDX, SUB_IDX, TASK_ID

              Output format:
              ```
              # Parallel Task Execution
              Task ID: $TASK_ID

              ## Context
              Step: [step prompt from PROGRESS.yaml]

              ## Your Task: [sub-phase-id]
              [sub-phase prompt from PROGRESS.yaml]

              ## Instructions
              1. Execute this task independently
              2. This runs in background - main workflow continues without waiting
              3. Focus on completing this specific task
              4. Commit changes when done

              Note: Do NOT modify PROGRESS.yaml - the main loop tracks completion via process exit.
              ```

              Reference: context/implementation-plan.md section 4.F


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-4-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-4

              ## Step Task
              Create new script: scripts/build-parallel-prompt.sh

              This script builds the prompt for parallel tasks spawned in background.

              Parameters:
              - SPRINT_DIR, PHASE_IDX, STEP_IDX, SUB_IDX, TASK_ID

              Output format:
              ```
              # Parallel Task Execution
              Task ID: $TASK_ID

              ## Context
              Step: [step prompt from PROGRESS.yaml]

              ## Your Task: [sub-phase-id]
              [sub-phase prompt from PROGRESS.yaml]

              ## Instructions
              1. Execute this task independently
              2. This runs in background - main workflow continues without waiting
              3. Focus on completing this specific task
              4. Commit changes when done

              Note: Do NOT modify PROGRESS.yaml - the main loop tracks completion via process exit.
              ```

              Reference: context/implementation-plan.md section 4.F


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-4-gherkin.md
              git commit -m "plan(step-4): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Create new script: scripts/build-parallel-prompt.sh

              This script builds the prompt for parallel tasks spawned in background.

              Parameters:
              - SPRINT_DIR, PHASE_IDX, STEP_IDX, SUB_IDX, TASK_ID

              Output format:
              ```
              # Parallel Task Execution
              Task ID: $TASK_ID

              ## Context
              Step: [step prompt from PROGRESS.yaml]

              ## Your Task: [sub-phase-id]
              [sub-phase prompt from PROGRESS.yaml]

              ## Instructions
              1. Execute this task independently
              2. This runs in background - main workflow continues without waiting
              3. Focus on completing this specific task
              4. Commit changes when done

              Note: Do NOT modify PROGRESS.yaml - the main loop tracks completion via process exit.
              ```

              Reference: context/implementation-plan.md section 4.F


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-4-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-4-context.md

              ```markdown
              # Step Context: step-4

              ## Task
              Create new script: scripts/build-parallel-prompt.sh

              This script builds the prompt for parallel tasks spawned in background.

              Parameters:
              - SPRINT_DIR, PHASE_IDX, STEP_IDX, SUB_IDX, TASK_ID

              Output format:
              ```
              # Parallel Task Execution
              Task ID: $TASK_ID

              ## Context
              Step: [step prompt from PROGRESS.yaml]

              ## Your Task: [sub-phase-id]
              [sub-phase prompt from PROGRESS.yaml]

              ## Instructions
              1. Execute this task independently
              2. This runs in background - main workflow continues without waiting
              3. Focus on completing this specific task
              4. Commit changes when done

              Note: Do NOT modify PROGRESS.yaml - the main loop tracks completion via process exit.
              ```

              Reference: context/implementation-plan.md section 4.F


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-4-context.md
              git commit -m "context(step-4): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Create new script: scripts/build-parallel-prompt.sh

              This script builds the prompt for parallel tasks spawned in background.

              Parameters:
              - SPRINT_DIR, PHASE_IDX, STEP_IDX, SUB_IDX, TASK_ID

              Output format:
              ```
              # Parallel Task Execution
              Task ID: $TASK_ID

              ## Context
              Step: [step prompt from PROGRESS.yaml]

              ## Your Task: [sub-phase-id]
              [sub-phase prompt from PROGRESS.yaml]

              ## Instructions
              1. Execute this task independently
              2. This runs in background - main workflow continues without waiting
              3. Focus on completing this specific task
              4. Commit changes when done

              Note: Do NOT modify PROGRESS.yaml - the main loop tracks completion via process exit.
              ```

              Reference: context/implementation-plan.md section 4.F


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-4-gherkin.md (scenarios to satisfy)
              4. context/step-4-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-4): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-4-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-4-qa-report.md

              ```markdown
              # QA Report: step-4

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-4-qa-report.md
                 git commit -m "qa(step-4): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-4.\n\n## Context\nRead: artifacts/step-4-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-4-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-4-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-4 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Create new script: scripts/build-parallel-prompt.sh

              This script builds the prompt for parallel tasks spawned in background.

              Parameters:
              - SPRINT_DIR, PHASE_IDX, STEP_IDX, SUB_IDX, TASK_ID

              Output format:
              ```
              # Parallel Task Execution
              Task ID: $TASK_ID

              ## Context
              Step: [step prompt from PROGRESS.yaml]

              ## Your Task: [sub-phase-id]
              [sub-phase prompt from PROGRESS.yaml]

              ## Instructions
              1. Execute this task independently
              2. This runs in background - main workflow continues without waiting
              3. Focus on completing this specific task
              4. Commit changes when done

              Note: Do NOT modify PROGRESS.yaml - the main loop tracks completion via process exit.
              ```

              Reference: context/implementation-plan.md section 4.F


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-4-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-4): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-5
        prompt: |
          Update scripts/sprint-loop.sh with parallel task management:

          Add new helper functions:
          1. is_parallel_subphase() - Check if current sub-phase has parallel flag
          2. spawn_parallel_task() - Spawn task in background, register in PROGRESS.yaml
          3. is_wait_for_parallel_phase() - Check if phase has wait-for-parallel flag
          4. wait_for_parallel_tasks() - Block until all parallel tasks complete
          5. update_parallel_task_statuses() - Poll and update status of running tasks

          Update main loop:
          - When processing sub-phase, check if parallel - if yes, spawn and continue
          - When processing top-level phase, check wait-for-parallel - if yes, wait
          - Call update_parallel_task_statuses() periodically

          Reference: context/implementation-plan.md section 4.E
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Update scripts/sprint-loop.sh with parallel task management:

              Add new helper functions:
              1. is_parallel_subphase() - Check if current sub-phase has parallel flag
              2. spawn_parallel_task() - Spawn task in background, register in PROGRESS.yaml
              3. is_wait_for_parallel_phase() - Check if phase has wait-for-parallel flag
              4. wait_for_parallel_tasks() - Block until all parallel tasks complete
              5. update_parallel_task_statuses() - Poll and update status of running tasks

              Update main loop:
              - When processing sub-phase, check if parallel - if yes, spawn and continue
              - When processing top-level phase, check wait-for-parallel - if yes, wait
              - Call update_parallel_task_statuses() periodically

              Reference: context/implementation-plan.md section 4.E


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-5-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-5

              ## Step Task
              Update scripts/sprint-loop.sh with parallel task management:

              Add new helper functions:
              1. is_parallel_subphase() - Check if current sub-phase has parallel flag
              2. spawn_parallel_task() - Spawn task in background, register in PROGRESS.yaml
              3. is_wait_for_parallel_phase() - Check if phase has wait-for-parallel flag
              4. wait_for_parallel_tasks() - Block until all parallel tasks complete
              5. update_parallel_task_statuses() - Poll and update status of running tasks

              Update main loop:
              - When processing sub-phase, check if parallel - if yes, spawn and continue
              - When processing top-level phase, check wait-for-parallel - if yes, wait
              - Call update_parallel_task_statuses() periodically

              Reference: context/implementation-plan.md section 4.E


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-5-gherkin.md
              git commit -m "plan(step-5): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Update scripts/sprint-loop.sh with parallel task management:

              Add new helper functions:
              1. is_parallel_subphase() - Check if current sub-phase has parallel flag
              2. spawn_parallel_task() - Spawn task in background, register in PROGRESS.yaml
              3. is_wait_for_parallel_phase() - Check if phase has wait-for-parallel flag
              4. wait_for_parallel_tasks() - Block until all parallel tasks complete
              5. update_parallel_task_statuses() - Poll and update status of running tasks

              Update main loop:
              - When processing sub-phase, check if parallel - if yes, spawn and continue
              - When processing top-level phase, check wait-for-parallel - if yes, wait
              - Call update_parallel_task_statuses() periodically

              Reference: context/implementation-plan.md section 4.E


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-5-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-5-context.md

              ```markdown
              # Step Context: step-5

              ## Task
              Update scripts/sprint-loop.sh with parallel task management:

              Add new helper functions:
              1. is_parallel_subphase() - Check if current sub-phase has parallel flag
              2. spawn_parallel_task() - Spawn task in background, register in PROGRESS.yaml
              3. is_wait_for_parallel_phase() - Check if phase has wait-for-parallel flag
              4. wait_for_parallel_tasks() - Block until all parallel tasks complete
              5. update_parallel_task_statuses() - Poll and update status of running tasks

              Update main loop:
              - When processing sub-phase, check if parallel - if yes, spawn and continue
              - When processing top-level phase, check wait-for-parallel - if yes, wait
              - Call update_parallel_task_statuses() periodically

              Reference: context/implementation-plan.md section 4.E


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-5-context.md
              git commit -m "context(step-5): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Update scripts/sprint-loop.sh with parallel task management:

              Add new helper functions:
              1. is_parallel_subphase() - Check if current sub-phase has parallel flag
              2. spawn_parallel_task() - Spawn task in background, register in PROGRESS.yaml
              3. is_wait_for_parallel_phase() - Check if phase has wait-for-parallel flag
              4. wait_for_parallel_tasks() - Block until all parallel tasks complete
              5. update_parallel_task_statuses() - Poll and update status of running tasks

              Update main loop:
              - When processing sub-phase, check if parallel - if yes, spawn and continue
              - When processing top-level phase, check wait-for-parallel - if yes, wait
              - Call update_parallel_task_statuses() periodically

              Reference: context/implementation-plan.md section 4.E


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-5-gherkin.md (scenarios to satisfy)
              4. context/step-5-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-5): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-5-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-5-qa-report.md

              ```markdown
              # QA Report: step-5

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-5-qa-report.md
                 git commit -m "qa(step-5): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-5.\n\n## Context\nRead: artifacts/step-5-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-5-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-5-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-5 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Update scripts/sprint-loop.sh with parallel task management:

              Add new helper functions:
              1. is_parallel_subphase() - Check if current sub-phase has parallel flag
              2. spawn_parallel_task() - Spawn task in background, register in PROGRESS.yaml
              3. is_wait_for_parallel_phase() - Check if phase has wait-for-parallel flag
              4. wait_for_parallel_tasks() - Block until all parallel tasks complete
              5. update_parallel_task_statuses() - Poll and update status of running tasks

              Update main loop:
              - When processing sub-phase, check if parallel - if yes, spawn and continue
              - When processing top-level phase, check wait-for-parallel - if yes, wait
              - Call update_parallel_task_statuses() periodically

              Reference: context/implementation-plan.md section 4.E


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-5-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-5): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-6
        prompt: |
          Update scripts/build-sprint-prompt.sh to skip parallel sub-phases:

          When building prompts for the main loop, skip sub-phases that:
          - Have status 'spawned' (already running in background)
          - Have parallel-task-id set (reference to parallel-tasks entry)

          This prevents re-executing tasks that are already running in parallel.

          Reference: context/implementation-plan.md section 5 (Files to Modify table)
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Update scripts/build-sprint-prompt.sh to skip parallel sub-phases:

              When building prompts for the main loop, skip sub-phases that:
              - Have status 'spawned' (already running in background)
              - Have parallel-task-id set (reference to parallel-tasks entry)

              This prevents re-executing tasks that are already running in parallel.

              Reference: context/implementation-plan.md section 5 (Files to Modify table)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-6-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-6

              ## Step Task
              Update scripts/build-sprint-prompt.sh to skip parallel sub-phases:

              When building prompts for the main loop, skip sub-phases that:
              - Have status 'spawned' (already running in background)
              - Have parallel-task-id set (reference to parallel-tasks entry)

              This prevents re-executing tasks that are already running in parallel.

              Reference: context/implementation-plan.md section 5 (Files to Modify table)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-6-gherkin.md
              git commit -m "plan(step-6): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Update scripts/build-sprint-prompt.sh to skip parallel sub-phases:

              When building prompts for the main loop, skip sub-phases that:
              - Have status 'spawned' (already running in background)
              - Have parallel-task-id set (reference to parallel-tasks entry)

              This prevents re-executing tasks that are already running in parallel.

              Reference: context/implementation-plan.md section 5 (Files to Modify table)


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-6-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-6-context.md

              ```markdown
              # Step Context: step-6

              ## Task
              Update scripts/build-sprint-prompt.sh to skip parallel sub-phases:

              When building prompts for the main loop, skip sub-phases that:
              - Have status 'spawned' (already running in background)
              - Have parallel-task-id set (reference to parallel-tasks entry)

              This prevents re-executing tasks that are already running in parallel.

              Reference: context/implementation-plan.md section 5 (Files to Modify table)


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-6-context.md
              git commit -m "context(step-6): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Update scripts/build-sprint-prompt.sh to skip parallel sub-phases:

              When building prompts for the main loop, skip sub-phases that:
              - Have status 'spawned' (already running in background)
              - Have parallel-task-id set (reference to parallel-tasks entry)

              This prevents re-executing tasks that are already running in parallel.

              Reference: context/implementation-plan.md section 5 (Files to Modify table)


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-6-gherkin.md (scenarios to satisfy)
              4. context/step-6-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-6): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-6-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-6-qa-report.md

              ```markdown
              # QA Report: step-6

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-6-qa-report.md
                 git commit -m "qa(step-6): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-6.\n\n## Context\nRead: artifacts/step-6-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-6-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-6-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-6 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Update scripts/build-sprint-prompt.sh to skip parallel sub-phases:

              When building prompts for the main loop, skip sub-phases that:
              - Have status 'spawned' (already running in background)
              - Have parallel-task-id set (reference to parallel-tasks entry)

              This prevents re-executing tasks that are already running in parallel.

              Reference: context/implementation-plan.md section 5 (Files to Modify table)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-6-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-6): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-7
        prompt: |
          Update commands/sprint-status.md to display parallel task status:

          Add new section after step/phase display:
          ```
          Parallel Tasks:
          [~] step-0-update-docs-1705123456 (running, 2m elapsed)
              Step: Implement user authentication
              Phase: update-docs
              PID: 12345 | Log: logs/step-0-update-docs-1705123456.log
          [x] step-1-update-docs-1705123789 (completed, 1m 23s)
          ```

          Show:
          - Task ID, status, elapsed time
          - Which step/phase spawned it
          - PID and log file location

          Reference: context/implementation-plan.md section 4.G
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Update commands/sprint-status.md to display parallel task status:

              Add new section after step/phase display:
              ```
              Parallel Tasks:
              [~] step-0-update-docs-1705123456 (running, 2m elapsed)
                  Step: Implement user authentication
                  Phase: update-docs
                  PID: 12345 | Log: logs/step-0-update-docs-1705123456.log
              [x] step-1-update-docs-1705123789 (completed, 1m 23s)
              ```

              Show:
              - Task ID, status, elapsed time
              - Which step/phase spawned it
              - PID and log file location

              Reference: context/implementation-plan.md section 4.G


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-7-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-7

              ## Step Task
              Update commands/sprint-status.md to display parallel task status:

              Add new section after step/phase display:
              ```
              Parallel Tasks:
              [~] step-0-update-docs-1705123456 (running, 2m elapsed)
                  Step: Implement user authentication
                  Phase: update-docs
                  PID: 12345 | Log: logs/step-0-update-docs-1705123456.log
              [x] step-1-update-docs-1705123789 (completed, 1m 23s)
              ```

              Show:
              - Task ID, status, elapsed time
              - Which step/phase spawned it
              - PID and log file location

              Reference: context/implementation-plan.md section 4.G


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-7-gherkin.md
              git commit -m "plan(step-7): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Update commands/sprint-status.md to display parallel task status:

              Add new section after step/phase display:
              ```
              Parallel Tasks:
              [~] step-0-update-docs-1705123456 (running, 2m elapsed)
                  Step: Implement user authentication
                  Phase: update-docs
                  PID: 12345 | Log: logs/step-0-update-docs-1705123456.log
              [x] step-1-update-docs-1705123789 (completed, 1m 23s)
              ```

              Show:
              - Task ID, status, elapsed time
              - Which step/phase spawned it
              - PID and log file location

              Reference: context/implementation-plan.md section 4.G


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-7-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-7-context.md

              ```markdown
              # Step Context: step-7

              ## Task
              Update commands/sprint-status.md to display parallel task status:

              Add new section after step/phase display:
              ```
              Parallel Tasks:
              [~] step-0-update-docs-1705123456 (running, 2m elapsed)
                  Step: Implement user authentication
                  Phase: update-docs
                  PID: 12345 | Log: logs/step-0-update-docs-1705123456.log
              [x] step-1-update-docs-1705123789 (completed, 1m 23s)
              ```

              Show:
              - Task ID, status, elapsed time
              - Which step/phase spawned it
              - PID and log file location

              Reference: context/implementation-plan.md section 4.G


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-7-context.md
              git commit -m "context(step-7): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Update commands/sprint-status.md to display parallel task status:

              Add new section after step/phase display:
              ```
              Parallel Tasks:
              [~] step-0-update-docs-1705123456 (running, 2m elapsed)
                  Step: Implement user authentication
                  Phase: update-docs
                  PID: 12345 | Log: logs/step-0-update-docs-1705123456.log
              [x] step-1-update-docs-1705123789 (completed, 1m 23s)
              ```

              Show:
              - Task ID, status, elapsed time
              - Which step/phase spawned it
              - PID and log file location

              Reference: context/implementation-plan.md section 4.G


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-7-gherkin.md (scenarios to satisfy)
              4. context/step-7-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-7): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-7-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-7-qa-report.md

              ```markdown
              # QA Report: step-7

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-7-qa-report.md
                 git commit -m "qa(step-7): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-7.\n\n## Context\nRead: artifacts/step-7-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-7-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-7-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-7 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Update commands/sprint-status.md to display parallel task status:

              Add new section after step/phase display:
              ```
              Parallel Tasks:
              [~] step-0-update-docs-1705123456 (running, 2m elapsed)
                  Step: Implement user authentication
                  Phase: update-docs
                  PID: 12345 | Log: logs/step-0-update-docs-1705123456.log
              [x] step-1-update-docs-1705123789 (completed, 1m 23s)
              ```

              Show:
              - Task ID, status, elapsed time
              - Which step/phase spawned it
              - PID and log file location

              Reference: context/implementation-plan.md section 4.G


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-7-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-7): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-8
        prompt: |
          Update skills/creating-workflows/references/workflow-schema.md:

          Document new properties:
          1. `parallel?: boolean` on WorkflowPhase
             - Description: Run this phase in background, don't block next step
             - Use case: Documentation updates, learning loops
             - Note: Only works in step workflows, not on for-each phases

          2. `wait-for-parallel?: boolean` on top-level WorkflowPhase
             - Description: Wait for all parallel tasks to complete before continuing
             - Use case: Sync points before QA or deployment phases

          Add usage examples from the plan.

          Reference: context/implementation-plan.md section 5
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Update skills/creating-workflows/references/workflow-schema.md:

              Document new properties:
              1. `parallel?: boolean` on WorkflowPhase
                 - Description: Run this phase in background, don't block next step
                 - Use case: Documentation updates, learning loops
                 - Note: Only works in step workflows, not on for-each phases

              2. `wait-for-parallel?: boolean` on top-level WorkflowPhase
                 - Description: Wait for all parallel tasks to complete before continuing
                 - Use case: Sync points before QA or deployment phases

              Add usage examples from the plan.

              Reference: context/implementation-plan.md section 5


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-8-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-8

              ## Step Task
              Update skills/creating-workflows/references/workflow-schema.md:

              Document new properties:
              1. `parallel?: boolean` on WorkflowPhase
                 - Description: Run this phase in background, don't block next step
                 - Use case: Documentation updates, learning loops
                 - Note: Only works in step workflows, not on for-each phases

              2. `wait-for-parallel?: boolean` on top-level WorkflowPhase
                 - Description: Wait for all parallel tasks to complete before continuing
                 - Use case: Sync points before QA or deployment phases

              Add usage examples from the plan.

              Reference: context/implementation-plan.md section 5


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-8-gherkin.md
              git commit -m "plan(step-8): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Update skills/creating-workflows/references/workflow-schema.md:

              Document new properties:
              1. `parallel?: boolean` on WorkflowPhase
                 - Description: Run this phase in background, don't block next step
                 - Use case: Documentation updates, learning loops
                 - Note: Only works in step workflows, not on for-each phases

              2. `wait-for-parallel?: boolean` on top-level WorkflowPhase
                 - Description: Wait for all parallel tasks to complete before continuing
                 - Use case: Sync points before QA or deployment phases

              Add usage examples from the plan.

              Reference: context/implementation-plan.md section 5


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-8-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-8-context.md

              ```markdown
              # Step Context: step-8

              ## Task
              Update skills/creating-workflows/references/workflow-schema.md:

              Document new properties:
              1. `parallel?: boolean` on WorkflowPhase
                 - Description: Run this phase in background, don't block next step
                 - Use case: Documentation updates, learning loops
                 - Note: Only works in step workflows, not on for-each phases

              2. `wait-for-parallel?: boolean` on top-level WorkflowPhase
                 - Description: Wait for all parallel tasks to complete before continuing
                 - Use case: Sync points before QA or deployment phases

              Add usage examples from the plan.

              Reference: context/implementation-plan.md section 5


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-8-context.md
              git commit -m "context(step-8): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Update skills/creating-workflows/references/workflow-schema.md:

              Document new properties:
              1. `parallel?: boolean` on WorkflowPhase
                 - Description: Run this phase in background, don't block next step
                 - Use case: Documentation updates, learning loops
                 - Note: Only works in step workflows, not on for-each phases

              2. `wait-for-parallel?: boolean` on top-level WorkflowPhase
                 - Description: Wait for all parallel tasks to complete before continuing
                 - Use case: Sync points before QA or deployment phases

              Add usage examples from the plan.

              Reference: context/implementation-plan.md section 5


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-8-gherkin.md (scenarios to satisfy)
              4. context/step-8-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-8): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-8-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-8-qa-report.md

              ```markdown
              # QA Report: step-8

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-8-qa-report.md
                 git commit -m "qa(step-8): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-8.\n\n## Context\nRead: artifacts/step-8-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-8-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-8-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-8 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Update skills/creating-workflows/references/workflow-schema.md:

              Document new properties:
              1. `parallel?: boolean` on WorkflowPhase
                 - Description: Run this phase in background, don't block next step
                 - Use case: Documentation updates, learning loops
                 - Note: Only works in step workflows, not on for-each phases

              2. `wait-for-parallel?: boolean` on top-level WorkflowPhase
                 - Description: Wait for all parallel tasks to complete before continuing
                 - Use case: Sync points before QA or deployment phases

              Add usage examples from the plan.

              Reference: context/implementation-plan.md section 5


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-8-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-8): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-9
        prompt: |
          Create integration test for parallel execution:

          1. Create test workflow with parallel sub-phase in step workflow
          2. Create test sprint with 2-3 steps using this workflow
          3. Run compilation and verify:
             - parallel-tasks array is initialized
             - parallel flag propagates to compiled sub-phases
             - wait-for-parallel flag appears on sync phases

          4. Test execution (manual or automated):
             - Verify parallel tasks spawn as background processes
             - Verify main loop advances without waiting
             - Verify wait-for-parallel blocks until completion
             - Check parallel task logs are created
             - Test failure handling (kill a parallel task, check status)

          Reference: context/implementation-plan.md section 8 (Verification Plan)
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Create integration test for parallel execution:

              1. Create test workflow with parallel sub-phase in step workflow
              2. Create test sprint with 2-3 steps using this workflow
              3. Run compilation and verify:
                 - parallel-tasks array is initialized
                 - parallel flag propagates to compiled sub-phases
                 - wait-for-parallel flag appears on sync phases

              4. Test execution (manual or automated):
                 - Verify parallel tasks spawn as background processes
                 - Verify main loop advances without waiting
                 - Verify wait-for-parallel blocks until completion
                 - Check parallel task logs are created
                 - Test failure handling (kill a parallel task, check status)

              Reference: context/implementation-plan.md section 8 (Verification Plan)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-9-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-9

              ## Step Task
              Create integration test for parallel execution:

              1. Create test workflow with parallel sub-phase in step workflow
              2. Create test sprint with 2-3 steps using this workflow
              3. Run compilation and verify:
                 - parallel-tasks array is initialized
                 - parallel flag propagates to compiled sub-phases
                 - wait-for-parallel flag appears on sync phases

              4. Test execution (manual or automated):
                 - Verify parallel tasks spawn as background processes
                 - Verify main loop advances without waiting
                 - Verify wait-for-parallel blocks until completion
                 - Check parallel task logs are created
                 - Test failure handling (kill a parallel task, check status)

              Reference: context/implementation-plan.md section 8 (Verification Plan)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-9-gherkin.md
              git commit -m "plan(step-9): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Create integration test for parallel execution:

              1. Create test workflow with parallel sub-phase in step workflow
              2. Create test sprint with 2-3 steps using this workflow
              3. Run compilation and verify:
                 - parallel-tasks array is initialized
                 - parallel flag propagates to compiled sub-phases
                 - wait-for-parallel flag appears on sync phases

              4. Test execution (manual or automated):
                 - Verify parallel tasks spawn as background processes
                 - Verify main loop advances without waiting
                 - Verify wait-for-parallel blocks until completion
                 - Check parallel task logs are created
                 - Test failure handling (kill a parallel task, check status)

              Reference: context/implementation-plan.md section 8 (Verification Plan)


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-9-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-9-context.md

              ```markdown
              # Step Context: step-9

              ## Task
              Create integration test for parallel execution:

              1. Create test workflow with parallel sub-phase in step workflow
              2. Create test sprint with 2-3 steps using this workflow
              3. Run compilation and verify:
                 - parallel-tasks array is initialized
                 - parallel flag propagates to compiled sub-phases
                 - wait-for-parallel flag appears on sync phases

              4. Test execution (manual or automated):
                 - Verify parallel tasks spawn as background processes
                 - Verify main loop advances without waiting
                 - Verify wait-for-parallel blocks until completion
                 - Check parallel task logs are created
                 - Test failure handling (kill a parallel task, check status)

              Reference: context/implementation-plan.md section 8 (Verification Plan)


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-9-context.md
              git commit -m "context(step-9): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Create integration test for parallel execution:

              1. Create test workflow with parallel sub-phase in step workflow
              2. Create test sprint with 2-3 steps using this workflow
              3. Run compilation and verify:
                 - parallel-tasks array is initialized
                 - parallel flag propagates to compiled sub-phases
                 - wait-for-parallel flag appears on sync phases

              4. Test execution (manual or automated):
                 - Verify parallel tasks spawn as background processes
                 - Verify main loop advances without waiting
                 - Verify wait-for-parallel blocks until completion
                 - Check parallel task logs are created
                 - Test failure handling (kill a parallel task, check status)

              Reference: context/implementation-plan.md section 8 (Verification Plan)


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-9-gherkin.md (scenarios to satisfy)
              4. context/step-9-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-9): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-9-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-9-qa-report.md

              ```markdown
              # QA Report: step-9

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-9-qa-report.md
                 git commit -m "qa(step-9): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-9.\n\n## Context\nRead: artifacts/step-9-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-9-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-9-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-9 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Create integration test for parallel execution:

              1. Create test workflow with parallel sub-phase in step workflow
              2. Create test sprint with 2-3 steps using this workflow
              3. Run compilation and verify:
                 - parallel-tasks array is initialized
                 - parallel flag propagates to compiled sub-phases
                 - wait-for-parallel flag appears on sync phases

              4. Test execution (manual or automated):
                 - Verify parallel tasks spawn as background processes
                 - Verify main loop advances without waiting
                 - Verify wait-for-parallel blocks until completion
                 - Check parallel task logs are created
                 - Test failure handling (kill a parallel task, check status)

              Reference: context/implementation-plan.md section 8 (Verification Plan)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-9-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-9): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
  - id: final-qa
    status: pending
    prompt: |
      Comprehensive Quality Assurance for the entire sprint.

      ## Context
      Read: context/_shared-context.md for build/test commands
      Read: context/sprint-plan.md for success criteria

      ## Step 1: Full Build Verification
      Run ALL build checks:
      ```bash
      # Identify commands from _shared-context.md, typically:
      npm run build
      npm run typecheck
      npm run lint
      ```

      Record each result in the QA report.

      ## Step 2: Complete Test Suite
      Run the full test suite:
      ```bash
      npm test
      ```

      Record test results and any failures.

      ## Step 3: Integration Verification
      Verify all steps work together:
      - Check that modules properly import each other
      - Verify no circular dependencies introduced
      - Test end-to-end flow if applicable

      ## Step 4: Regression Check
      Compare against main branch:
      ```bash
      git diff main...HEAD --stat
      ```

      Verify:
      - No unintended changes to existing functionality
      - All modified files are expected per sprint-plan.md
      - No temporary/debug code left in

      ## Step 5: Review All Step QA Reports
      Read all artifacts/step-*-qa-report.md files
      - Verify all steps show PASS status
      - Consolidate any warnings or notes

      ## Step 6: Generate Sprint QA Report
      Create: artifacts/sprint-qa-report.md

      ```markdown
      # Sprint QA Report: 2026-01-18_parallel-execution

      ## Build Verification
      | Check | Result | Output |
      |-------|--------|--------|
      | Build | PASS/FAIL | [summary] |
      | TypeCheck | PASS/FAIL | [summary] |
      | Lint | PASS/FAIL | [summary] |

      ## Test Suite
      | Metric | Value |
      |--------|-------|
      | Tests Run | [count] |
      | Passed | [count] |
      | Failed | [count] |
      | Skipped | [count] |

      ## Integration Verification
      - [ ] Modules import correctly
      - [ ] No circular dependencies
      - [ ] End-to-end flow works

      ## Step QA Summary
      | Step | Status | Notes |
      |------|--------|-------|
      | step-0 | PASS | [brief note] |
      | step-1 | PASS | [brief note] |
      ...

      ## Regression Analysis
      [Summary of changes vs main branch]

      ## Issues Found
      [List any issues, or "None"]

      ## Overall Status: PASS / FAIL
      ```

      ## Step 7: Handle Outcome

      ### If PASS:
      - Commit the QA report:
        ```bash
        git add artifacts/sprint-qa-report.md
        git commit -m "qa: sprint-level verification passed"
        ```

      ### If FAIL:
      - Document specific failures in the report
      - Set status to needs-human with details of what failed
      - The sprint cannot proceed to summary/PR until issues are resolved
  - id: summary
    status: pending
    prompt: |
      Generate sprint summary deliverable for user review.

      ## Context
      Read: context/sprint-plan.md for original goals
      Read: artifacts/sprint-qa-report.md for verification results
      Read: All artifacts/step-*-qa-report.md for step details

      ## Step 1: Collect Commit History
      ```bash
      git log main..HEAD --oneline --no-decorate
      ```

      ## Step 2: Collect File Changes
      ```bash
      git diff main..HEAD --stat
      ```

      ## Step 3: Generate Sprint Summary
      Create: artifacts/sprint-summary.md

      ```markdown
      # Sprint Summary: 2026-01-18_parallel-execution

      ## What Was Accomplished

      ### Step 0: [Step title]
      - [Key accomplishment 1]
      - [Key accomplishment 2]
      **Files**: [list of files created/modified]

      ### Step 1: [Step title]
      ...

      ## Files Changed
      | File | Change Type | Description |
      |------|-------------|-------------|
      | [path] | Created/Modified/Deleted | [brief description] |

      ## Commits Made
      | Hash | Message |
      |------|---------|
      | [short hash] | [commit message] |

      ## Test Coverage
      [Summary from QA report]

      ## Verification Status
      - Build: PASS
      - TypeCheck: PASS
      - Lint: PASS
      - Tests: [X/Y passed]
      - Integration: PASS

      ## Known Issues / Follow-ups
      [List any, or "None identified"]

      ## Sprint Statistics
      - Steps completed: [X/Y]
      - Total commits: [count]
      - Files changed: [count]
      - Lines added: [count]
      - Lines removed: [count]
      ```

      ## Step 4: Commit Summary
      ```bash
      git add artifacts/sprint-summary.md
      git commit -m "docs: add sprint summary"
      ```
  - id: pr-create
    status: pending
    prompt: "Push the sprint branch and create a pull request.\n\n## Context\nRead: artifacts/sprint-summary.md for PR body content\nRead: artifacts/sprint-qa-report.md for verification checklist\n\n## Step 1: Ensure All Changes Committed\n```bash\ngit status\n```\nIf there are uncommitted changes, commit them appropriately.\n\n## Step 2: Push Branch\n```bash\ngit push -u origin sprint/2026-01-18_parallel-execution\n```\n\n## Step 3: Create Pull Request\nUse the sprint summary to create a well-structured PR:\n\n```bash\ngh pr create \\\n  --title \"Sprint: 2026-01-18_parallel-execution\" \\\n  --body \"$(cat <<'EOF'\n## Summary\n[Extract key points from sprint-summary.md]\n\n## Changes\n[List of major changes from summary]\n\n## Verification Checklist\n- [x] Build passes\n- [x] TypeCheck passes\n- [x] Lint passes\n- [x] Tests pass\n- [x] Integration verified\n- [x] No regressions\n\n## Test Results\n[Extract from sprint-qa-report.md]\n\n## Files Changed\n[File list from summary]\n\n---\nFull details in `artifacts/sprint-summary.md`\n\n\U0001F916 Generated with Sprint Workflow\nEOF\n)\"\n```\n\n## Step 4: Output PR URL\nCapture and display the PR URL:\n```bash\ngh pr view --json url -q '.url'\n```\n\n## Output\n- Branch pushed to remote\n- Pull request created\n- PR URL displayed for user\n"
current:
  phase: 1
  step: 2
  sub-phase: 0
stats:
  started-at: "2026-01-17T23:57:42Z"
  total-phases: 55
  completed-phases: 0
  total-steps: 10
  completed-steps: 0
  max-iterations: 100
  current-iteration: 11
