# Sprint: Ralph Mode Implementation
# Hybrid Workflow - Autonomous Claude Loop mit deterministischen per-iteration Hooks

workflow: gherkin-verified-execution

steps:
  # ==========================================================================
  # Step 0: Compiler-Erweiterungen für Ralph Mode
  # ==========================================================================
  - id: step-0
    prompt: |
      Erweitere das Compiler-System für Ralph Mode Support.

      ## Kontext
      Lies den Implementierungsplan: context/implementation-plan.md

      ## Aufgaben

      ### 1. Types erweitern (plugins/m42-sprint/compiler/src/types.ts)

      Füge folgende Interfaces hinzu:

      ```typescript
      interface PerIterationHook {
        id: string;
        workflow?: string;       // z.B. "m42-signs:learning-extraction"
        prompt?: string;         // Inline prompt Alternative
        parallel: boolean;
        enabled: boolean;
      }
      ```

      Erweitere das Workflow Interface:
      ```typescript
      interface Workflow {
        // ... bestehende Felder
        mode?: 'standard' | 'ralph';
        "goal-prompt"?: string;
        "reflection-prompt"?: string;
        "per-iteration-hooks"?: PerIterationHook[];
      }
      ```

      Erweitere Sprint Interface um `goal` Feld für Ralph Mode.

      ### 2. Compile.ts erweitern (plugins/m42-sprint/compiler/src/compile.ts)

      Füge Ralph Mode Detection und PROGRESS.yaml Generierung hinzu:

      - Prüfe ob Workflow `mode: ralph` hat
      - Wenn ja: Generiere PROGRESS.yaml mit Ralph-spezifischer Struktur:
        - `mode: ralph`
        - `goal:` aus SPRINT.yaml
        - `dynamic-steps: []` (initial leer)
        - `hook-tasks: []`
        - `per-iteration-hooks:` (merged aus Workflow + SPRINT.yaml)
        - `ralph:` Config Block
      - Merge per-iteration-hooks aus Workflow-Definition mit SPRINT.yaml Overrides

      ### 3. Validierung

      Füge Validierungsregeln hinzu:
      - Ralph Mode Workflows brauchen KEIN `phases:` Array
      - SPRINT.yaml mit Ralph Workflow MUSS `goal:` haben
      - Per-iteration hooks müssen entweder `workflow:` oder `prompt:` haben

      ## Gherkin Scenarios

      ```gherkin
      Scenario: Ralph Mode PROGRESS.yaml Generierung
        Given eine SPRINT.yaml mit workflow: ralph und goal: "Test goal"
        And eine ralph.yaml Workflow-Definition mit mode: ralph
        When der Compiler ausgeführt wird
        Then enthält PROGRESS.yaml mode: ralph
        And enthält PROGRESS.yaml das goal Feld
        And enthält PROGRESS.yaml leere dynamic-steps Array
        And enthält PROGRESS.yaml per-iteration-hooks aus Workflow

      Scenario: Per-iteration Hook Merging
        Given ralph.yaml mit per-iteration-hooks: learning (enabled: false)
        And SPRINT.yaml mit per-iteration-hooks: learning: enabled: true
        When der Compiler merged
        Then ist learning hook in PROGRESS.yaml enabled: true

      Scenario: Validierung ohne goal
        Given eine SPRINT.yaml mit workflow: ralph aber OHNE goal
        When der Compiler ausgeführt wird
        Then gibt es einen Validierungsfehler "Ralph mode requires goal field"
      ```

      ## Verifikation
      ```bash
      # Build compiler
      cd plugins/m42-sprint/compiler && npm run build

      # TypeScript prüfen
      npm run typecheck
      ```

  # ==========================================================================
  # Step 1: Ralph Loop in sprint-loop.sh implementieren
  # ==========================================================================
  - id: step-1
    prompt: |
      Implementiere die Ralph Loop Funktion in sprint-loop.sh.

      ## Kontext
      Lies den Implementierungsplan: context/implementation-plan.md
      Lies die bestehende sprint-loop.sh: plugins/m42-sprint/scripts/sprint-loop.sh

      ## Aufgaben

      ### 1. Mode Detection am Loop-Start

      Am Anfang des Scripts nach PROGRESS.yaml Validierung:
      ```bash
      MODE=$(yq -r '.mode // "standard"' "$PROGRESS_FILE")

      if [[ "$MODE" == "ralph" ]]; then
        run_ralph_loop
      else
        # Bestehende Logik
        run_standard_loop
      fi
      ```

      Refaktoriere bestehende Loop-Logik in `run_standard_loop()` Funktion.

      ### 2. run_ralph_loop() Funktion

      Implementiere die Endlosschleife:
      - Kein MAX_ITERATIONS Limit (echte Endlosschleife)
      - Bestimme Modus basierend auf pending Steps:
        - Keine pending Steps + idle_count < threshold → "planning"
        - Keine pending Steps + idle_count >= threshold → "reflecting"
        - Pending Steps vorhanden → "executing"
      - Baue Prompt via build-ralph-prompt.sh
      - Spawn per-iteration hooks (wenn enabled)
      - Führe Claude aus mit Transcript-Speicherung
      - Prüfe auf RALPH_COMPLETE: im Output
      - Wenn gefunden: record_ralph_completion() und exit

      ### 3. spawn_per_iteration_hooks() Funktion

      Iteriere über enabled hooks aus PROGRESS.yaml:
      - Registriere Task in hook-tasks[]
      - Wenn workflow: → führe als /workflow-name aus
      - Wenn prompt: → führe als direkten prompt aus
      - Wenn parallel: true → spawn im background
      - Wenn parallel: false → warte auf completion

      ### 4. record_ralph_completion() Funktion

      - Extrahiere Summary aus RALPH_COMPLETE: Zeile
      - Setze ralph-exit.detected-at, iteration, final-summary
      - Setze status: completed
      - Warte auf alle parallelen hooks (wait)

      ## Gherkin Scenarios

      ```gherkin
      Scenario: Ralph Mode Detection
        Given PROGRESS.yaml mit mode: ralph
        When sprint-loop.sh startet
        Then wird run_ralph_loop aufgerufen
        And nicht run_standard_loop

      Scenario: Endlosschleife bis COMPLETE
        Given Ralph Mode aktiv
        And Claude gibt nach 5 Iterationen "RALPH_COMPLETE: Fertig" aus
        When die Loop läuft
        Then stoppt die Loop nach Iteration 5
        And status ist completed
        And ralph-exit.final-summary enthält "Fertig"

      Scenario: Per-iteration Hooks parallel
        Given per-iteration-hooks mit learning (parallel: true, enabled: true)
        When eine Ralph Iteration startet
        Then wird learning hook im background gespawned
        And die Haupt-Iteration wartet nicht darauf

      Scenario: Reflection nach idle threshold
        Given idle-threshold: 3
        And keine pending Steps für 3 Iterationen
        When die nächste Iteration startet
        Then ist der MODE "reflecting"
      ```

      ## Verifikation
      ```bash
      # Syntax check
      bash -n plugins/m42-sprint/scripts/sprint-loop.sh

      # Shellcheck
      shellcheck plugins/m42-sprint/scripts/sprint-loop.sh || true
      ```

  # ==========================================================================
  # Step 2: build-ralph-prompt.sh und Workflow-Datei
  # ==========================================================================
  - id: step-2
    prompt: |
      Erstelle das Prompt-Builder Script und die Ralph Workflow-Datei.

      ## Kontext
      Lies den Implementierungsplan: context/implementation-plan.md
      Lies build-sprint-prompt.sh als Referenz: plugins/m42-sprint/scripts/build-sprint-prompt.sh

      ## Aufgaben

      ### 1. build-ralph-prompt.sh erstellen

      Erstelle plugins/m42-sprint/scripts/build-ralph-prompt.sh:

      **Argumente:**
      - $1: SPRINT_DIR
      - $2: MODE (planning | executing | reflecting)
      - $3: ITERATION

      **Logik:**
      - Lese goal aus PROGRESS.yaml
      - Lese goal-prompt und reflection-prompt aus Workflow (optional)
      - Generiere mode-spezifischen Prompt:

      **planning Mode:**
      - Zeige Goal
      - Instruiere: Analysiere und erstelle Steps
      - Zeige yq Befehle zum Hinzufügen von Steps zu dynamic-steps[]
      - Erwähne RALPH_COMPLETE Keyword

      **executing Mode:**
      - Zeige Goal als Kontext
      - Zeige aktuellen pending Step (ID + Prompt)
      - Instruiere: Führe aus, markiere als completed
      - Erlaube Hinzufügen neuer Steps
      - EXIT nach diesem Task

      **reflecting Mode:**
      - Zeige Goal
      - Zeige Anzahl completed Steps
      - Optionen: RALPH_COMPLETE, neue Steps, oder needs-human

      ### 2. ralph.yaml Workflow erstellen

      Erstelle .claude/workflows/ralph.yaml mit:
      - name: Ralph Mode Workflow
      - mode: ralph
      - goal-prompt: Template für Goal-Analyse
      - reflection-prompt: Template für Reflection
      - per-iteration-hooks: Vordefinierte Hooks (default disabled)
        - learning (m42-signs:learning-extraction)
        - documentation
        - tests

      ### 3. Script executable machen

      ```bash
      chmod +x plugins/m42-sprint/scripts/build-ralph-prompt.sh
      ```

      ## Gherkin Scenarios

      ```gherkin
      Scenario: Planning Prompt Generation
        Given MODE=planning und GOAL="Build auth system"
        When build-ralph-prompt.sh ausgeführt wird
        Then enthält der Output "## Your Goal" mit dem Goal
        And enthält der Output yq Befehle für dynamic-steps
        And enthält der Output "RALPH_COMPLETE"

      Scenario: Executing Prompt Generation
        Given MODE=executing
        And dynamic-steps enthält step-0 mit status=pending
        When build-ralph-prompt.sh ausgeführt wird
        Then enthält der Output "## Current Task: step-0"
        And enthält der Output den Step Prompt
        And enthält der Output "EXIT after this task"

      Scenario: Reflecting Prompt Generation
        Given MODE=reflecting
        And 5 completed Steps
        When build-ralph-prompt.sh ausgeführt wird
        Then enthält der Output "## Completed: 5 steps"
        And enthält der Output Option A für RALPH_COMPLETE
        And enthält der Output Option B für neue Steps

      Scenario: Workflow File Syntax
        Given ralph.yaml existiert
        When yq validiert
        Then ist das YAML syntaktisch korrekt
        And enthält mode: ralph
      ```

      ## Verifikation
      ```bash
      # Script syntax
      bash -n plugins/m42-sprint/scripts/build-ralph-prompt.sh

      # Workflow YAML validieren
      yq '.' .claude/workflows/ralph.yaml

      # Executable check
      test -x plugins/m42-sprint/scripts/build-ralph-prompt.sh
      ```

  # ==========================================================================
  # Step 3: Integration und Dokumentation
  # ==========================================================================
  - id: step-3
    prompt: |
      Integriere Ralph Mode und erstelle Dokumentation.

      ## Kontext
      Lies den Implementierungsplan: context/implementation-plan.md

      ## Aufgaben

      ### 1. Dokumentation erstellen

      Erstelle plugins/m42-sprint/docs/concepts/ralph-mode.md:

      - Übersicht: Was ist Ralph Mode
      - Architektur-Diagramm (aus Plan übernehmen)
      - Hybrid-Konzept erklären (Frei + Deterministisch)
      - SPRINT.yaml Beispiel für Ralph Mode
      - Per-iteration Hooks erklären
      - Exit-Mechanismus (RALPH_COMPLETE)
      - Beispiele

      ### 2. Schema-Dokumentation erweitern

      Erweitere plugins/m42-sprint/skills/orchestrating-sprints/references/progress-schema.md:
      - Ralph Mode spezifische Felder dokumentieren
      - dynamic-steps Schema
      - hook-tasks Schema
      - ralph-exit Schema

      Erweitere plugins/m42-sprint/skills/creating-workflows/references/workflow-schema.md:
      - mode Feld dokumentieren
      - goal-prompt Feld
      - reflection-prompt Feld
      - per-iteration-hooks Feld

      ### 3. SKILL.md Updates

      Update plugins/m42-sprint/skills/orchestrating-sprints/SKILL.md:
      - Ralph Mode als neue Workflow-Option erwähnen
      - Verweis auf ralph-mode.md

      Update plugins/m42-sprint/skills/creating-workflows/SKILL.md:
      - Ralph Mode Workflows erklären
      - Per-iteration hooks dokumentieren

      ### 4. Compiler rebuild

      ```bash
      cd plugins/m42-sprint/compiler && npm run build
      ```

      ## Gherkin Scenarios

      ```gherkin
      Scenario: Ralph Mode Dokumentation existiert
        Given die Implementierung ist abgeschlossen
        When docs/concepts/ralph-mode.md gelesen wird
        Then enthält es Übersicht über Ralph Mode
        And enthält es Architektur-Diagramm
        And enthält es Beispiel SPRINT.yaml

      Scenario: Schema Dokumentation aktualisiert
        Given progress-schema.md existiert
        When der Ralph Mode Abschnitt gelesen wird
        Then dokumentiert er dynamic-steps
        And dokumentiert er hook-tasks
        And dokumentiert er ralph-exit

      Scenario: Workflow Schema erweitert
        Given workflow-schema.md existiert
        When der Ralph Mode Abschnitt gelesen wird
        Then dokumentiert er mode: ralph
        And dokumentiert er per-iteration-hooks

      Scenario: Compiler baut erfolgreich
        When npm run build im compiler Verzeichnis läuft
        Then ist der Exit Code 0
        And existiert dist/index.js
      ```

      ## Verifikation
      ```bash
      # Dokumentation existiert
      test -f plugins/m42-sprint/docs/concepts/ralph-mode.md

      # Compiler build
      cd plugins/m42-sprint/compiler && npm run build

      # Typecheck
      cd plugins/m42-sprint/compiler && npm run typecheck
      ```

  # ==========================================================================
  # Step 4: End-to-End Test
  # ==========================================================================
  - id: step-4
    prompt: |
      Führe einen End-to-End Test der Ralph Mode Implementierung durch.

      ## Aufgaben

      ### 1. Test Sprint erstellen

      Erstelle .claude/sprints/test-ralph-e2e/SPRINT.yaml:
      ```yaml
      workflow: ralph
      goal: |
        Create a simple hello.ts file that exports a greet function.
        The function should take a name and return "Hello, {name}!".
        Include a test file hello.test.ts with basic tests.

      per-iteration-hooks:
        learning:
          enabled: false  # Deaktiviert für Test
      ```

      ### 2. Kompilieren

      ```bash
      node plugins/m42-sprint/compiler/dist/index.js .claude/sprints/test-ralph-e2e -w ".claude/workflows" -v
      ```

      ### 3. PROGRESS.yaml validieren

      Prüfe dass PROGRESS.yaml korrekt generiert wurde:
      - mode: ralph
      - goal vorhanden
      - dynamic-steps: [] (leer)
      - per-iteration-hooks korrekt gemerged

      ### 4. Prompt-Generierung testen

      ```bash
      # Planning Mode
      plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e planning 1

      # Manuell Step hinzufügen für Test
      yq -i '.dynamic-steps += [{"id": "step-0", "prompt": "Create hello.ts", "status": "pending"}]' .claude/sprints/test-ralph-e2e/PROGRESS.yaml

      # Executing Mode
      plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e executing 2

      # Manuell als completed markieren
      yq -i '(.dynamic-steps[] | select(.id == "step-0")).status = "completed"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml

      # Reflecting Mode (keine pending Steps mehr)
      plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e reflecting 3
      ```

      ### 5. Sprint Loop Mode Detection testen

      ```bash
      # Prüfe ob Ralph Mode erkannt wird (dry run - nur Mode check)
      MODE=$(yq -r '.mode // "standard"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml)
      echo "Detected mode: $MODE"
      test "$MODE" = "ralph" && echo "✓ Ralph Mode korrekt erkannt"
      ```

      ### 6. Cleanup

      ```bash
      rm -rf .claude/sprints/test-ralph-e2e
      ```

      ## Gherkin Scenarios

      ```gherkin
      Scenario: E2E Compilation
        Given test-ralph-e2e Sprint existiert
        When Compiler ausgeführt wird
        Then wird PROGRESS.yaml mit mode: ralph generiert

      Scenario: E2E Prompt Generation alle Modi
        Given PROGRESS.yaml für Ralph Mode
        When build-ralph-prompt.sh mit planning, executing, reflecting aufgerufen wird
        Then generiert jeder Mode einen korrekten Prompt

      Scenario: E2E Mode Detection
        Given PROGRESS.yaml mit mode: ralph
        When sprint-loop.sh die Mode prüft
        Then erkennt es Ralph Mode

      Scenario: E2E Cleanup
        When der Test abgeschlossen ist
        Then existiert test-ralph-e2e nicht mehr
      ```

      ## Verifikation
      ```bash
      # Alles muss PASS sein
      echo "E2E Test completed"

      # Final project validation
      cd plugins/m42-sprint/compiler && npm run build && npm run typecheck
      ```
