sprint-id: 2026-01-18_ralph-mode-implementation
status: in-progress
phases:
  - id: preflight
    status: completed
    prompt: >
      Create comprehensive sprint context that ALL subsequent phases will reference.


      ## Your Task

      Analyze the entire sprint scope and generate shared context documents.


      ## Step 1: Create Sprint Branch

      ```bash

      git checkout -b sprint/2026-01-18_ralph-mode-implementation 2>/dev/null || git checkout sprint/2026-01-18_ralph-mode-implementation

      ```


      ## Step 2: Analyze Sprint Scope

      Read SPRINT.yaml to understand:

      - All steps and their relationships

      - Overall sprint goal

      - Technical requirements across all steps

      - Potential dependencies between steps


      ## Step 3: Research Project Context

      Investigate the codebase to understand:

      - Project architecture and structure

      - Key patterns and conventions used

      - Relevant types and interfaces

      - Build/test/lint commands

      - Dependencies (internal modules, external packages)


      ## Step 4: Generate Shared Context

      Create: context/_shared-context.md


      ```markdown

      # Shared Sprint Context


      ## Project Architecture

      [High-level architecture overview relevant to this sprint]


      ## Key Patterns

      - [Pattern 1]: [Where and how it's used]

      - [Pattern 2]: [Where and how it's used]

      ...


      ## Conventions

      - Naming: [Naming conventions]

      - File structure: [File organization patterns]

      - Testing: [Testing patterns and frameworks]

      - Error handling: [Error handling patterns]


      ## Commands

      - Build: `[build command]`

      - Test: `[test command]`

      - Lint: `[lint command]`

      - TypeCheck: `[typecheck command]`


      ## Dependencies

      ### Internal Modules

      - [Module]: [Purpose]


      ### External Packages

      - [Package]: [Usage]


      ## Types and Interfaces

      [Key types relevant to this sprint]

      ```


      ## Step 5: Generate Sprint Plan

      Create: context/sprint-plan.md


      ```markdown

      # Sprint Plan: 2026-01-18_ralph-mode-implementation


      ## Goal

      [One paragraph describing what this sprint accomplishes]


      ## Success Criteria

      - [ ] [Measurable criterion 1]

      - [ ] [Measurable criterion 2]

      ...


      ## Step Breakdown


      ### Step 0: [Step title from prompt]

      **Scope**: [What this step does]

      **Files**: [Expected files to create/modify]

      **Dependencies**: [What it depends on]

      **Risk**: Low/Medium/High - [reason]


      ### Step 1: ...

      [Continue for all steps]


      ## Step Dependency Graph

      ```

      step-0 → step-1 → step-2

































































































































































































                ↓
              step-3
      ```

      [Or describe dependencies textually]


      ## Risk Assessment

      | Risk | Impact | Mitigation |

      |------|--------|------------|

      | [Risk 1] | [Impact] | [How to mitigate] |


      ## Estimated Complexity

      | Step | Complexity | Reason |

      |------|------------|--------|

      | step-0 | Low/Medium/High | [Brief reason] |

      ```


      ## Output

      - Sprint branch created/checked out

      - context/_shared-context.md with project patterns

      - context/sprint-plan.md with step analysis

      - Commit preflight artifacts:

































































































































































































        ```bash
        git add context/
        git commit -m "preflight: add shared context and sprint plan"
        ```
    started-at: "2026-01-18T21:09:20Z"
    completed-at: "2026-01-18T21:13:32Z"
    elapsed: 00:01:37
  - id: development
    status: in-progress
    steps:
      - id: step-0
        prompt: |
          Erweitere das Compiler-System für Ralph Mode Support.

          ## Kontext
          Lies den Implementierungsplan: context/implementation-plan.md

          ## Aufgaben

          ### 1. Types erweitern (plugins/m42-sprint/compiler/src/types.ts)

          Füge folgende Interfaces hinzu:

          ```typescript
          interface PerIterationHook {
            id: string;
            workflow?: string;       // z.B. "m42-signs:learning-extraction"
            prompt?: string;         // Inline prompt Alternative
            parallel: boolean;
            enabled: boolean;
          }
          ```

          Erweitere das Workflow Interface:
          ```typescript
          interface Workflow {
            // ... bestehende Felder
            mode?: 'standard' | 'ralph';
            "goal-prompt"?: string;
            "reflection-prompt"?: string;
            "per-iteration-hooks"?: PerIterationHook[];
          }
          ```

          Erweitere Sprint Interface um `goal` Feld für Ralph Mode.

          ### 2. Compile.ts erweitern (plugins/m42-sprint/compiler/src/compile.ts)

          Füge Ralph Mode Detection und PROGRESS.yaml Generierung hinzu:

          - Prüfe ob Workflow `mode: ralph` hat
          - Wenn ja: Generiere PROGRESS.yaml mit Ralph-spezifischer Struktur:
            - `mode: ralph`
            - `goal:` aus SPRINT.yaml
            - `dynamic-steps: []` (initial leer)
            - `hook-tasks: []`
            - `per-iteration-hooks:` (merged aus Workflow + SPRINT.yaml)
            - `ralph:` Config Block
          - Merge per-iteration-hooks aus Workflow-Definition mit SPRINT.yaml Overrides

          ### 3. Validierung

          Füge Validierungsregeln hinzu:
          - Ralph Mode Workflows brauchen KEIN `phases:` Array
          - SPRINT.yaml mit Ralph Workflow MUSS `goal:` haben
          - Per-iteration hooks müssen entweder `workflow:` oder `prompt:` haben

          ## Gherkin Scenarios

          ```gherkin
          Scenario: Ralph Mode PROGRESS.yaml Generierung
            Given eine SPRINT.yaml mit workflow: ralph und goal: "Test goal"
            And eine ralph.yaml Workflow-Definition mit mode: ralph
            When der Compiler ausgeführt wird
            Then enthält PROGRESS.yaml mode: ralph
            And enthält PROGRESS.yaml das goal Feld
            And enthält PROGRESS.yaml leere dynamic-steps Array
            And enthält PROGRESS.yaml per-iteration-hooks aus Workflow

          Scenario: Per-iteration Hook Merging
            Given ralph.yaml mit per-iteration-hooks: learning (enabled: false)
            And SPRINT.yaml mit per-iteration-hooks: learning: enabled: true
            When der Compiler merged
            Then ist learning hook in PROGRESS.yaml enabled: true

          Scenario: Validierung ohne goal
            Given eine SPRINT.yaml mit workflow: ralph aber OHNE goal
            When der Compiler ausgeführt wird
            Then gibt es einen Validierungsfehler "Ralph mode requires goal field"
          ```

          ## Verifikation
          ```bash
          # Build compiler
          cd plugins/m42-sprint/compiler && npm run build

          # TypeScript prüfen
          npm run typecheck
          ```
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Erweitere das Compiler-System für Ralph Mode Support.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md

              ## Aufgaben

              ### 1. Types erweitern (plugins/m42-sprint/compiler/src/types.ts)

              Füge folgende Interfaces hinzu:

              ```typescript
              interface PerIterationHook {
                id: string;
                workflow?: string;       // z.B. "m42-signs:learning-extraction"
                prompt?: string;         // Inline prompt Alternative
                parallel: boolean;
                enabled: boolean;
              }
              ```

              Erweitere das Workflow Interface:
              ```typescript
              interface Workflow {
                // ... bestehende Felder
                mode?: 'standard' | 'ralph';
                "goal-prompt"?: string;
                "reflection-prompt"?: string;
                "per-iteration-hooks"?: PerIterationHook[];
              }
              ```

              Erweitere Sprint Interface um `goal` Feld für Ralph Mode.

              ### 2. Compile.ts erweitern (plugins/m42-sprint/compiler/src/compile.ts)

              Füge Ralph Mode Detection und PROGRESS.yaml Generierung hinzu:

              - Prüfe ob Workflow `mode: ralph` hat
              - Wenn ja: Generiere PROGRESS.yaml mit Ralph-spezifischer Struktur:
                - `mode: ralph`
                - `goal:` aus SPRINT.yaml
                - `dynamic-steps: []` (initial leer)
                - `hook-tasks: []`
                - `per-iteration-hooks:` (merged aus Workflow + SPRINT.yaml)
                - `ralph:` Config Block
              - Merge per-iteration-hooks aus Workflow-Definition mit SPRINT.yaml Overrides

              ### 3. Validierung

              Füge Validierungsregeln hinzu:
              - Ralph Mode Workflows brauchen KEIN `phases:` Array
              - SPRINT.yaml mit Ralph Workflow MUSS `goal:` haben
              - Per-iteration hooks müssen entweder `workflow:` oder `prompt:` haben

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode PROGRESS.yaml Generierung
                Given eine SPRINT.yaml mit workflow: ralph und goal: "Test goal"
                And eine ralph.yaml Workflow-Definition mit mode: ralph
                When der Compiler ausgeführt wird
                Then enthält PROGRESS.yaml mode: ralph
                And enthält PROGRESS.yaml das goal Feld
                And enthält PROGRESS.yaml leere dynamic-steps Array
                And enthält PROGRESS.yaml per-iteration-hooks aus Workflow

              Scenario: Per-iteration Hook Merging
                Given ralph.yaml mit per-iteration-hooks: learning (enabled: false)
                And SPRINT.yaml mit per-iteration-hooks: learning: enabled: true
                When der Compiler merged
                Then ist learning hook in PROGRESS.yaml enabled: true

              Scenario: Validierung ohne goal
                Given eine SPRINT.yaml mit workflow: ralph aber OHNE goal
                When der Compiler ausgeführt wird
                Then gibt es einen Validierungsfehler "Ralph mode requires goal field"
              ```

              ## Verifikation
              ```bash
              # Build compiler
              cd plugins/m42-sprint/compiler && npm run build

              # TypeScript prüfen
              npm run typecheck
              ```


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-0-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-0

              ## Step Task
              Erweitere das Compiler-System für Ralph Mode Support.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md

              ## Aufgaben

              ### 1. Types erweitern (plugins/m42-sprint/compiler/src/types.ts)

              Füge folgende Interfaces hinzu:

              ```typescript
              interface PerIterationHook {
                id: string;
                workflow?: string;       // z.B. "m42-signs:learning-extraction"
                prompt?: string;         // Inline prompt Alternative
                parallel: boolean;
                enabled: boolean;
              }
              ```

              Erweitere das Workflow Interface:
              ```typescript
              interface Workflow {
                // ... bestehende Felder
                mode?: 'standard' | 'ralph';
                "goal-prompt"?: string;
                "reflection-prompt"?: string;
                "per-iteration-hooks"?: PerIterationHook[];
              }
              ```

              Erweitere Sprint Interface um `goal` Feld für Ralph Mode.

              ### 2. Compile.ts erweitern (plugins/m42-sprint/compiler/src/compile.ts)

              Füge Ralph Mode Detection und PROGRESS.yaml Generierung hinzu:

              - Prüfe ob Workflow `mode: ralph` hat
              - Wenn ja: Generiere PROGRESS.yaml mit Ralph-spezifischer Struktur:
                - `mode: ralph`
                - `goal:` aus SPRINT.yaml
                - `dynamic-steps: []` (initial leer)
                - `hook-tasks: []`
                - `per-iteration-hooks:` (merged aus Workflow + SPRINT.yaml)
                - `ralph:` Config Block
              - Merge per-iteration-hooks aus Workflow-Definition mit SPRINT.yaml Overrides

              ### 3. Validierung

              Füge Validierungsregeln hinzu:
              - Ralph Mode Workflows brauchen KEIN `phases:` Array
              - SPRINT.yaml mit Ralph Workflow MUSS `goal:` haben
              - Per-iteration hooks müssen entweder `workflow:` oder `prompt:` haben

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode PROGRESS.yaml Generierung
                Given eine SPRINT.yaml mit workflow: ralph und goal: "Test goal"
                And eine ralph.yaml Workflow-Definition mit mode: ralph
                When der Compiler ausgeführt wird
                Then enthält PROGRESS.yaml mode: ralph
                And enthält PROGRESS.yaml das goal Feld
                And enthält PROGRESS.yaml leere dynamic-steps Array
                And enthält PROGRESS.yaml per-iteration-hooks aus Workflow

              Scenario: Per-iteration Hook Merging
                Given ralph.yaml mit per-iteration-hooks: learning (enabled: false)
                And SPRINT.yaml mit per-iteration-hooks: learning: enabled: true
                When der Compiler merged
                Then ist learning hook in PROGRESS.yaml enabled: true

              Scenario: Validierung ohne goal
                Given eine SPRINT.yaml mit workflow: ralph aber OHNE goal
                When der Compiler ausgeführt wird
                Then gibt es einen Validierungsfehler "Ralph mode requires goal field"
              ```

              ## Verifikation
              ```bash
              # Build compiler
              cd plugins/m42-sprint/compiler && npm run build

              # TypeScript prüfen
              npm run typecheck
              ```


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-0-gherkin.md
              git commit -m "plan(step-0): define gherkin scenarios"
              ```
            started-at: "2026-01-18T21:11:00Z"
            completed-at: "2026-01-18T21:12:18Z"
            elapsed: 00:01:18
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Erweitere das Compiler-System für Ralph Mode Support.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md

              ## Aufgaben

              ### 1. Types erweitern (plugins/m42-sprint/compiler/src/types.ts)

              Füge folgende Interfaces hinzu:

              ```typescript
              interface PerIterationHook {
                id: string;
                workflow?: string;       // z.B. "m42-signs:learning-extraction"
                prompt?: string;         // Inline prompt Alternative
                parallel: boolean;
                enabled: boolean;
              }
              ```

              Erweitere das Workflow Interface:
              ```typescript
              interface Workflow {
                // ... bestehende Felder
                mode?: 'standard' | 'ralph';
                "goal-prompt"?: string;
                "reflection-prompt"?: string;
                "per-iteration-hooks"?: PerIterationHook[];
              }
              ```

              Erweitere Sprint Interface um `goal` Feld für Ralph Mode.

              ### 2. Compile.ts erweitern (plugins/m42-sprint/compiler/src/compile.ts)

              Füge Ralph Mode Detection und PROGRESS.yaml Generierung hinzu:

              - Prüfe ob Workflow `mode: ralph` hat
              - Wenn ja: Generiere PROGRESS.yaml mit Ralph-spezifischer Struktur:
                - `mode: ralph`
                - `goal:` aus SPRINT.yaml
                - `dynamic-steps: []` (initial leer)
                - `hook-tasks: []`
                - `per-iteration-hooks:` (merged aus Workflow + SPRINT.yaml)
                - `ralph:` Config Block
              - Merge per-iteration-hooks aus Workflow-Definition mit SPRINT.yaml Overrides

              ### 3. Validierung

              Füge Validierungsregeln hinzu:
              - Ralph Mode Workflows brauchen KEIN `phases:` Array
              - SPRINT.yaml mit Ralph Workflow MUSS `goal:` haben
              - Per-iteration hooks müssen entweder `workflow:` oder `prompt:` haben

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode PROGRESS.yaml Generierung
                Given eine SPRINT.yaml mit workflow: ralph und goal: "Test goal"
                And eine ralph.yaml Workflow-Definition mit mode: ralph
                When der Compiler ausgeführt wird
                Then enthält PROGRESS.yaml mode: ralph
                And enthält PROGRESS.yaml das goal Feld
                And enthält PROGRESS.yaml leere dynamic-steps Array
                And enthält PROGRESS.yaml per-iteration-hooks aus Workflow

              Scenario: Per-iteration Hook Merging
                Given ralph.yaml mit per-iteration-hooks: learning (enabled: false)
                And SPRINT.yaml mit per-iteration-hooks: learning: enabled: true
                When der Compiler merged
                Then ist learning hook in PROGRESS.yaml enabled: true

              Scenario: Validierung ohne goal
                Given eine SPRINT.yaml mit workflow: ralph aber OHNE goal
                When der Compiler ausgeführt wird
                Then gibt es einen Validierungsfehler "Ralph mode requires goal field"
              ```

              ## Verifikation
              ```bash
              # Build compiler
              cd plugins/m42-sprint/compiler && npm run build

              # TypeScript prüfen
              npm run typecheck
              ```


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-0-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-0-context.md

              ```markdown
              # Step Context: step-0

              ## Task
              Erweitere das Compiler-System für Ralph Mode Support.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md

              ## Aufgaben

              ### 1. Types erweitern (plugins/m42-sprint/compiler/src/types.ts)

              Füge folgende Interfaces hinzu:

              ```typescript
              interface PerIterationHook {
                id: string;
                workflow?: string;       // z.B. "m42-signs:learning-extraction"
                prompt?: string;         // Inline prompt Alternative
                parallel: boolean;
                enabled: boolean;
              }
              ```

              Erweitere das Workflow Interface:
              ```typescript
              interface Workflow {
                // ... bestehende Felder
                mode?: 'standard' | 'ralph';
                "goal-prompt"?: string;
                "reflection-prompt"?: string;
                "per-iteration-hooks"?: PerIterationHook[];
              }
              ```

              Erweitere Sprint Interface um `goal` Feld für Ralph Mode.

              ### 2. Compile.ts erweitern (plugins/m42-sprint/compiler/src/compile.ts)

              Füge Ralph Mode Detection und PROGRESS.yaml Generierung hinzu:

              - Prüfe ob Workflow `mode: ralph` hat
              - Wenn ja: Generiere PROGRESS.yaml mit Ralph-spezifischer Struktur:
                - `mode: ralph`
                - `goal:` aus SPRINT.yaml
                - `dynamic-steps: []` (initial leer)
                - `hook-tasks: []`
                - `per-iteration-hooks:` (merged aus Workflow + SPRINT.yaml)
                - `ralph:` Config Block
              - Merge per-iteration-hooks aus Workflow-Definition mit SPRINT.yaml Overrides

              ### 3. Validierung

              Füge Validierungsregeln hinzu:
              - Ralph Mode Workflows brauchen KEIN `phases:` Array
              - SPRINT.yaml mit Ralph Workflow MUSS `goal:` haben
              - Per-iteration hooks müssen entweder `workflow:` oder `prompt:` haben

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode PROGRESS.yaml Generierung
                Given eine SPRINT.yaml mit workflow: ralph und goal: "Test goal"
                And eine ralph.yaml Workflow-Definition mit mode: ralph
                When der Compiler ausgeführt wird
                Then enthält PROGRESS.yaml mode: ralph
                And enthält PROGRESS.yaml das goal Feld
                And enthält PROGRESS.yaml leere dynamic-steps Array
                And enthält PROGRESS.yaml per-iteration-hooks aus Workflow

              Scenario: Per-iteration Hook Merging
                Given ralph.yaml mit per-iteration-hooks: learning (enabled: false)
                And SPRINT.yaml mit per-iteration-hooks: learning: enabled: true
                When der Compiler merged
                Then ist learning hook in PROGRESS.yaml enabled: true

              Scenario: Validierung ohne goal
                Given eine SPRINT.yaml mit workflow: ralph aber OHNE goal
                When der Compiler ausgeführt wird
                Then gibt es einen Validierungsfehler "Ralph mode requires goal field"
              ```

              ## Verifikation
              ```bash
              # Build compiler
              cd plugins/m42-sprint/compiler && npm run build

              # TypeScript prüfen
              npm run typecheck
              ```


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-0-context.md
              git commit -m "context(step-0): gather implementation context"
              ```
            started-at: "2026-01-18T21:12:20Z"
            completed-at: "2026-01-18T21:15:20Z"
            elapsed: 00:01:31
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Erweitere das Compiler-System für Ralph Mode Support.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md

              ## Aufgaben

              ### 1. Types erweitern (plugins/m42-sprint/compiler/src/types.ts)

              Füge folgende Interfaces hinzu:

              ```typescript
              interface PerIterationHook {
                id: string;
                workflow?: string;       // z.B. "m42-signs:learning-extraction"
                prompt?: string;         // Inline prompt Alternative
                parallel: boolean;
                enabled: boolean;
              }
              ```

              Erweitere das Workflow Interface:
              ```typescript
              interface Workflow {
                // ... bestehende Felder
                mode?: 'standard' | 'ralph';
                "goal-prompt"?: string;
                "reflection-prompt"?: string;
                "per-iteration-hooks"?: PerIterationHook[];
              }
              ```

              Erweitere Sprint Interface um `goal` Feld für Ralph Mode.

              ### 2. Compile.ts erweitern (plugins/m42-sprint/compiler/src/compile.ts)

              Füge Ralph Mode Detection und PROGRESS.yaml Generierung hinzu:

              - Prüfe ob Workflow `mode: ralph` hat
              - Wenn ja: Generiere PROGRESS.yaml mit Ralph-spezifischer Struktur:
                - `mode: ralph`
                - `goal:` aus SPRINT.yaml
                - `dynamic-steps: []` (initial leer)
                - `hook-tasks: []`
                - `per-iteration-hooks:` (merged aus Workflow + SPRINT.yaml)
                - `ralph:` Config Block
              - Merge per-iteration-hooks aus Workflow-Definition mit SPRINT.yaml Overrides

              ### 3. Validierung

              Füge Validierungsregeln hinzu:
              - Ralph Mode Workflows brauchen KEIN `phases:` Array
              - SPRINT.yaml mit Ralph Workflow MUSS `goal:` haben
              - Per-iteration hooks müssen entweder `workflow:` oder `prompt:` haben

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode PROGRESS.yaml Generierung
                Given eine SPRINT.yaml mit workflow: ralph und goal: "Test goal"
                And eine ralph.yaml Workflow-Definition mit mode: ralph
                When der Compiler ausgeführt wird
                Then enthält PROGRESS.yaml mode: ralph
                And enthält PROGRESS.yaml das goal Feld
                And enthält PROGRESS.yaml leere dynamic-steps Array
                And enthält PROGRESS.yaml per-iteration-hooks aus Workflow

              Scenario: Per-iteration Hook Merging
                Given ralph.yaml mit per-iteration-hooks: learning (enabled: false)
                And SPRINT.yaml mit per-iteration-hooks: learning: enabled: true
                When der Compiler merged
                Then ist learning hook in PROGRESS.yaml enabled: true

              Scenario: Validierung ohne goal
                Given eine SPRINT.yaml mit workflow: ralph aber OHNE goal
                When der Compiler ausgeführt wird
                Then gibt es einen Validierungsfehler "Ralph mode requires goal field"
              ```

              ## Verifikation
              ```bash
              # Build compiler
              cd plugins/m42-sprint/compiler && npm run build

              # TypeScript prüfen
              npm run typecheck
              ```


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-0-gherkin.md (scenarios to satisfy)
              4. context/step-0-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-0): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-18T21:13:54Z"
            completed-at: "2026-01-18T21:21:07Z"
            elapsed: 00:06:56
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-0-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-0-qa-report.md

              ```markdown
              # QA Report: step-0

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-0-qa-report.md
                 git commit -m "qa(step-0): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-0.\n\n## Context\nRead: artifacts/step-0-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-0-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-0-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-0 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-18T21:21:10Z"
            completed-at: "2026-01-18T21:22:38Z"
            elapsed: 00:01:00
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Erweitere das Compiler-System für Ralph Mode Support.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md

              ## Aufgaben

              ### 1. Types erweitern (plugins/m42-sprint/compiler/src/types.ts)

              Füge folgende Interfaces hinzu:

              ```typescript
              interface PerIterationHook {
                id: string;
                workflow?: string;       // z.B. "m42-signs:learning-extraction"
                prompt?: string;         // Inline prompt Alternative
                parallel: boolean;
                enabled: boolean;
              }
              ```

              Erweitere das Workflow Interface:
              ```typescript
              interface Workflow {
                // ... bestehende Felder
                mode?: 'standard' | 'ralph';
                "goal-prompt"?: string;
                "reflection-prompt"?: string;
                "per-iteration-hooks"?: PerIterationHook[];
              }
              ```

              Erweitere Sprint Interface um `goal` Feld für Ralph Mode.

              ### 2. Compile.ts erweitern (plugins/m42-sprint/compiler/src/compile.ts)

              Füge Ralph Mode Detection und PROGRESS.yaml Generierung hinzu:

              - Prüfe ob Workflow `mode: ralph` hat
              - Wenn ja: Generiere PROGRESS.yaml mit Ralph-spezifischer Struktur:
                - `mode: ralph`
                - `goal:` aus SPRINT.yaml
                - `dynamic-steps: []` (initial leer)
                - `hook-tasks: []`
                - `per-iteration-hooks:` (merged aus Workflow + SPRINT.yaml)
                - `ralph:` Config Block
              - Merge per-iteration-hooks aus Workflow-Definition mit SPRINT.yaml Overrides

              ### 3. Validierung

              Füge Validierungsregeln hinzu:
              - Ralph Mode Workflows brauchen KEIN `phases:` Array
              - SPRINT.yaml mit Ralph Workflow MUSS `goal:` haben
              - Per-iteration hooks müssen entweder `workflow:` oder `prompt:` haben

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode PROGRESS.yaml Generierung
                Given eine SPRINT.yaml mit workflow: ralph und goal: "Test goal"
                And eine ralph.yaml Workflow-Definition mit mode: ralph
                When der Compiler ausgeführt wird
                Then enthält PROGRESS.yaml mode: ralph
                And enthält PROGRESS.yaml das goal Feld
                And enthält PROGRESS.yaml leere dynamic-steps Array
                And enthält PROGRESS.yaml per-iteration-hooks aus Workflow

              Scenario: Per-iteration Hook Merging
                Given ralph.yaml mit per-iteration-hooks: learning (enabled: false)
                And SPRINT.yaml mit per-iteration-hooks: learning: enabled: true
                When der Compiler merged
                Then ist learning hook in PROGRESS.yaml enabled: true

              Scenario: Validierung ohne goal
                Given eine SPRINT.yaml mit workflow: ralph aber OHNE goal
                When der Compiler ausgeführt wird
                Then gibt es einen Validierungsfehler "Ralph mode requires goal field"
              ```

              ## Verifikation
              ```bash
              # Build compiler
              cd plugins/m42-sprint/compiler && npm run build

              # TypeScript prüfen
              npm run typecheck
              ```


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-0-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-0): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-18T21:22:40Z"
            completed-at: "2026-01-18T21:24:31Z"
            elapsed: 00:01:32
      - id: step-1
        prompt: |
          Implementiere die Ralph Loop Funktion in sprint-loop.sh.

          ## Kontext
          Lies den Implementierungsplan: context/implementation-plan.md
          Lies die bestehende sprint-loop.sh: plugins/m42-sprint/scripts/sprint-loop.sh

          ## Aufgaben

          ### 1. Mode Detection am Loop-Start

          Am Anfang des Scripts nach PROGRESS.yaml Validierung:
          ```bash
          MODE=$(yq -r '.mode // "standard"' "$PROGRESS_FILE")

          if [[ "$MODE" == "ralph" ]]; then
            run_ralph_loop
          else
            # Bestehende Logik
            run_standard_loop
          fi
          ```

          Refaktoriere bestehende Loop-Logik in `run_standard_loop()` Funktion.

          ### 2. run_ralph_loop() Funktion

          Implementiere die Endlosschleife:
          - Kein MAX_ITERATIONS Limit (echte Endlosschleife)
          - Bestimme Modus basierend auf pending Steps:
            - Keine pending Steps + idle_count < threshold → "planning"
            - Keine pending Steps + idle_count >= threshold → "reflecting"
            - Pending Steps vorhanden → "executing"
          - Baue Prompt via build-ralph-prompt.sh
          - Spawn per-iteration hooks (wenn enabled)
          - Führe Claude aus mit Transcript-Speicherung
          - Prüfe auf RALPH_COMPLETE: im Output
          - Wenn gefunden: record_ralph_completion() und exit

          ### 3. spawn_per_iteration_hooks() Funktion

          Iteriere über enabled hooks aus PROGRESS.yaml:
          - Registriere Task in hook-tasks[]
          - Wenn workflow: → führe als /workflow-name aus
          - Wenn prompt: → führe als direkten prompt aus
          - Wenn parallel: true → spawn im background
          - Wenn parallel: false → warte auf completion

          ### 4. record_ralph_completion() Funktion

          - Extrahiere Summary aus RALPH_COMPLETE: Zeile
          - Setze ralph-exit.detected-at, iteration, final-summary
          - Setze status: completed
          - Warte auf alle parallelen hooks (wait)

          ## Gherkin Scenarios

          ```gherkin
          Scenario: Ralph Mode Detection
            Given PROGRESS.yaml mit mode: ralph
            When sprint-loop.sh startet
            Then wird run_ralph_loop aufgerufen
            And nicht run_standard_loop

          Scenario: Endlosschleife bis COMPLETE
            Given Ralph Mode aktiv
            And Claude gibt nach 5 Iterationen "RALPH_COMPLETE: Fertig" aus
            When die Loop läuft
            Then stoppt die Loop nach Iteration 5
            And status ist completed
            And ralph-exit.final-summary enthält "Fertig"

          Scenario: Per-iteration Hooks parallel
            Given per-iteration-hooks mit learning (parallel: true, enabled: true)
            When eine Ralph Iteration startet
            Then wird learning hook im background gespawned
            And die Haupt-Iteration wartet nicht darauf

          Scenario: Reflection nach idle threshold
            Given idle-threshold: 3
            And keine pending Steps für 3 Iterationen
            When die nächste Iteration startet
            Then ist der MODE "reflecting"
          ```

          ## Verifikation
          ```bash
          # Syntax check
          bash -n plugins/m42-sprint/scripts/sprint-loop.sh

          # Shellcheck
          shellcheck plugins/m42-sprint/scripts/sprint-loop.sh || true
          ```
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Implementiere die Ralph Loop Funktion in sprint-loop.sh.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md
              Lies die bestehende sprint-loop.sh: plugins/m42-sprint/scripts/sprint-loop.sh

              ## Aufgaben

              ### 1. Mode Detection am Loop-Start

              Am Anfang des Scripts nach PROGRESS.yaml Validierung:
              ```bash
              MODE=$(yq -r '.mode // "standard"' "$PROGRESS_FILE")

              if [[ "$MODE" == "ralph" ]]; then
                run_ralph_loop
              else
                # Bestehende Logik
                run_standard_loop
              fi
              ```

              Refaktoriere bestehende Loop-Logik in `run_standard_loop()` Funktion.

              ### 2. run_ralph_loop() Funktion

              Implementiere die Endlosschleife:
              - Kein MAX_ITERATIONS Limit (echte Endlosschleife)
              - Bestimme Modus basierend auf pending Steps:
                - Keine pending Steps + idle_count < threshold → "planning"
                - Keine pending Steps + idle_count >= threshold → "reflecting"
                - Pending Steps vorhanden → "executing"
              - Baue Prompt via build-ralph-prompt.sh
              - Spawn per-iteration hooks (wenn enabled)
              - Führe Claude aus mit Transcript-Speicherung
              - Prüfe auf RALPH_COMPLETE: im Output
              - Wenn gefunden: record_ralph_completion() und exit

              ### 3. spawn_per_iteration_hooks() Funktion

              Iteriere über enabled hooks aus PROGRESS.yaml:
              - Registriere Task in hook-tasks[]
              - Wenn workflow: → führe als /workflow-name aus
              - Wenn prompt: → führe als direkten prompt aus
              - Wenn parallel: true → spawn im background
              - Wenn parallel: false → warte auf completion

              ### 4. record_ralph_completion() Funktion

              - Extrahiere Summary aus RALPH_COMPLETE: Zeile
              - Setze ralph-exit.detected-at, iteration, final-summary
              - Setze status: completed
              - Warte auf alle parallelen hooks (wait)

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode Detection
                Given PROGRESS.yaml mit mode: ralph
                When sprint-loop.sh startet
                Then wird run_ralph_loop aufgerufen
                And nicht run_standard_loop

              Scenario: Endlosschleife bis COMPLETE
                Given Ralph Mode aktiv
                And Claude gibt nach 5 Iterationen "RALPH_COMPLETE: Fertig" aus
                When die Loop läuft
                Then stoppt die Loop nach Iteration 5
                And status ist completed
                And ralph-exit.final-summary enthält "Fertig"

              Scenario: Per-iteration Hooks parallel
                Given per-iteration-hooks mit learning (parallel: true, enabled: true)
                When eine Ralph Iteration startet
                Then wird learning hook im background gespawned
                And die Haupt-Iteration wartet nicht darauf

              Scenario: Reflection nach idle threshold
                Given idle-threshold: 3
                And keine pending Steps für 3 Iterationen
                When die nächste Iteration startet
                Then ist der MODE "reflecting"
              ```

              ## Verifikation
              ```bash
              # Syntax check
              bash -n plugins/m42-sprint/scripts/sprint-loop.sh

              # Shellcheck
              shellcheck plugins/m42-sprint/scripts/sprint-loop.sh || true
              ```


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-1-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-1

              ## Step Task
              Implementiere die Ralph Loop Funktion in sprint-loop.sh.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md
              Lies die bestehende sprint-loop.sh: plugins/m42-sprint/scripts/sprint-loop.sh

              ## Aufgaben

              ### 1. Mode Detection am Loop-Start

              Am Anfang des Scripts nach PROGRESS.yaml Validierung:
              ```bash
              MODE=$(yq -r '.mode // "standard"' "$PROGRESS_FILE")

              if [[ "$MODE" == "ralph" ]]; then
                run_ralph_loop
              else
                # Bestehende Logik
                run_standard_loop
              fi
              ```

              Refaktoriere bestehende Loop-Logik in `run_standard_loop()` Funktion.

              ### 2. run_ralph_loop() Funktion

              Implementiere die Endlosschleife:
              - Kein MAX_ITERATIONS Limit (echte Endlosschleife)
              - Bestimme Modus basierend auf pending Steps:
                - Keine pending Steps + idle_count < threshold → "planning"
                - Keine pending Steps + idle_count >= threshold → "reflecting"
                - Pending Steps vorhanden → "executing"
              - Baue Prompt via build-ralph-prompt.sh
              - Spawn per-iteration hooks (wenn enabled)
              - Führe Claude aus mit Transcript-Speicherung
              - Prüfe auf RALPH_COMPLETE: im Output
              - Wenn gefunden: record_ralph_completion() und exit

              ### 3. spawn_per_iteration_hooks() Funktion

              Iteriere über enabled hooks aus PROGRESS.yaml:
              - Registriere Task in hook-tasks[]
              - Wenn workflow: → führe als /workflow-name aus
              - Wenn prompt: → führe als direkten prompt aus
              - Wenn parallel: true → spawn im background
              - Wenn parallel: false → warte auf completion

              ### 4. record_ralph_completion() Funktion

              - Extrahiere Summary aus RALPH_COMPLETE: Zeile
              - Setze ralph-exit.detected-at, iteration, final-summary
              - Setze status: completed
              - Warte auf alle parallelen hooks (wait)

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode Detection
                Given PROGRESS.yaml mit mode: ralph
                When sprint-loop.sh startet
                Then wird run_ralph_loop aufgerufen
                And nicht run_standard_loop

              Scenario: Endlosschleife bis COMPLETE
                Given Ralph Mode aktiv
                And Claude gibt nach 5 Iterationen "RALPH_COMPLETE: Fertig" aus
                When die Loop läuft
                Then stoppt die Loop nach Iteration 5
                And status ist completed
                And ralph-exit.final-summary enthält "Fertig"

              Scenario: Per-iteration Hooks parallel
                Given per-iteration-hooks mit learning (parallel: true, enabled: true)
                When eine Ralph Iteration startet
                Then wird learning hook im background gespawned
                And die Haupt-Iteration wartet nicht darauf

              Scenario: Reflection nach idle threshold
                Given idle-threshold: 3
                And keine pending Steps für 3 Iterationen
                When die nächste Iteration startet
                Then ist der MODE "reflecting"
              ```

              ## Verifikation
              ```bash
              # Syntax check
              bash -n plugins/m42-sprint/scripts/sprint-loop.sh

              # Shellcheck
              shellcheck plugins/m42-sprint/scripts/sprint-loop.sh || true
              ```


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-1-gherkin.md
              git commit -m "plan(step-1): define gherkin scenarios"
              ```
            started-at: "2026-01-18T21:24:34Z"
            completed-at: "2026-01-18T21:25:55Z"
            elapsed: 00:01:00
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Implementiere die Ralph Loop Funktion in sprint-loop.sh.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md
              Lies die bestehende sprint-loop.sh: plugins/m42-sprint/scripts/sprint-loop.sh

              ## Aufgaben

              ### 1. Mode Detection am Loop-Start

              Am Anfang des Scripts nach PROGRESS.yaml Validierung:
              ```bash
              MODE=$(yq -r '.mode // "standard"' "$PROGRESS_FILE")

              if [[ "$MODE" == "ralph" ]]; then
                run_ralph_loop
              else
                # Bestehende Logik
                run_standard_loop
              fi
              ```

              Refaktoriere bestehende Loop-Logik in `run_standard_loop()` Funktion.

              ### 2. run_ralph_loop() Funktion

              Implementiere die Endlosschleife:
              - Kein MAX_ITERATIONS Limit (echte Endlosschleife)
              - Bestimme Modus basierend auf pending Steps:
                - Keine pending Steps + idle_count < threshold → "planning"
                - Keine pending Steps + idle_count >= threshold → "reflecting"
                - Pending Steps vorhanden → "executing"
              - Baue Prompt via build-ralph-prompt.sh
              - Spawn per-iteration hooks (wenn enabled)
              - Führe Claude aus mit Transcript-Speicherung
              - Prüfe auf RALPH_COMPLETE: im Output
              - Wenn gefunden: record_ralph_completion() und exit

              ### 3. spawn_per_iteration_hooks() Funktion

              Iteriere über enabled hooks aus PROGRESS.yaml:
              - Registriere Task in hook-tasks[]
              - Wenn workflow: → führe als /workflow-name aus
              - Wenn prompt: → führe als direkten prompt aus
              - Wenn parallel: true → spawn im background
              - Wenn parallel: false → warte auf completion

              ### 4. record_ralph_completion() Funktion

              - Extrahiere Summary aus RALPH_COMPLETE: Zeile
              - Setze ralph-exit.detected-at, iteration, final-summary
              - Setze status: completed
              - Warte auf alle parallelen hooks (wait)

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode Detection
                Given PROGRESS.yaml mit mode: ralph
                When sprint-loop.sh startet
                Then wird run_ralph_loop aufgerufen
                And nicht run_standard_loop

              Scenario: Endlosschleife bis COMPLETE
                Given Ralph Mode aktiv
                And Claude gibt nach 5 Iterationen "RALPH_COMPLETE: Fertig" aus
                When die Loop läuft
                Then stoppt die Loop nach Iteration 5
                And status ist completed
                And ralph-exit.final-summary enthält "Fertig"

              Scenario: Per-iteration Hooks parallel
                Given per-iteration-hooks mit learning (parallel: true, enabled: true)
                When eine Ralph Iteration startet
                Then wird learning hook im background gespawned
                And die Haupt-Iteration wartet nicht darauf

              Scenario: Reflection nach idle threshold
                Given idle-threshold: 3
                And keine pending Steps für 3 Iterationen
                When die nächste Iteration startet
                Then ist der MODE "reflecting"
              ```

              ## Verifikation
              ```bash
              # Syntax check
              bash -n plugins/m42-sprint/scripts/sprint-loop.sh

              # Shellcheck
              shellcheck plugins/m42-sprint/scripts/sprint-loop.sh || true
              ```


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-1-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-1-context.md

              ```markdown
              # Step Context: step-1

              ## Task
              Implementiere die Ralph Loop Funktion in sprint-loop.sh.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md
              Lies die bestehende sprint-loop.sh: plugins/m42-sprint/scripts/sprint-loop.sh

              ## Aufgaben

              ### 1. Mode Detection am Loop-Start

              Am Anfang des Scripts nach PROGRESS.yaml Validierung:
              ```bash
              MODE=$(yq -r '.mode // "standard"' "$PROGRESS_FILE")

              if [[ "$MODE" == "ralph" ]]; then
                run_ralph_loop
              else
                # Bestehende Logik
                run_standard_loop
              fi
              ```

              Refaktoriere bestehende Loop-Logik in `run_standard_loop()` Funktion.

              ### 2. run_ralph_loop() Funktion

              Implementiere die Endlosschleife:
              - Kein MAX_ITERATIONS Limit (echte Endlosschleife)
              - Bestimme Modus basierend auf pending Steps:
                - Keine pending Steps + idle_count < threshold → "planning"
                - Keine pending Steps + idle_count >= threshold → "reflecting"
                - Pending Steps vorhanden → "executing"
              - Baue Prompt via build-ralph-prompt.sh
              - Spawn per-iteration hooks (wenn enabled)
              - Führe Claude aus mit Transcript-Speicherung
              - Prüfe auf RALPH_COMPLETE: im Output
              - Wenn gefunden: record_ralph_completion() und exit

              ### 3. spawn_per_iteration_hooks() Funktion

              Iteriere über enabled hooks aus PROGRESS.yaml:
              - Registriere Task in hook-tasks[]
              - Wenn workflow: → führe als /workflow-name aus
              - Wenn prompt: → führe als direkten prompt aus
              - Wenn parallel: true → spawn im background
              - Wenn parallel: false → warte auf completion

              ### 4. record_ralph_completion() Funktion

              - Extrahiere Summary aus RALPH_COMPLETE: Zeile
              - Setze ralph-exit.detected-at, iteration, final-summary
              - Setze status: completed
              - Warte auf alle parallelen hooks (wait)

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode Detection
                Given PROGRESS.yaml mit mode: ralph
                When sprint-loop.sh startet
                Then wird run_ralph_loop aufgerufen
                And nicht run_standard_loop

              Scenario: Endlosschleife bis COMPLETE
                Given Ralph Mode aktiv
                And Claude gibt nach 5 Iterationen "RALPH_COMPLETE: Fertig" aus
                When die Loop läuft
                Then stoppt die Loop nach Iteration 5
                And status ist completed
                And ralph-exit.final-summary enthält "Fertig"

              Scenario: Per-iteration Hooks parallel
                Given per-iteration-hooks mit learning (parallel: true, enabled: true)
                When eine Ralph Iteration startet
                Then wird learning hook im background gespawned
                And die Haupt-Iteration wartet nicht darauf

              Scenario: Reflection nach idle threshold
                Given idle-threshold: 3
                And keine pending Steps für 3 Iterationen
                When die nächste Iteration startet
                Then ist der MODE "reflecting"
              ```

              ## Verifikation
              ```bash
              # Syntax check
              bash -n plugins/m42-sprint/scripts/sprint-loop.sh

              # Shellcheck
              shellcheck plugins/m42-sprint/scripts/sprint-loop.sh || true
              ```


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-1-context.md
              git commit -m "context(step-1): gather implementation context"
              ```
            started-at: "2026-01-18T21:25:38Z"
            completed-at: "2026-01-18T21:28:30Z"
            elapsed: 00:01:40
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Implementiere die Ralph Loop Funktion in sprint-loop.sh.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md
              Lies die bestehende sprint-loop.sh: plugins/m42-sprint/scripts/sprint-loop.sh

              ## Aufgaben

              ### 1. Mode Detection am Loop-Start

              Am Anfang des Scripts nach PROGRESS.yaml Validierung:
              ```bash
              MODE=$(yq -r '.mode // "standard"' "$PROGRESS_FILE")

              if [[ "$MODE" == "ralph" ]]; then
                run_ralph_loop
              else
                # Bestehende Logik
                run_standard_loop
              fi
              ```

              Refaktoriere bestehende Loop-Logik in `run_standard_loop()` Funktion.

              ### 2. run_ralph_loop() Funktion

              Implementiere die Endlosschleife:
              - Kein MAX_ITERATIONS Limit (echte Endlosschleife)
              - Bestimme Modus basierend auf pending Steps:
                - Keine pending Steps + idle_count < threshold → "planning"
                - Keine pending Steps + idle_count >= threshold → "reflecting"
                - Pending Steps vorhanden → "executing"
              - Baue Prompt via build-ralph-prompt.sh
              - Spawn per-iteration hooks (wenn enabled)
              - Führe Claude aus mit Transcript-Speicherung
              - Prüfe auf RALPH_COMPLETE: im Output
              - Wenn gefunden: record_ralph_completion() und exit

              ### 3. spawn_per_iteration_hooks() Funktion

              Iteriere über enabled hooks aus PROGRESS.yaml:
              - Registriere Task in hook-tasks[]
              - Wenn workflow: → führe als /workflow-name aus
              - Wenn prompt: → führe als direkten prompt aus
              - Wenn parallel: true → spawn im background
              - Wenn parallel: false → warte auf completion

              ### 4. record_ralph_completion() Funktion

              - Extrahiere Summary aus RALPH_COMPLETE: Zeile
              - Setze ralph-exit.detected-at, iteration, final-summary
              - Setze status: completed
              - Warte auf alle parallelen hooks (wait)

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode Detection
                Given PROGRESS.yaml mit mode: ralph
                When sprint-loop.sh startet
                Then wird run_ralph_loop aufgerufen
                And nicht run_standard_loop

              Scenario: Endlosschleife bis COMPLETE
                Given Ralph Mode aktiv
                And Claude gibt nach 5 Iterationen "RALPH_COMPLETE: Fertig" aus
                When die Loop läuft
                Then stoppt die Loop nach Iteration 5
                And status ist completed
                And ralph-exit.final-summary enthält "Fertig"

              Scenario: Per-iteration Hooks parallel
                Given per-iteration-hooks mit learning (parallel: true, enabled: true)
                When eine Ralph Iteration startet
                Then wird learning hook im background gespawned
                And die Haupt-Iteration wartet nicht darauf

              Scenario: Reflection nach idle threshold
                Given idle-threshold: 3
                And keine pending Steps für 3 Iterationen
                When die nächste Iteration startet
                Then ist der MODE "reflecting"
              ```

              ## Verifikation
              ```bash
              # Syntax check
              bash -n plugins/m42-sprint/scripts/sprint-loop.sh

              # Shellcheck
              shellcheck plugins/m42-sprint/scripts/sprint-loop.sh || true
              ```


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-1-gherkin.md (scenarios to satisfy)
              4. context/step-1-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-1): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-18T21:27:20Z"
            completed-at: "2026-01-18T21:31:00Z"
            elapsed: 00:02:49
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-1-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-1-qa-report.md

              ```markdown
              # QA Report: step-1

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-1-qa-report.md
                 git commit -m "qa(step-1): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-1.\n\n## Context\nRead: artifacts/step-1-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-1-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-1-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-1 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-18T21:30:13Z"
            completed-at: "2026-01-18T21:32:27Z"
            elapsed: 00:01:20
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Implementiere die Ralph Loop Funktion in sprint-loop.sh.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md
              Lies die bestehende sprint-loop.sh: plugins/m42-sprint/scripts/sprint-loop.sh

              ## Aufgaben

              ### 1. Mode Detection am Loop-Start

              Am Anfang des Scripts nach PROGRESS.yaml Validierung:
              ```bash
              MODE=$(yq -r '.mode // "standard"' "$PROGRESS_FILE")

              if [[ "$MODE" == "ralph" ]]; then
                run_ralph_loop
              else
                # Bestehende Logik
                run_standard_loop
              fi
              ```

              Refaktoriere bestehende Loop-Logik in `run_standard_loop()` Funktion.

              ### 2. run_ralph_loop() Funktion

              Implementiere die Endlosschleife:
              - Kein MAX_ITERATIONS Limit (echte Endlosschleife)
              - Bestimme Modus basierend auf pending Steps:
                - Keine pending Steps + idle_count < threshold → "planning"
                - Keine pending Steps + idle_count >= threshold → "reflecting"
                - Pending Steps vorhanden → "executing"
              - Baue Prompt via build-ralph-prompt.sh
              - Spawn per-iteration hooks (wenn enabled)
              - Führe Claude aus mit Transcript-Speicherung
              - Prüfe auf RALPH_COMPLETE: im Output
              - Wenn gefunden: record_ralph_completion() und exit

              ### 3. spawn_per_iteration_hooks() Funktion

              Iteriere über enabled hooks aus PROGRESS.yaml:
              - Registriere Task in hook-tasks[]
              - Wenn workflow: → führe als /workflow-name aus
              - Wenn prompt: → führe als direkten prompt aus
              - Wenn parallel: true → spawn im background
              - Wenn parallel: false → warte auf completion

              ### 4. record_ralph_completion() Funktion

              - Extrahiere Summary aus RALPH_COMPLETE: Zeile
              - Setze ralph-exit.detected-at, iteration, final-summary
              - Setze status: completed
              - Warte auf alle parallelen hooks (wait)

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode Detection
                Given PROGRESS.yaml mit mode: ralph
                When sprint-loop.sh startet
                Then wird run_ralph_loop aufgerufen
                And nicht run_standard_loop

              Scenario: Endlosschleife bis COMPLETE
                Given Ralph Mode aktiv
                And Claude gibt nach 5 Iterationen "RALPH_COMPLETE: Fertig" aus
                When die Loop läuft
                Then stoppt die Loop nach Iteration 5
                And status ist completed
                And ralph-exit.final-summary enthält "Fertig"

              Scenario: Per-iteration Hooks parallel
                Given per-iteration-hooks mit learning (parallel: true, enabled: true)
                When eine Ralph Iteration startet
                Then wird learning hook im background gespawned
                And die Haupt-Iteration wartet nicht darauf

              Scenario: Reflection nach idle threshold
                Given idle-threshold: 3
                And keine pending Steps für 3 Iterationen
                When die nächste Iteration startet
                Then ist der MODE "reflecting"
              ```

              ## Verifikation
              ```bash
              # Syntax check
              bash -n plugins/m42-sprint/scripts/sprint-loop.sh

              # Shellcheck
              shellcheck plugins/m42-sprint/scripts/sprint-loop.sh || true
              ```


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-1-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-1): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-18T21:31:37Z"
            completed-at: "2026-01-18T21:33:54Z"
            elapsed: 00:02:02
      - id: step-2
        prompt: |
          Erstelle das Prompt-Builder Script und die Ralph Workflow-Datei.

          ## Kontext
          Lies den Implementierungsplan: context/implementation-plan.md
          Lies build-sprint-prompt.sh als Referenz: plugins/m42-sprint/scripts/build-sprint-prompt.sh

          ## Aufgaben

          ### 1. build-ralph-prompt.sh erstellen

          Erstelle plugins/m42-sprint/scripts/build-ralph-prompt.sh:

          **Argumente:**
          - $1: SPRINT_DIR
          - $2: MODE (planning | executing | reflecting)
          - $3: ITERATION

          **Logik:**
          - Lese goal aus PROGRESS.yaml
          - Lese goal-prompt und reflection-prompt aus Workflow (optional)
          - Generiere mode-spezifischen Prompt:

          **planning Mode:**
          - Zeige Goal
          - Instruiere: Analysiere und erstelle Steps
          - Zeige yq Befehle zum Hinzufügen von Steps zu dynamic-steps[]
          - Erwähne RALPH_COMPLETE Keyword

          **executing Mode:**
          - Zeige Goal als Kontext
          - Zeige aktuellen pending Step (ID + Prompt)
          - Instruiere: Führe aus, markiere als completed
          - Erlaube Hinzufügen neuer Steps
          - EXIT nach diesem Task

          **reflecting Mode:**
          - Zeige Goal
          - Zeige Anzahl completed Steps
          - Optionen: RALPH_COMPLETE, neue Steps, oder needs-human

          ### 2. ralph.yaml Workflow erstellen

          Erstelle .claude/workflows/ralph.yaml mit:
          - name: Ralph Mode Workflow
          - mode: ralph
          - goal-prompt: Template für Goal-Analyse
          - reflection-prompt: Template für Reflection
          - per-iteration-hooks: Vordefinierte Hooks (default disabled)
            - learning (m42-signs:learning-extraction)
            - documentation
            - tests

          ### 3. Script executable machen

          ```bash
          chmod +x plugins/m42-sprint/scripts/build-ralph-prompt.sh
          ```

          ## Gherkin Scenarios

          ```gherkin
          Scenario: Planning Prompt Generation
            Given MODE=planning und GOAL="Build auth system"
            When build-ralph-prompt.sh ausgeführt wird
            Then enthält der Output "## Your Goal" mit dem Goal
            And enthält der Output yq Befehle für dynamic-steps
            And enthält der Output "RALPH_COMPLETE"

          Scenario: Executing Prompt Generation
            Given MODE=executing
            And dynamic-steps enthält step-0 mit status=pending
            When build-ralph-prompt.sh ausgeführt wird
            Then enthält der Output "## Current Task: step-0"
            And enthält der Output den Step Prompt
            And enthält der Output "EXIT after this task"

          Scenario: Reflecting Prompt Generation
            Given MODE=reflecting
            And 5 completed Steps
            When build-ralph-prompt.sh ausgeführt wird
            Then enthält der Output "## Completed: 5 steps"
            And enthält der Output Option A für RALPH_COMPLETE
            And enthält der Output Option B für neue Steps

          Scenario: Workflow File Syntax
            Given ralph.yaml existiert
            When yq validiert
            Then ist das YAML syntaktisch korrekt
            And enthält mode: ralph
          ```

          ## Verifikation
          ```bash
          # Script syntax
          bash -n plugins/m42-sprint/scripts/build-ralph-prompt.sh

          # Workflow YAML validieren
          yq '.' .claude/workflows/ralph.yaml

          # Executable check
          test -x plugins/m42-sprint/scripts/build-ralph-prompt.sh
          ```
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Erstelle das Prompt-Builder Script und die Ralph Workflow-Datei.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md
              Lies build-sprint-prompt.sh als Referenz: plugins/m42-sprint/scripts/build-sprint-prompt.sh

              ## Aufgaben

              ### 1. build-ralph-prompt.sh erstellen

              Erstelle plugins/m42-sprint/scripts/build-ralph-prompt.sh:

              **Argumente:**
              - $1: SPRINT_DIR
              - $2: MODE (planning | executing | reflecting)
              - $3: ITERATION

              **Logik:**
              - Lese goal aus PROGRESS.yaml
              - Lese goal-prompt und reflection-prompt aus Workflow (optional)
              - Generiere mode-spezifischen Prompt:

              **planning Mode:**
              - Zeige Goal
              - Instruiere: Analysiere und erstelle Steps
              - Zeige yq Befehle zum Hinzufügen von Steps zu dynamic-steps[]
              - Erwähne RALPH_COMPLETE Keyword

              **executing Mode:**
              - Zeige Goal als Kontext
              - Zeige aktuellen pending Step (ID + Prompt)
              - Instruiere: Führe aus, markiere als completed
              - Erlaube Hinzufügen neuer Steps
              - EXIT nach diesem Task

              **reflecting Mode:**
              - Zeige Goal
              - Zeige Anzahl completed Steps
              - Optionen: RALPH_COMPLETE, neue Steps, oder needs-human

              ### 2. ralph.yaml Workflow erstellen

              Erstelle .claude/workflows/ralph.yaml mit:
              - name: Ralph Mode Workflow
              - mode: ralph
              - goal-prompt: Template für Goal-Analyse
              - reflection-prompt: Template für Reflection
              - per-iteration-hooks: Vordefinierte Hooks (default disabled)
                - learning (m42-signs:learning-extraction)
                - documentation
                - tests

              ### 3. Script executable machen

              ```bash
              chmod +x plugins/m42-sprint/scripts/build-ralph-prompt.sh
              ```

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Planning Prompt Generation
                Given MODE=planning und GOAL="Build auth system"
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Your Goal" mit dem Goal
                And enthält der Output yq Befehle für dynamic-steps
                And enthält der Output "RALPH_COMPLETE"

              Scenario: Executing Prompt Generation
                Given MODE=executing
                And dynamic-steps enthält step-0 mit status=pending
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Current Task: step-0"
                And enthält der Output den Step Prompt
                And enthält der Output "EXIT after this task"

              Scenario: Reflecting Prompt Generation
                Given MODE=reflecting
                And 5 completed Steps
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Completed: 5 steps"
                And enthält der Output Option A für RALPH_COMPLETE
                And enthält der Output Option B für neue Steps

              Scenario: Workflow File Syntax
                Given ralph.yaml existiert
                When yq validiert
                Then ist das YAML syntaktisch korrekt
                And enthält mode: ralph
              ```

              ## Verifikation
              ```bash
              # Script syntax
              bash -n plugins/m42-sprint/scripts/build-ralph-prompt.sh

              # Workflow YAML validieren
              yq '.' .claude/workflows/ralph.yaml

              # Executable check
              test -x plugins/m42-sprint/scripts/build-ralph-prompt.sh
              ```


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-2-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-2

              ## Step Task
              Erstelle das Prompt-Builder Script und die Ralph Workflow-Datei.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md
              Lies build-sprint-prompt.sh als Referenz: plugins/m42-sprint/scripts/build-sprint-prompt.sh

              ## Aufgaben

              ### 1. build-ralph-prompt.sh erstellen

              Erstelle plugins/m42-sprint/scripts/build-ralph-prompt.sh:

              **Argumente:**
              - $1: SPRINT_DIR
              - $2: MODE (planning | executing | reflecting)
              - $3: ITERATION

              **Logik:**
              - Lese goal aus PROGRESS.yaml
              - Lese goal-prompt und reflection-prompt aus Workflow (optional)
              - Generiere mode-spezifischen Prompt:

              **planning Mode:**
              - Zeige Goal
              - Instruiere: Analysiere und erstelle Steps
              - Zeige yq Befehle zum Hinzufügen von Steps zu dynamic-steps[]
              - Erwähne RALPH_COMPLETE Keyword

              **executing Mode:**
              - Zeige Goal als Kontext
              - Zeige aktuellen pending Step (ID + Prompt)
              - Instruiere: Führe aus, markiere als completed
              - Erlaube Hinzufügen neuer Steps
              - EXIT nach diesem Task

              **reflecting Mode:**
              - Zeige Goal
              - Zeige Anzahl completed Steps
              - Optionen: RALPH_COMPLETE, neue Steps, oder needs-human

              ### 2. ralph.yaml Workflow erstellen

              Erstelle .claude/workflows/ralph.yaml mit:
              - name: Ralph Mode Workflow
              - mode: ralph
              - goal-prompt: Template für Goal-Analyse
              - reflection-prompt: Template für Reflection
              - per-iteration-hooks: Vordefinierte Hooks (default disabled)
                - learning (m42-signs:learning-extraction)
                - documentation
                - tests

              ### 3. Script executable machen

              ```bash
              chmod +x plugins/m42-sprint/scripts/build-ralph-prompt.sh
              ```

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Planning Prompt Generation
                Given MODE=planning und GOAL="Build auth system"
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Your Goal" mit dem Goal
                And enthält der Output yq Befehle für dynamic-steps
                And enthält der Output "RALPH_COMPLETE"

              Scenario: Executing Prompt Generation
                Given MODE=executing
                And dynamic-steps enthält step-0 mit status=pending
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Current Task: step-0"
                And enthält der Output den Step Prompt
                And enthält der Output "EXIT after this task"

              Scenario: Reflecting Prompt Generation
                Given MODE=reflecting
                And 5 completed Steps
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Completed: 5 steps"
                And enthält der Output Option A für RALPH_COMPLETE
                And enthält der Output Option B für neue Steps

              Scenario: Workflow File Syntax
                Given ralph.yaml existiert
                When yq validiert
                Then ist das YAML syntaktisch korrekt
                And enthält mode: ralph
              ```

              ## Verifikation
              ```bash
              # Script syntax
              bash -n plugins/m42-sprint/scripts/build-ralph-prompt.sh

              # Workflow YAML validieren
              yq '.' .claude/workflows/ralph.yaml

              # Executable check
              test -x plugins/m42-sprint/scripts/build-ralph-prompt.sh
              ```


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-2-gherkin.md
              git commit -m "plan(step-2): define gherkin scenarios"
              ```
            started-at: "2026-01-18T21:33:44Z"
            completed-at: "2026-01-18T21:34:57Z"
            elapsed: 00:00:57
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Erstelle das Prompt-Builder Script und die Ralph Workflow-Datei.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md
              Lies build-sprint-prompt.sh als Referenz: plugins/m42-sprint/scripts/build-sprint-prompt.sh

              ## Aufgaben

              ### 1. build-ralph-prompt.sh erstellen

              Erstelle plugins/m42-sprint/scripts/build-ralph-prompt.sh:

              **Argumente:**
              - $1: SPRINT_DIR
              - $2: MODE (planning | executing | reflecting)
              - $3: ITERATION

              **Logik:**
              - Lese goal aus PROGRESS.yaml
              - Lese goal-prompt und reflection-prompt aus Workflow (optional)
              - Generiere mode-spezifischen Prompt:

              **planning Mode:**
              - Zeige Goal
              - Instruiere: Analysiere und erstelle Steps
              - Zeige yq Befehle zum Hinzufügen von Steps zu dynamic-steps[]
              - Erwähne RALPH_COMPLETE Keyword

              **executing Mode:**
              - Zeige Goal als Kontext
              - Zeige aktuellen pending Step (ID + Prompt)
              - Instruiere: Führe aus, markiere als completed
              - Erlaube Hinzufügen neuer Steps
              - EXIT nach diesem Task

              **reflecting Mode:**
              - Zeige Goal
              - Zeige Anzahl completed Steps
              - Optionen: RALPH_COMPLETE, neue Steps, oder needs-human

              ### 2. ralph.yaml Workflow erstellen

              Erstelle .claude/workflows/ralph.yaml mit:
              - name: Ralph Mode Workflow
              - mode: ralph
              - goal-prompt: Template für Goal-Analyse
              - reflection-prompt: Template für Reflection
              - per-iteration-hooks: Vordefinierte Hooks (default disabled)
                - learning (m42-signs:learning-extraction)
                - documentation
                - tests

              ### 3. Script executable machen

              ```bash
              chmod +x plugins/m42-sprint/scripts/build-ralph-prompt.sh
              ```

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Planning Prompt Generation
                Given MODE=planning und GOAL="Build auth system"
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Your Goal" mit dem Goal
                And enthält der Output yq Befehle für dynamic-steps
                And enthält der Output "RALPH_COMPLETE"

              Scenario: Executing Prompt Generation
                Given MODE=executing
                And dynamic-steps enthält step-0 mit status=pending
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Current Task: step-0"
                And enthält der Output den Step Prompt
                And enthält der Output "EXIT after this task"

              Scenario: Reflecting Prompt Generation
                Given MODE=reflecting
                And 5 completed Steps
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Completed: 5 steps"
                And enthält der Output Option A für RALPH_COMPLETE
                And enthält der Output Option B für neue Steps

              Scenario: Workflow File Syntax
                Given ralph.yaml existiert
                When yq validiert
                Then ist das YAML syntaktisch korrekt
                And enthält mode: ralph
              ```

              ## Verifikation
              ```bash
              # Script syntax
              bash -n plugins/m42-sprint/scripts/build-ralph-prompt.sh

              # Workflow YAML validieren
              yq '.' .claude/workflows/ralph.yaml

              # Executable check
              test -x plugins/m42-sprint/scripts/build-ralph-prompt.sh
              ```


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-2-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-2-context.md

              ```markdown
              # Step Context: step-2

              ## Task
              Erstelle das Prompt-Builder Script und die Ralph Workflow-Datei.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md
              Lies build-sprint-prompt.sh als Referenz: plugins/m42-sprint/scripts/build-sprint-prompt.sh

              ## Aufgaben

              ### 1. build-ralph-prompt.sh erstellen

              Erstelle plugins/m42-sprint/scripts/build-ralph-prompt.sh:

              **Argumente:**
              - $1: SPRINT_DIR
              - $2: MODE (planning | executing | reflecting)
              - $3: ITERATION

              **Logik:**
              - Lese goal aus PROGRESS.yaml
              - Lese goal-prompt und reflection-prompt aus Workflow (optional)
              - Generiere mode-spezifischen Prompt:

              **planning Mode:**
              - Zeige Goal
              - Instruiere: Analysiere und erstelle Steps
              - Zeige yq Befehle zum Hinzufügen von Steps zu dynamic-steps[]
              - Erwähne RALPH_COMPLETE Keyword

              **executing Mode:**
              - Zeige Goal als Kontext
              - Zeige aktuellen pending Step (ID + Prompt)
              - Instruiere: Führe aus, markiere als completed
              - Erlaube Hinzufügen neuer Steps
              - EXIT nach diesem Task

              **reflecting Mode:**
              - Zeige Goal
              - Zeige Anzahl completed Steps
              - Optionen: RALPH_COMPLETE, neue Steps, oder needs-human

              ### 2. ralph.yaml Workflow erstellen

              Erstelle .claude/workflows/ralph.yaml mit:
              - name: Ralph Mode Workflow
              - mode: ralph
              - goal-prompt: Template für Goal-Analyse
              - reflection-prompt: Template für Reflection
              - per-iteration-hooks: Vordefinierte Hooks (default disabled)
                - learning (m42-signs:learning-extraction)
                - documentation
                - tests

              ### 3. Script executable machen

              ```bash
              chmod +x plugins/m42-sprint/scripts/build-ralph-prompt.sh
              ```

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Planning Prompt Generation
                Given MODE=planning und GOAL="Build auth system"
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Your Goal" mit dem Goal
                And enthält der Output yq Befehle für dynamic-steps
                And enthält der Output "RALPH_COMPLETE"

              Scenario: Executing Prompt Generation
                Given MODE=executing
                And dynamic-steps enthält step-0 mit status=pending
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Current Task: step-0"
                And enthält der Output den Step Prompt
                And enthält der Output "EXIT after this task"

              Scenario: Reflecting Prompt Generation
                Given MODE=reflecting
                And 5 completed Steps
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Completed: 5 steps"
                And enthält der Output Option A für RALPH_COMPLETE
                And enthält der Output Option B für neue Steps

              Scenario: Workflow File Syntax
                Given ralph.yaml existiert
                When yq validiert
                Then ist das YAML syntaktisch korrekt
                And enthält mode: ralph
              ```

              ## Verifikation
              ```bash
              # Script syntax
              bash -n plugins/m42-sprint/scripts/build-ralph-prompt.sh

              # Workflow YAML validieren
              yq '.' .claude/workflows/ralph.yaml

              # Executable check
              test -x plugins/m42-sprint/scripts/build-ralph-prompt.sh
              ```


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-2-context.md
              git commit -m "context(step-2): gather implementation context"
              ```
            started-at: "2026-01-18T21:34:45Z"
            completed-at: "2026-01-18T21:36:48Z"
            elapsed: 00:01:26
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Erstelle das Prompt-Builder Script und die Ralph Workflow-Datei.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md
              Lies build-sprint-prompt.sh als Referenz: plugins/m42-sprint/scripts/build-sprint-prompt.sh

              ## Aufgaben

              ### 1. build-ralph-prompt.sh erstellen

              Erstelle plugins/m42-sprint/scripts/build-ralph-prompt.sh:

              **Argumente:**
              - $1: SPRINT_DIR
              - $2: MODE (planning | executing | reflecting)
              - $3: ITERATION

              **Logik:**
              - Lese goal aus PROGRESS.yaml
              - Lese goal-prompt und reflection-prompt aus Workflow (optional)
              - Generiere mode-spezifischen Prompt:

              **planning Mode:**
              - Zeige Goal
              - Instruiere: Analysiere und erstelle Steps
              - Zeige yq Befehle zum Hinzufügen von Steps zu dynamic-steps[]
              - Erwähne RALPH_COMPLETE Keyword

              **executing Mode:**
              - Zeige Goal als Kontext
              - Zeige aktuellen pending Step (ID + Prompt)
              - Instruiere: Führe aus, markiere als completed
              - Erlaube Hinzufügen neuer Steps
              - EXIT nach diesem Task

              **reflecting Mode:**
              - Zeige Goal
              - Zeige Anzahl completed Steps
              - Optionen: RALPH_COMPLETE, neue Steps, oder needs-human

              ### 2. ralph.yaml Workflow erstellen

              Erstelle .claude/workflows/ralph.yaml mit:
              - name: Ralph Mode Workflow
              - mode: ralph
              - goal-prompt: Template für Goal-Analyse
              - reflection-prompt: Template für Reflection
              - per-iteration-hooks: Vordefinierte Hooks (default disabled)
                - learning (m42-signs:learning-extraction)
                - documentation
                - tests

              ### 3. Script executable machen

              ```bash
              chmod +x plugins/m42-sprint/scripts/build-ralph-prompt.sh
              ```

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Planning Prompt Generation
                Given MODE=planning und GOAL="Build auth system"
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Your Goal" mit dem Goal
                And enthält der Output yq Befehle für dynamic-steps
                And enthält der Output "RALPH_COMPLETE"

              Scenario: Executing Prompt Generation
                Given MODE=executing
                And dynamic-steps enthält step-0 mit status=pending
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Current Task: step-0"
                And enthält der Output den Step Prompt
                And enthält der Output "EXIT after this task"

              Scenario: Reflecting Prompt Generation
                Given MODE=reflecting
                And 5 completed Steps
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Completed: 5 steps"
                And enthält der Output Option A für RALPH_COMPLETE
                And enthält der Output Option B für neue Steps

              Scenario: Workflow File Syntax
                Given ralph.yaml existiert
                When yq validiert
                Then ist das YAML syntaktisch korrekt
                And enthält mode: ralph
              ```

              ## Verifikation
              ```bash
              # Script syntax
              bash -n plugins/m42-sprint/scripts/build-ralph-prompt.sh

              # Workflow YAML validieren
              yq '.' .claude/workflows/ralph.yaml

              # Executable check
              test -x plugins/m42-sprint/scripts/build-ralph-prompt.sh
              ```


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-2-gherkin.md (scenarios to satisfy)
              4. context/step-2-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-2): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-18T21:36:15Z"
            completed-at: "2026-01-18T21:39:21Z"
            elapsed: 00:01:54
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-2-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-2-qa-report.md

              ```markdown
              # QA Report: step-2

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-2-qa-report.md
                 git commit -m "qa(step-2): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-2.\n\n## Context\nRead: artifacts/step-2-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-2-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-2-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-2 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-18T21:38:13Z"
            completed-at: "2026-01-18T21:39:10Z"
            elapsed: 00:00:57
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Erstelle das Prompt-Builder Script und die Ralph Workflow-Datei.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md
              Lies build-sprint-prompt.sh als Referenz: plugins/m42-sprint/scripts/build-sprint-prompt.sh

              ## Aufgaben

              ### 1. build-ralph-prompt.sh erstellen

              Erstelle plugins/m42-sprint/scripts/build-ralph-prompt.sh:

              **Argumente:**
              - $1: SPRINT_DIR
              - $2: MODE (planning | executing | reflecting)
              - $3: ITERATION

              **Logik:**
              - Lese goal aus PROGRESS.yaml
              - Lese goal-prompt und reflection-prompt aus Workflow (optional)
              - Generiere mode-spezifischen Prompt:

              **planning Mode:**
              - Zeige Goal
              - Instruiere: Analysiere und erstelle Steps
              - Zeige yq Befehle zum Hinzufügen von Steps zu dynamic-steps[]
              - Erwähne RALPH_COMPLETE Keyword

              **executing Mode:**
              - Zeige Goal als Kontext
              - Zeige aktuellen pending Step (ID + Prompt)
              - Instruiere: Führe aus, markiere als completed
              - Erlaube Hinzufügen neuer Steps
              - EXIT nach diesem Task

              **reflecting Mode:**
              - Zeige Goal
              - Zeige Anzahl completed Steps
              - Optionen: RALPH_COMPLETE, neue Steps, oder needs-human

              ### 2. ralph.yaml Workflow erstellen

              Erstelle .claude/workflows/ralph.yaml mit:
              - name: Ralph Mode Workflow
              - mode: ralph
              - goal-prompt: Template für Goal-Analyse
              - reflection-prompt: Template für Reflection
              - per-iteration-hooks: Vordefinierte Hooks (default disabled)
                - learning (m42-signs:learning-extraction)
                - documentation
                - tests

              ### 3. Script executable machen

              ```bash
              chmod +x plugins/m42-sprint/scripts/build-ralph-prompt.sh
              ```

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Planning Prompt Generation
                Given MODE=planning und GOAL="Build auth system"
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Your Goal" mit dem Goal
                And enthält der Output yq Befehle für dynamic-steps
                And enthält der Output "RALPH_COMPLETE"

              Scenario: Executing Prompt Generation
                Given MODE=executing
                And dynamic-steps enthält step-0 mit status=pending
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Current Task: step-0"
                And enthält der Output den Step Prompt
                And enthält der Output "EXIT after this task"

              Scenario: Reflecting Prompt Generation
                Given MODE=reflecting
                And 5 completed Steps
                When build-ralph-prompt.sh ausgeführt wird
                Then enthält der Output "## Completed: 5 steps"
                And enthält der Output Option A für RALPH_COMPLETE
                And enthält der Output Option B für neue Steps

              Scenario: Workflow File Syntax
                Given ralph.yaml existiert
                When yq validiert
                Then ist das YAML syntaktisch korrekt
                And enthält mode: ralph
              ```

              ## Verifikation
              ```bash
              # Script syntax
              bash -n plugins/m42-sprint/scripts/build-ralph-prompt.sh

              # Workflow YAML validieren
              yq '.' .claude/workflows/ralph.yaml

              # Executable check
              test -x plugins/m42-sprint/scripts/build-ralph-prompt.sh
              ```


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-2-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-2): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-18T21:39:14Z"
            completed-at: "2026-01-18T21:41:21Z"
            elapsed: 00:01:42
      - id: step-3
        prompt: |
          Integriere Ralph Mode und erstelle Dokumentation.

          ## Kontext
          Lies den Implementierungsplan: context/implementation-plan.md

          ## Aufgaben

          ### 1. Dokumentation erstellen

          Erstelle plugins/m42-sprint/docs/concepts/ralph-mode.md:

          - Übersicht: Was ist Ralph Mode
          - Architektur-Diagramm (aus Plan übernehmen)
          - Hybrid-Konzept erklären (Frei + Deterministisch)
          - SPRINT.yaml Beispiel für Ralph Mode
          - Per-iteration Hooks erklären
          - Exit-Mechanismus (RALPH_COMPLETE)
          - Beispiele

          ### 2. Schema-Dokumentation erweitern

          Erweitere plugins/m42-sprint/skills/orchestrating-sprints/references/progress-schema.md:
          - Ralph Mode spezifische Felder dokumentieren
          - dynamic-steps Schema
          - hook-tasks Schema
          - ralph-exit Schema

          Erweitere plugins/m42-sprint/skills/creating-workflows/references/workflow-schema.md:
          - mode Feld dokumentieren
          - goal-prompt Feld
          - reflection-prompt Feld
          - per-iteration-hooks Feld

          ### 3. SKILL.md Updates

          Update plugins/m42-sprint/skills/orchestrating-sprints/SKILL.md:
          - Ralph Mode als neue Workflow-Option erwähnen
          - Verweis auf ralph-mode.md

          Update plugins/m42-sprint/skills/creating-workflows/SKILL.md:
          - Ralph Mode Workflows erklären
          - Per-iteration hooks dokumentieren

          ### 4. Compiler rebuild

          ```bash
          cd plugins/m42-sprint/compiler && npm run build
          ```

          ## Gherkin Scenarios

          ```gherkin
          Scenario: Ralph Mode Dokumentation existiert
            Given die Implementierung ist abgeschlossen
            When docs/concepts/ralph-mode.md gelesen wird
            Then enthält es Übersicht über Ralph Mode
            And enthält es Architektur-Diagramm
            And enthält es Beispiel SPRINT.yaml

          Scenario: Schema Dokumentation aktualisiert
            Given progress-schema.md existiert
            When der Ralph Mode Abschnitt gelesen wird
            Then dokumentiert er dynamic-steps
            And dokumentiert er hook-tasks
            And dokumentiert er ralph-exit

          Scenario: Workflow Schema erweitert
            Given workflow-schema.md existiert
            When der Ralph Mode Abschnitt gelesen wird
            Then dokumentiert er mode: ralph
            And dokumentiert er per-iteration-hooks

          Scenario: Compiler baut erfolgreich
            When npm run build im compiler Verzeichnis läuft
            Then ist der Exit Code 0
            And existiert dist/index.js
          ```

          ## Verifikation
          ```bash
          # Dokumentation existiert
          test -f plugins/m42-sprint/docs/concepts/ralph-mode.md

          # Compiler build
          cd plugins/m42-sprint/compiler && npm run build

          # Typecheck
          cd plugins/m42-sprint/compiler && npm run typecheck
          ```
        status: in-progress
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Integriere Ralph Mode und erstelle Dokumentation.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md

              ## Aufgaben

              ### 1. Dokumentation erstellen

              Erstelle plugins/m42-sprint/docs/concepts/ralph-mode.md:

              - Übersicht: Was ist Ralph Mode
              - Architektur-Diagramm (aus Plan übernehmen)
              - Hybrid-Konzept erklären (Frei + Deterministisch)
              - SPRINT.yaml Beispiel für Ralph Mode
              - Per-iteration Hooks erklären
              - Exit-Mechanismus (RALPH_COMPLETE)
              - Beispiele

              ### 2. Schema-Dokumentation erweitern

              Erweitere plugins/m42-sprint/skills/orchestrating-sprints/references/progress-schema.md:
              - Ralph Mode spezifische Felder dokumentieren
              - dynamic-steps Schema
              - hook-tasks Schema
              - ralph-exit Schema

              Erweitere plugins/m42-sprint/skills/creating-workflows/references/workflow-schema.md:
              - mode Feld dokumentieren
              - goal-prompt Feld
              - reflection-prompt Feld
              - per-iteration-hooks Feld

              ### 3. SKILL.md Updates

              Update plugins/m42-sprint/skills/orchestrating-sprints/SKILL.md:
              - Ralph Mode als neue Workflow-Option erwähnen
              - Verweis auf ralph-mode.md

              Update plugins/m42-sprint/skills/creating-workflows/SKILL.md:
              - Ralph Mode Workflows erklären
              - Per-iteration hooks dokumentieren

              ### 4. Compiler rebuild

              ```bash
              cd plugins/m42-sprint/compiler && npm run build
              ```

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode Dokumentation existiert
                Given die Implementierung ist abgeschlossen
                When docs/concepts/ralph-mode.md gelesen wird
                Then enthält es Übersicht über Ralph Mode
                And enthält es Architektur-Diagramm
                And enthält es Beispiel SPRINT.yaml

              Scenario: Schema Dokumentation aktualisiert
                Given progress-schema.md existiert
                When der Ralph Mode Abschnitt gelesen wird
                Then dokumentiert er dynamic-steps
                And dokumentiert er hook-tasks
                And dokumentiert er ralph-exit

              Scenario: Workflow Schema erweitert
                Given workflow-schema.md existiert
                When der Ralph Mode Abschnitt gelesen wird
                Then dokumentiert er mode: ralph
                And dokumentiert er per-iteration-hooks

              Scenario: Compiler baut erfolgreich
                When npm run build im compiler Verzeichnis läuft
                Then ist der Exit Code 0
                And existiert dist/index.js
              ```

              ## Verifikation
              ```bash
              # Dokumentation existiert
              test -f plugins/m42-sprint/docs/concepts/ralph-mode.md

              # Compiler build
              cd plugins/m42-sprint/compiler && npm run build

              # Typecheck
              cd plugins/m42-sprint/compiler && npm run typecheck
              ```


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-3-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-3

              ## Step Task
              Integriere Ralph Mode und erstelle Dokumentation.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md

              ## Aufgaben

              ### 1. Dokumentation erstellen

              Erstelle plugins/m42-sprint/docs/concepts/ralph-mode.md:

              - Übersicht: Was ist Ralph Mode
              - Architektur-Diagramm (aus Plan übernehmen)
              - Hybrid-Konzept erklären (Frei + Deterministisch)
              - SPRINT.yaml Beispiel für Ralph Mode
              - Per-iteration Hooks erklären
              - Exit-Mechanismus (RALPH_COMPLETE)
              - Beispiele

              ### 2. Schema-Dokumentation erweitern

              Erweitere plugins/m42-sprint/skills/orchestrating-sprints/references/progress-schema.md:
              - Ralph Mode spezifische Felder dokumentieren
              - dynamic-steps Schema
              - hook-tasks Schema
              - ralph-exit Schema

              Erweitere plugins/m42-sprint/skills/creating-workflows/references/workflow-schema.md:
              - mode Feld dokumentieren
              - goal-prompt Feld
              - reflection-prompt Feld
              - per-iteration-hooks Feld

              ### 3. SKILL.md Updates

              Update plugins/m42-sprint/skills/orchestrating-sprints/SKILL.md:
              - Ralph Mode als neue Workflow-Option erwähnen
              - Verweis auf ralph-mode.md

              Update plugins/m42-sprint/skills/creating-workflows/SKILL.md:
              - Ralph Mode Workflows erklären
              - Per-iteration hooks dokumentieren

              ### 4. Compiler rebuild

              ```bash
              cd plugins/m42-sprint/compiler && npm run build
              ```

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode Dokumentation existiert
                Given die Implementierung ist abgeschlossen
                When docs/concepts/ralph-mode.md gelesen wird
                Then enthält es Übersicht über Ralph Mode
                And enthält es Architektur-Diagramm
                And enthält es Beispiel SPRINT.yaml

              Scenario: Schema Dokumentation aktualisiert
                Given progress-schema.md existiert
                When der Ralph Mode Abschnitt gelesen wird
                Then dokumentiert er dynamic-steps
                And dokumentiert er hook-tasks
                And dokumentiert er ralph-exit

              Scenario: Workflow Schema erweitert
                Given workflow-schema.md existiert
                When der Ralph Mode Abschnitt gelesen wird
                Then dokumentiert er mode: ralph
                And dokumentiert er per-iteration-hooks

              Scenario: Compiler baut erfolgreich
                When npm run build im compiler Verzeichnis läuft
                Then ist der Exit Code 0
                And existiert dist/index.js
              ```

              ## Verifikation
              ```bash
              # Dokumentation existiert
              test -f plugins/m42-sprint/docs/concepts/ralph-mode.md

              # Compiler build
              cd plugins/m42-sprint/compiler && npm run build

              # Typecheck
              cd plugins/m42-sprint/compiler && npm run typecheck
              ```


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-3-gherkin.md
              git commit -m "plan(step-3): define gherkin scenarios"
              ```
            started-at: "2026-01-18T21:40:58Z"
            completed-at: "2026-01-18T21:42:17Z"
            elapsed: 00:01:19
          - id: context
            status: in-progress
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Integriere Ralph Mode und erstelle Dokumentation.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md

              ## Aufgaben

              ### 1. Dokumentation erstellen

              Erstelle plugins/m42-sprint/docs/concepts/ralph-mode.md:

              - Übersicht: Was ist Ralph Mode
              - Architektur-Diagramm (aus Plan übernehmen)
              - Hybrid-Konzept erklären (Frei + Deterministisch)
              - SPRINT.yaml Beispiel für Ralph Mode
              - Per-iteration Hooks erklären
              - Exit-Mechanismus (RALPH_COMPLETE)
              - Beispiele

              ### 2. Schema-Dokumentation erweitern

              Erweitere plugins/m42-sprint/skills/orchestrating-sprints/references/progress-schema.md:
              - Ralph Mode spezifische Felder dokumentieren
              - dynamic-steps Schema
              - hook-tasks Schema
              - ralph-exit Schema

              Erweitere plugins/m42-sprint/skills/creating-workflows/references/workflow-schema.md:
              - mode Feld dokumentieren
              - goal-prompt Feld
              - reflection-prompt Feld
              - per-iteration-hooks Feld

              ### 3. SKILL.md Updates

              Update plugins/m42-sprint/skills/orchestrating-sprints/SKILL.md:
              - Ralph Mode als neue Workflow-Option erwähnen
              - Verweis auf ralph-mode.md

              Update plugins/m42-sprint/skills/creating-workflows/SKILL.md:
              - Ralph Mode Workflows erklären
              - Per-iteration hooks dokumentieren

              ### 4. Compiler rebuild

              ```bash
              cd plugins/m42-sprint/compiler && npm run build
              ```

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode Dokumentation existiert
                Given die Implementierung ist abgeschlossen
                When docs/concepts/ralph-mode.md gelesen wird
                Then enthält es Übersicht über Ralph Mode
                And enthält es Architektur-Diagramm
                And enthält es Beispiel SPRINT.yaml

              Scenario: Schema Dokumentation aktualisiert
                Given progress-schema.md existiert
                When der Ralph Mode Abschnitt gelesen wird
                Then dokumentiert er dynamic-steps
                And dokumentiert er hook-tasks
                And dokumentiert er ralph-exit

              Scenario: Workflow Schema erweitert
                Given workflow-schema.md existiert
                When der Ralph Mode Abschnitt gelesen wird
                Then dokumentiert er mode: ralph
                And dokumentiert er per-iteration-hooks

              Scenario: Compiler baut erfolgreich
                When npm run build im compiler Verzeichnis läuft
                Then ist der Exit Code 0
                And existiert dist/index.js
              ```

              ## Verifikation
              ```bash
              # Dokumentation existiert
              test -f plugins/m42-sprint/docs/concepts/ralph-mode.md

              # Compiler build
              cd plugins/m42-sprint/compiler && npm run build

              # Typecheck
              cd plugins/m42-sprint/compiler && npm run typecheck
              ```


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-3-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-3-context.md

              ```markdown
              # Step Context: step-3

              ## Task
              Integriere Ralph Mode und erstelle Dokumentation.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md

              ## Aufgaben

              ### 1. Dokumentation erstellen

              Erstelle plugins/m42-sprint/docs/concepts/ralph-mode.md:

              - Übersicht: Was ist Ralph Mode
              - Architektur-Diagramm (aus Plan übernehmen)
              - Hybrid-Konzept erklären (Frei + Deterministisch)
              - SPRINT.yaml Beispiel für Ralph Mode
              - Per-iteration Hooks erklären
              - Exit-Mechanismus (RALPH_COMPLETE)
              - Beispiele

              ### 2. Schema-Dokumentation erweitern

              Erweitere plugins/m42-sprint/skills/orchestrating-sprints/references/progress-schema.md:
              - Ralph Mode spezifische Felder dokumentieren
              - dynamic-steps Schema
              - hook-tasks Schema
              - ralph-exit Schema

              Erweitere plugins/m42-sprint/skills/creating-workflows/references/workflow-schema.md:
              - mode Feld dokumentieren
              - goal-prompt Feld
              - reflection-prompt Feld
              - per-iteration-hooks Feld

              ### 3. SKILL.md Updates

              Update plugins/m42-sprint/skills/orchestrating-sprints/SKILL.md:
              - Ralph Mode als neue Workflow-Option erwähnen
              - Verweis auf ralph-mode.md

              Update plugins/m42-sprint/skills/creating-workflows/SKILL.md:
              - Ralph Mode Workflows erklären
              - Per-iteration hooks dokumentieren

              ### 4. Compiler rebuild

              ```bash
              cd plugins/m42-sprint/compiler && npm run build
              ```

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode Dokumentation existiert
                Given die Implementierung ist abgeschlossen
                When docs/concepts/ralph-mode.md gelesen wird
                Then enthält es Übersicht über Ralph Mode
                And enthält es Architektur-Diagramm
                And enthält es Beispiel SPRINT.yaml

              Scenario: Schema Dokumentation aktualisiert
                Given progress-schema.md existiert
                When der Ralph Mode Abschnitt gelesen wird
                Then dokumentiert er dynamic-steps
                And dokumentiert er hook-tasks
                And dokumentiert er ralph-exit

              Scenario: Workflow Schema erweitert
                Given workflow-schema.md existiert
                When der Ralph Mode Abschnitt gelesen wird
                Then dokumentiert er mode: ralph
                And dokumentiert er per-iteration-hooks

              Scenario: Compiler baut erfolgreich
                When npm run build im compiler Verzeichnis läuft
                Then ist der Exit Code 0
                And existiert dist/index.js
              ```

              ## Verifikation
              ```bash
              # Dokumentation existiert
              test -f plugins/m42-sprint/docs/concepts/ralph-mode.md

              # Compiler build
              cd plugins/m42-sprint/compiler && npm run build

              # Typecheck
              cd plugins/m42-sprint/compiler && npm run typecheck
              ```


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-3-context.md
              git commit -m "context(step-3): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Integriere Ralph Mode und erstelle Dokumentation.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md

              ## Aufgaben

              ### 1. Dokumentation erstellen

              Erstelle plugins/m42-sprint/docs/concepts/ralph-mode.md:

              - Übersicht: Was ist Ralph Mode
              - Architektur-Diagramm (aus Plan übernehmen)
              - Hybrid-Konzept erklären (Frei + Deterministisch)
              - SPRINT.yaml Beispiel für Ralph Mode
              - Per-iteration Hooks erklären
              - Exit-Mechanismus (RALPH_COMPLETE)
              - Beispiele

              ### 2. Schema-Dokumentation erweitern

              Erweitere plugins/m42-sprint/skills/orchestrating-sprints/references/progress-schema.md:
              - Ralph Mode spezifische Felder dokumentieren
              - dynamic-steps Schema
              - hook-tasks Schema
              - ralph-exit Schema

              Erweitere plugins/m42-sprint/skills/creating-workflows/references/workflow-schema.md:
              - mode Feld dokumentieren
              - goal-prompt Feld
              - reflection-prompt Feld
              - per-iteration-hooks Feld

              ### 3. SKILL.md Updates

              Update plugins/m42-sprint/skills/orchestrating-sprints/SKILL.md:
              - Ralph Mode als neue Workflow-Option erwähnen
              - Verweis auf ralph-mode.md

              Update plugins/m42-sprint/skills/creating-workflows/SKILL.md:
              - Ralph Mode Workflows erklären
              - Per-iteration hooks dokumentieren

              ### 4. Compiler rebuild

              ```bash
              cd plugins/m42-sprint/compiler && npm run build
              ```

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode Dokumentation existiert
                Given die Implementierung ist abgeschlossen
                When docs/concepts/ralph-mode.md gelesen wird
                Then enthält es Übersicht über Ralph Mode
                And enthält es Architektur-Diagramm
                And enthält es Beispiel SPRINT.yaml

              Scenario: Schema Dokumentation aktualisiert
                Given progress-schema.md existiert
                When der Ralph Mode Abschnitt gelesen wird
                Then dokumentiert er dynamic-steps
                And dokumentiert er hook-tasks
                And dokumentiert er ralph-exit

              Scenario: Workflow Schema erweitert
                Given workflow-schema.md existiert
                When der Ralph Mode Abschnitt gelesen wird
                Then dokumentiert er mode: ralph
                And dokumentiert er per-iteration-hooks

              Scenario: Compiler baut erfolgreich
                When npm run build im compiler Verzeichnis läuft
                Then ist der Exit Code 0
                And existiert dist/index.js
              ```

              ## Verifikation
              ```bash
              # Dokumentation existiert
              test -f plugins/m42-sprint/docs/concepts/ralph-mode.md

              # Compiler build
              cd plugins/m42-sprint/compiler && npm run build

              # Typecheck
              cd plugins/m42-sprint/compiler && npm run typecheck
              ```


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-3-gherkin.md (scenarios to satisfy)
              4. context/step-3-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-3): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-3-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-3-qa-report.md

              ```markdown
              # QA Report: step-3

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-3-qa-report.md
                 git commit -m "qa(step-3): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-3.\n\n## Context\nRead: artifacts/step-3-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-3-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-3-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-3 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Integriere Ralph Mode und erstelle Dokumentation.

              ## Kontext
              Lies den Implementierungsplan: context/implementation-plan.md

              ## Aufgaben

              ### 1. Dokumentation erstellen

              Erstelle plugins/m42-sprint/docs/concepts/ralph-mode.md:

              - Übersicht: Was ist Ralph Mode
              - Architektur-Diagramm (aus Plan übernehmen)
              - Hybrid-Konzept erklären (Frei + Deterministisch)
              - SPRINT.yaml Beispiel für Ralph Mode
              - Per-iteration Hooks erklären
              - Exit-Mechanismus (RALPH_COMPLETE)
              - Beispiele

              ### 2. Schema-Dokumentation erweitern

              Erweitere plugins/m42-sprint/skills/orchestrating-sprints/references/progress-schema.md:
              - Ralph Mode spezifische Felder dokumentieren
              - dynamic-steps Schema
              - hook-tasks Schema
              - ralph-exit Schema

              Erweitere plugins/m42-sprint/skills/creating-workflows/references/workflow-schema.md:
              - mode Feld dokumentieren
              - goal-prompt Feld
              - reflection-prompt Feld
              - per-iteration-hooks Feld

              ### 3. SKILL.md Updates

              Update plugins/m42-sprint/skills/orchestrating-sprints/SKILL.md:
              - Ralph Mode als neue Workflow-Option erwähnen
              - Verweis auf ralph-mode.md

              Update plugins/m42-sprint/skills/creating-workflows/SKILL.md:
              - Ralph Mode Workflows erklären
              - Per-iteration hooks dokumentieren

              ### 4. Compiler rebuild

              ```bash
              cd plugins/m42-sprint/compiler && npm run build
              ```

              ## Gherkin Scenarios

              ```gherkin
              Scenario: Ralph Mode Dokumentation existiert
                Given die Implementierung ist abgeschlossen
                When docs/concepts/ralph-mode.md gelesen wird
                Then enthält es Übersicht über Ralph Mode
                And enthält es Architektur-Diagramm
                And enthält es Beispiel SPRINT.yaml

              Scenario: Schema Dokumentation aktualisiert
                Given progress-schema.md existiert
                When der Ralph Mode Abschnitt gelesen wird
                Then dokumentiert er dynamic-steps
                And dokumentiert er hook-tasks
                And dokumentiert er ralph-exit

              Scenario: Workflow Schema erweitert
                Given workflow-schema.md existiert
                When der Ralph Mode Abschnitt gelesen wird
                Then dokumentiert er mode: ralph
                And dokumentiert er per-iteration-hooks

              Scenario: Compiler baut erfolgreich
                When npm run build im compiler Verzeichnis läuft
                Then ist der Exit Code 0
                And existiert dist/index.js
              ```

              ## Verifikation
              ```bash
              # Dokumentation existiert
              test -f plugins/m42-sprint/docs/concepts/ralph-mode.md

              # Compiler build
              cd plugins/m42-sprint/compiler && npm run build

              # Typecheck
              cd plugins/m42-sprint/compiler && npm run typecheck
              ```


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-3-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-3): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-4
        prompt: >
          Führe einen End-to-End Test der Ralph Mode Implementierung durch.


          ## Aufgaben


          ### 1. Test Sprint erstellen


          Erstelle .claude/sprints/test-ralph-e2e/SPRINT.yaml:

          ```yaml

          workflow: ralph

          goal: |

































































































































































































            Create a simple hello.ts file that exports a greet function.
            The function should take a name and return "Hello, {name}!".
            Include a test file hello.test.ts with basic tests.

          per-iteration-hooks:

































































































































































































            learning:
              enabled: false  # Deaktiviert für Test
          ```


          ### 2. Kompilieren


          ```bash

          node plugins/m42-sprint/compiler/dist/index.js .claude/sprints/test-ralph-e2e -w ".claude/workflows" -v

          ```


          ### 3. PROGRESS.yaml validieren


          Prüfe dass PROGRESS.yaml korrekt generiert wurde:

          - mode: ralph

          - goal vorhanden

          - dynamic-steps: [] (leer)

          - per-iteration-hooks korrekt gemerged


          ### 4. Prompt-Generierung testen


          ```bash

          # Planning Mode

          plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e planning 1


          # Manuell Step hinzufügen für Test

          yq -i '.dynamic-steps += [{"id": "step-0", "prompt": "Create hello.ts", "status": "pending"}]' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


          # Executing Mode

          plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e executing 2


          # Manuell als completed markieren

          yq -i '(.dynamic-steps[] | select(.id == "step-0")).status = "completed"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


          # Reflecting Mode (keine pending Steps mehr)

          plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e reflecting 3

          ```


          ### 5. Sprint Loop Mode Detection testen


          ```bash

          # Prüfe ob Ralph Mode erkannt wird (dry run - nur Mode check)

          MODE=$(yq -r '.mode // "standard"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml)

          echo "Detected mode: $MODE"

          test "$MODE" = "ralph" && echo "✓ Ralph Mode korrekt erkannt"

          ```


          ### 6. Cleanup


          ```bash

          rm -rf .claude/sprints/test-ralph-e2e

          ```


          ## Gherkin Scenarios


          ```gherkin

          Scenario: E2E Compilation

































































































































































































            Given test-ralph-e2e Sprint existiert
            When Compiler ausgeführt wird
            Then wird PROGRESS.yaml mit mode: ralph generiert

          Scenario: E2E Prompt Generation alle Modi

































































































































































































            Given PROGRESS.yaml für Ralph Mode
            When build-ralph-prompt.sh mit planning, executing, reflecting aufgerufen wird
            Then generiert jeder Mode einen korrekten Prompt

          Scenario: E2E Mode Detection

































































































































































































            Given PROGRESS.yaml mit mode: ralph
            When sprint-loop.sh die Mode prüft
            Then erkennt es Ralph Mode

          Scenario: E2E Cleanup

































































































































































































            When der Test abgeschlossen ist
            Then existiert test-ralph-e2e nicht mehr
          ```


          ## Verifikation

          ```bash

          # Alles muss PASS sein

          echo "E2E Test completed"


          # Final project validation

          cd plugins/m42-sprint/compiler && npm run build && npm run typecheck

          ```

        status: pending
        phases:
          - id: plan
            status: pending
            prompt: >
              Generate binary-verifiable gherkin scenarios for this step.


              ## Your Task

              Führe einen End-to-End Test der Ralph Mode Implementierung durch.


              ## Aufgaben


              ### 1. Test Sprint erstellen


              Erstelle .claude/sprints/test-ralph-e2e/SPRINT.yaml:

              ```yaml

              workflow: ralph

              goal: |

































































































































































































                Create a simple hello.ts file that exports a greet function.
                The function should take a name and return "Hello, {name}!".
                Include a test file hello.test.ts with basic tests.

              per-iteration-hooks:

































































































































































































                learning:
                  enabled: false  # Deaktiviert für Test
              ```


              ### 2. Kompilieren


              ```bash

              node plugins/m42-sprint/compiler/dist/index.js .claude/sprints/test-ralph-e2e -w ".claude/workflows" -v

              ```


              ### 3. PROGRESS.yaml validieren


              Prüfe dass PROGRESS.yaml korrekt generiert wurde:

              - mode: ralph

              - goal vorhanden

              - dynamic-steps: [] (leer)

              - per-iteration-hooks korrekt gemerged


              ### 4. Prompt-Generierung testen


              ```bash

              # Planning Mode

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e planning 1


              # Manuell Step hinzufügen für Test

              yq -i '.dynamic-steps += [{"id": "step-0", "prompt": "Create hello.ts", "status": "pending"}]' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


              # Executing Mode

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e executing 2


              # Manuell als completed markieren

              yq -i '(.dynamic-steps[] | select(.id == "step-0")).status = "completed"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


              # Reflecting Mode (keine pending Steps mehr)

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e reflecting 3

              ```


              ### 5. Sprint Loop Mode Detection testen


              ```bash

              # Prüfe ob Ralph Mode erkannt wird (dry run - nur Mode check)

              MODE=$(yq -r '.mode // "standard"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml)

              echo "Detected mode: $MODE"

              test "$MODE" = "ralph" && echo "✓ Ralph Mode korrekt erkannt"

              ```


              ### 6. Cleanup


              ```bash

              rm -rf .claude/sprints/test-ralph-e2e

              ```


              ## Gherkin Scenarios


              ```gherkin

              Scenario: E2E Compilation

































































































































































































                Given test-ralph-e2e Sprint existiert
                When Compiler ausgeführt wird
                Then wird PROGRESS.yaml mit mode: ralph generiert

              Scenario: E2E Prompt Generation alle Modi

































































































































































































                Given PROGRESS.yaml für Ralph Mode
                When build-ralph-prompt.sh mit planning, executing, reflecting aufgerufen wird
                Then generiert jeder Mode einen korrekten Prompt

              Scenario: E2E Mode Detection

































































































































































































                Given PROGRESS.yaml mit mode: ralph
                When sprint-loop.sh die Mode prüft
                Then erkennt es Ralph Mode

              Scenario: E2E Cleanup

































































































































































































                When der Test abgeschlossen ist
                Then existiert test-ralph-e2e nicht mehr
              ```


              ## Verifikation

              ```bash

              # Alles muss PASS sein

              echo "E2E Test completed"


              # Final project validation

              cd plugins/m42-sprint/compiler && npm run build && npm run typecheck

              ```



              ## Shared Context

              Read: context/_shared-context.md (project patterns, conventions, commands)

              Read: context/sprint-plan.md (how this step fits in the sprint)


              ## Instructions

              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.

              Each scenario MUST have:

              1. Clear Given/When/Then structure

              2. An explicit verification command that returns exit code 0 on success

              3. Binary outcome: exactly 1 (pass) or 0 (fail)


              ## Gherkin Format

              Each scenario follows this exact structure:


              ```gherkin

              Scenario: [Descriptive name]

































































































































































































                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ## Example Scenarios


              ### File Existence

              ```gherkin

              Scenario: Source file exists

































































































































































































                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ### TypeScript Compilation

              ```gherkin

              Scenario: TypeScript compiles without errors

































































































































































































                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ### Function Export

              ```gherkin

              Scenario: Login function is exported

































































































































































































                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`

              Pass: Exit code = 0 → Score 1

              Fail: Exit code ≠ 0 → Score 0

              ```


              ### Test Execution

              ```gherkin

              Scenario: Unit tests pass

































































































































































































                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ### Lint Check

              ```gherkin

              Scenario: Code passes linting

































































































































































































                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`

              Pass: Last line = 0 → Score 1

              Fail: Last line ≠ 0 → Score 0

              ```


              ## Output

              Create: artifacts/step-4-gherkin.md


              ```markdown

              # Gherkin Scenarios: step-4


              ## Step Task

              Führe einen End-to-End Test der Ralph Mode Implementierung durch.


              ## Aufgaben


              ### 1. Test Sprint erstellen


              Erstelle .claude/sprints/test-ralph-e2e/SPRINT.yaml:

              ```yaml

              workflow: ralph

              goal: |

































































































































































































                Create a simple hello.ts file that exports a greet function.
                The function should take a name and return "Hello, {name}!".
                Include a test file hello.test.ts with basic tests.

              per-iteration-hooks:

































































































































































































                learning:
                  enabled: false  # Deaktiviert für Test
              ```


              ### 2. Kompilieren


              ```bash

              node plugins/m42-sprint/compiler/dist/index.js .claude/sprints/test-ralph-e2e -w ".claude/workflows" -v

              ```


              ### 3. PROGRESS.yaml validieren


              Prüfe dass PROGRESS.yaml korrekt generiert wurde:

              - mode: ralph

              - goal vorhanden

              - dynamic-steps: [] (leer)

              - per-iteration-hooks korrekt gemerged


              ### 4. Prompt-Generierung testen


              ```bash

              # Planning Mode

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e planning 1


              # Manuell Step hinzufügen für Test

              yq -i '.dynamic-steps += [{"id": "step-0", "prompt": "Create hello.ts", "status": "pending"}]' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


              # Executing Mode

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e executing 2


              # Manuell als completed markieren

              yq -i '(.dynamic-steps[] | select(.id == "step-0")).status = "completed"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


              # Reflecting Mode (keine pending Steps mehr)

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e reflecting 3

              ```


              ### 5. Sprint Loop Mode Detection testen


              ```bash

              # Prüfe ob Ralph Mode erkannt wird (dry run - nur Mode check)

              MODE=$(yq -r '.mode // "standard"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml)

              echo "Detected mode: $MODE"

              test "$MODE" = "ralph" && echo "✓ Ralph Mode korrekt erkannt"

              ```


              ### 6. Cleanup


              ```bash

              rm -rf .claude/sprints/test-ralph-e2e

              ```


              ## Gherkin Scenarios


              ```gherkin

              Scenario: E2E Compilation

































































































































































































                Given test-ralph-e2e Sprint existiert
                When Compiler ausgeführt wird
                Then wird PROGRESS.yaml mit mode: ralph generiert

              Scenario: E2E Prompt Generation alle Modi

































































































































































































                Given PROGRESS.yaml für Ralph Mode
                When build-ralph-prompt.sh mit planning, executing, reflecting aufgerufen wird
                Then generiert jeder Mode einen korrekten Prompt

              Scenario: E2E Mode Detection

































































































































































































                Given PROGRESS.yaml mit mode: ralph
                When sprint-loop.sh die Mode prüft
                Then erkennt es Ralph Mode

              Scenario: E2E Cleanup

































































































































































































                When der Test abgeschlossen ist
                Then existiert test-ralph-e2e nicht mehr
              ```


              ## Verifikation

              ```bash

              # Alles muss PASS sein

              echo "E2E Test completed"


              # Final project validation

              cd plugins/m42-sprint/compiler && npm run build && npm run typecheck

              ```



              ## Success Criteria

              All scenarios must pass (score = 1) for the step to be complete.

              Total scenarios: [N]

              Required score: [N]/[N]


              ---


              ## Scenario 1: [Name]

              [Full gherkin with verification as shown above]


              ---


              ## Scenario 2: [Name]

              ...


              [Continue for 4-8 scenarios]

              ```


              ## Commit

              ```bash

              git add artifacts/step-4-gherkin.md

              git commit -m "plan(step-4): define gherkin scenarios"

              ```

          - id: context
            status: pending
            prompt: >
              Gather step-specific context for implementation.


              ## Your Task

              Führe einen End-to-End Test der Ralph Mode Implementierung durch.


              ## Aufgaben


              ### 1. Test Sprint erstellen


              Erstelle .claude/sprints/test-ralph-e2e/SPRINT.yaml:

              ```yaml

              workflow: ralph

              goal: |

































































































































































































                Create a simple hello.ts file that exports a greet function.
                The function should take a name and return "Hello, {name}!".
                Include a test file hello.test.ts with basic tests.

              per-iteration-hooks:

































































































































































































                learning:
                  enabled: false  # Deaktiviert für Test
              ```


              ### 2. Kompilieren


              ```bash

              node plugins/m42-sprint/compiler/dist/index.js .claude/sprints/test-ralph-e2e -w ".claude/workflows" -v

              ```


              ### 3. PROGRESS.yaml validieren


              Prüfe dass PROGRESS.yaml korrekt generiert wurde:

              - mode: ralph

              - goal vorhanden

              - dynamic-steps: [] (leer)

              - per-iteration-hooks korrekt gemerged


              ### 4. Prompt-Generierung testen


              ```bash

              # Planning Mode

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e planning 1


              # Manuell Step hinzufügen für Test

              yq -i '.dynamic-steps += [{"id": "step-0", "prompt": "Create hello.ts", "status": "pending"}]' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


              # Executing Mode

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e executing 2


              # Manuell als completed markieren

              yq -i '(.dynamic-steps[] | select(.id == "step-0")).status = "completed"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


              # Reflecting Mode (keine pending Steps mehr)

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e reflecting 3

              ```


              ### 5. Sprint Loop Mode Detection testen


              ```bash

              # Prüfe ob Ralph Mode erkannt wird (dry run - nur Mode check)

              MODE=$(yq -r '.mode // "standard"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml)

              echo "Detected mode: $MODE"

              test "$MODE" = "ralph" && echo "✓ Ralph Mode korrekt erkannt"

              ```


              ### 6. Cleanup


              ```bash

              rm -rf .claude/sprints/test-ralph-e2e

              ```


              ## Gherkin Scenarios


              ```gherkin

              Scenario: E2E Compilation

































































































































































































                Given test-ralph-e2e Sprint existiert
                When Compiler ausgeführt wird
                Then wird PROGRESS.yaml mit mode: ralph generiert

              Scenario: E2E Prompt Generation alle Modi

































































































































































































                Given PROGRESS.yaml für Ralph Mode
                When build-ralph-prompt.sh mit planning, executing, reflecting aufgerufen wird
                Then generiert jeder Mode einen korrekten Prompt

              Scenario: E2E Mode Detection

































































































































































































                Given PROGRESS.yaml mit mode: ralph
                When sprint-loop.sh die Mode prüft
                Then erkennt es Ralph Mode

              Scenario: E2E Cleanup

































































































































































































                When der Test abgeschlossen ist
                Then existiert test-ralph-e2e nicht mehr
              ```


              ## Verifikation

              ```bash

              # Alles muss PASS sein

              echo "E2E Test completed"


              # Final project validation

              cd plugins/m42-sprint/compiler && npm run build && npm run typecheck

              ```



              ## Shared Context

              Read: context/_shared-context.md (already has project-wide patterns)

              Read: artifacts/step-4-gherkin.md (scenarios to implement)


              ## Instructions

              Research the specific code areas this step will touch:


              1. **Related Existing Code**

































































































































































































                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**

































































































































































































                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**

































































































































































































                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**

































































































































































































                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output

              Create: context/step-4-context.md


              ```markdown

              # Step Context: step-4


              ## Task

              Führe einen End-to-End Test der Ralph Mode Implementierung durch.


              ## Aufgaben


              ### 1. Test Sprint erstellen


              Erstelle .claude/sprints/test-ralph-e2e/SPRINT.yaml:

              ```yaml

              workflow: ralph

              goal: |

































































































































































































                Create a simple hello.ts file that exports a greet function.
                The function should take a name and return "Hello, {name}!".
                Include a test file hello.test.ts with basic tests.

              per-iteration-hooks:

































































































































































































                learning:
                  enabled: false  # Deaktiviert für Test
              ```


              ### 2. Kompilieren


              ```bash

              node plugins/m42-sprint/compiler/dist/index.js .claude/sprints/test-ralph-e2e -w ".claude/workflows" -v

              ```


              ### 3. PROGRESS.yaml validieren


              Prüfe dass PROGRESS.yaml korrekt generiert wurde:

              - mode: ralph

              - goal vorhanden

              - dynamic-steps: [] (leer)

              - per-iteration-hooks korrekt gemerged


              ### 4. Prompt-Generierung testen


              ```bash

              # Planning Mode

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e planning 1


              # Manuell Step hinzufügen für Test

              yq -i '.dynamic-steps += [{"id": "step-0", "prompt": "Create hello.ts", "status": "pending"}]' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


              # Executing Mode

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e executing 2


              # Manuell als completed markieren

              yq -i '(.dynamic-steps[] | select(.id == "step-0")).status = "completed"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


              # Reflecting Mode (keine pending Steps mehr)

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e reflecting 3

              ```


              ### 5. Sprint Loop Mode Detection testen


              ```bash

              # Prüfe ob Ralph Mode erkannt wird (dry run - nur Mode check)

              MODE=$(yq -r '.mode // "standard"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml)

              echo "Detected mode: $MODE"

              test "$MODE" = "ralph" && echo "✓ Ralph Mode korrekt erkannt"

              ```


              ### 6. Cleanup


              ```bash

              rm -rf .claude/sprints/test-ralph-e2e

              ```


              ## Gherkin Scenarios


              ```gherkin

              Scenario: E2E Compilation

































































































































































































                Given test-ralph-e2e Sprint existiert
                When Compiler ausgeführt wird
                Then wird PROGRESS.yaml mit mode: ralph generiert

              Scenario: E2E Prompt Generation alle Modi

































































































































































































                Given PROGRESS.yaml für Ralph Mode
                When build-ralph-prompt.sh mit planning, executing, reflecting aufgerufen wird
                Then generiert jeder Mode einen korrekten Prompt

              Scenario: E2E Mode Detection

































































































































































































                Given PROGRESS.yaml mit mode: ralph
                When sprint-loop.sh die Mode prüft
                Then erkennt es Ralph Mode

              Scenario: E2E Cleanup

































































































































































































                When der Test abgeschlossen ist
                Then existiert test-ralph-e2e nicht mehr
              ```


              ## Verifikation

              ```bash

              # Alles muss PASS sein

              echo "E2E Test completed"


              # Final project validation

              cd plugins/m42-sprint/compiler && npm run build && npm run typecheck

              ```



              ## Related Code Patterns


              ### Similar Implementation: [path]

              ```typescript

              // Key pattern to follow

              [relevant code snippet]

              ```


              ### Similar Implementation: [path]

              [continue as needed]


              ## Required Imports

              ### Internal

              - `[module]`: [what to import]


              ### External

              - `[package]`: [what to import]


              ## Types/Interfaces to Use

              ```typescript

              // From [source]

              interface [Name] {

































































































































































































                [relevant fields]
              }

              ```


              ## Integration Points

              - Called by: [who will use this]

              - Calls: [what this will call]

              - Tests: [related test files]


              ## Implementation Notes

              - [Specific note 1]

              - [Specific note 2]

              ```


              ## Commit

              ```bash

              git add context/step-4-context.md

              git commit -m "context(step-4): gather implementation context"

              ```

          - id: execute
            status: pending
            prompt: >
              Implement the step following gherkin scenarios and context.


              ## Your Task

              Führe einen End-to-End Test der Ralph Mode Implementierung durch.


              ## Aufgaben


              ### 1. Test Sprint erstellen


              Erstelle .claude/sprints/test-ralph-e2e/SPRINT.yaml:

              ```yaml

              workflow: ralph

              goal: |

































































































































































































                Create a simple hello.ts file that exports a greet function.
                The function should take a name and return "Hello, {name}!".
                Include a test file hello.test.ts with basic tests.

              per-iteration-hooks:

































































































































































































                learning:
                  enabled: false  # Deaktiviert für Test
              ```


              ### 2. Kompilieren


              ```bash

              node plugins/m42-sprint/compiler/dist/index.js .claude/sprints/test-ralph-e2e -w ".claude/workflows" -v

              ```


              ### 3. PROGRESS.yaml validieren


              Prüfe dass PROGRESS.yaml korrekt generiert wurde:

              - mode: ralph

              - goal vorhanden

              - dynamic-steps: [] (leer)

              - per-iteration-hooks korrekt gemerged


              ### 4. Prompt-Generierung testen


              ```bash

              # Planning Mode

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e planning 1


              # Manuell Step hinzufügen für Test

              yq -i '.dynamic-steps += [{"id": "step-0", "prompt": "Create hello.ts", "status": "pending"}]' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


              # Executing Mode

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e executing 2


              # Manuell als completed markieren

              yq -i '(.dynamic-steps[] | select(.id == "step-0")).status = "completed"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


              # Reflecting Mode (keine pending Steps mehr)

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e reflecting 3

              ```


              ### 5. Sprint Loop Mode Detection testen


              ```bash

              # Prüfe ob Ralph Mode erkannt wird (dry run - nur Mode check)

              MODE=$(yq -r '.mode // "standard"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml)

              echo "Detected mode: $MODE"

              test "$MODE" = "ralph" && echo "✓ Ralph Mode korrekt erkannt"

              ```


              ### 6. Cleanup


              ```bash

              rm -rf .claude/sprints/test-ralph-e2e

              ```


              ## Gherkin Scenarios


              ```gherkin

              Scenario: E2E Compilation

































































































































































































                Given test-ralph-e2e Sprint existiert
                When Compiler ausgeführt wird
                Then wird PROGRESS.yaml mit mode: ralph generiert

              Scenario: E2E Prompt Generation alle Modi

































































































































































































                Given PROGRESS.yaml für Ralph Mode
                When build-ralph-prompt.sh mit planning, executing, reflecting aufgerufen wird
                Then generiert jeder Mode einen korrekten Prompt

              Scenario: E2E Mode Detection

































































































































































































                Given PROGRESS.yaml mit mode: ralph
                When sprint-loop.sh die Mode prüft
                Then erkennt es Ralph Mode

              Scenario: E2E Cleanup

































































































































































































                When der Test abgeschlossen ist
                Then existiert test-ralph-e2e nicht mehr
              ```


              ## Verifikation

              ```bash

              # Alles muss PASS sein

              echo "E2E Test completed"


              # Final project validation

              cd plugins/m42-sprint/compiler && npm run build && npm run typecheck

              ```



              ## MUST READ BEFORE IMPLEMENTING

              Read these files in order:

              1. context/_shared-context.md (project patterns, conventions)

              2. context/sprint-plan.md (how this fits in sprint)

              3. artifacts/step-4-gherkin.md (scenarios to satisfy)

              4. context/step-4-context.md (specific patterns, imports)


              ## Implementation Rules


              ### Follow the Gherkin

              Your implementation MUST satisfy ALL gherkin scenarios.

              Each scenario has a verification command - mentally run it to check your work.


              ### Follow the Context

              - Use patterns from similar implementations

              - Import from specified modules

              - Implement required interfaces

              - Follow naming conventions


              ### Code Quality

              - Keep code simple and focused

              - Follow existing patterns exactly

              - No over-engineering or extra abstractions

              - Only implement what's needed for the scenarios


              ### Commits

              Make atomic commits for logical units:

              ```bash

              # After each logical piece

              git add [files]

              git commit -m "[type](step-4): [description]"

              ```


              Types: feat, fix, refactor, test, docs


              ## Implementation Checklist

              Before marking complete, verify:

              - [ ] All files from gherkin scenarios exist

              - [ ] Code follows patterns from context

              - [ ] Imports are correct

              - [ ] No TypeScript errors (run typecheck mentally)

              - [ ] Each scenario's verification should pass


              ## If Blocked

              If you encounter an issue that prevents completion:

              - Document the blocker clearly

              - Set status to needs-human

              - Do NOT leave partial/broken implementation

          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-4-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-4-qa-report.md

              ```markdown
              # QA Report: step-4

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-4-qa-report.md
                 git commit -m "qa(step-4): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-4.\n\n## Context\nRead: artifacts/step-4-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-4-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-4-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-4 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: >
              Final integration verification for the step.


              ## Your Task

              Führe einen End-to-End Test der Ralph Mode Implementierung durch.


              ## Aufgaben


              ### 1. Test Sprint erstellen


              Erstelle .claude/sprints/test-ralph-e2e/SPRINT.yaml:

              ```yaml

              workflow: ralph

              goal: |

































































































































































































                Create a simple hello.ts file that exports a greet function.
                The function should take a name and return "Hello, {name}!".
                Include a test file hello.test.ts with basic tests.

              per-iteration-hooks:

































































































































































































                learning:
                  enabled: false  # Deaktiviert für Test
              ```


              ### 2. Kompilieren


              ```bash

              node plugins/m42-sprint/compiler/dist/index.js .claude/sprints/test-ralph-e2e -w ".claude/workflows" -v

              ```


              ### 3. PROGRESS.yaml validieren


              Prüfe dass PROGRESS.yaml korrekt generiert wurde:

              - mode: ralph

              - goal vorhanden

              - dynamic-steps: [] (leer)

              - per-iteration-hooks korrekt gemerged


              ### 4. Prompt-Generierung testen


              ```bash

              # Planning Mode

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e planning 1


              # Manuell Step hinzufügen für Test

              yq -i '.dynamic-steps += [{"id": "step-0", "prompt": "Create hello.ts", "status": "pending"}]' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


              # Executing Mode

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e executing 2


              # Manuell als completed markieren

              yq -i '(.dynamic-steps[] | select(.id == "step-0")).status = "completed"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml


              # Reflecting Mode (keine pending Steps mehr)

              plugins/m42-sprint/scripts/build-ralph-prompt.sh .claude/sprints/test-ralph-e2e reflecting 3

              ```


              ### 5. Sprint Loop Mode Detection testen


              ```bash

              # Prüfe ob Ralph Mode erkannt wird (dry run - nur Mode check)

              MODE=$(yq -r '.mode // "standard"' .claude/sprints/test-ralph-e2e/PROGRESS.yaml)

              echo "Detected mode: $MODE"

              test "$MODE" = "ralph" && echo "✓ Ralph Mode korrekt erkannt"

              ```


              ### 6. Cleanup


              ```bash

              rm -rf .claude/sprints/test-ralph-e2e

              ```


              ## Gherkin Scenarios


              ```gherkin

              Scenario: E2E Compilation

































































































































































































                Given test-ralph-e2e Sprint existiert
                When Compiler ausgeführt wird
                Then wird PROGRESS.yaml mit mode: ralph generiert

              Scenario: E2E Prompt Generation alle Modi

































































































































































































                Given PROGRESS.yaml für Ralph Mode
                When build-ralph-prompt.sh mit planning, executing, reflecting aufgerufen wird
                Then generiert jeder Mode einen korrekten Prompt

              Scenario: E2E Mode Detection

































































































































































































                Given PROGRESS.yaml mit mode: ralph
                When sprint-loop.sh die Mode prüft
                Then erkennt es Ralph Mode

              Scenario: E2E Cleanup

































































































































































































                When der Test abgeschlossen ist
                Then existiert test-ralph-e2e nicht mehr
              ```


              ## Verifikation

              ```bash

              # Alles muss PASS sein

              echo "E2E Test completed"


              # Final project validation

              cd plugins/m42-sprint/compiler && npm run build && npm run typecheck

              ```



              ## Context

              Read: context/_shared-context.md (build commands)

              Read: artifacts/step-4-qa-report.md (should show PASS)


              ## Step 1: Build Verification

              Run the project build to ensure this step integrates:

              ```bash

              # Use commands from _shared-context.md, typically:

              npm run build

              npm run typecheck

              ```


              ## Step 2: Integration Check

              Verify this step works with the rest of the sprint:

              - Check imports resolve correctly

              - Verify no circular dependencies

              - Ensure types are compatible


              ## Step 3: Smoke Test

              If possible, manually verify the functionality:

              - Run the code path that uses this step's output

              - Check expected behavior matches gherkin scenarios


              ## Step 4: Final Commit

              If all verification passes:

              ```bash

              git add -A

              git status  # Check for any uncommitted changes

              # Only commit if there are changes

              git diff --cached --quiet || git commit -m "verify(step-4): integration verified"

              ```


              ## Outcome

              - If integration passes: Mark step as complete

              - If integration fails: Document the issue and set status to needs-human


              ## Important

              This is the final gate before moving to the next step.

              The step's gherkin scenarios already passed in QA.

              This phase ensures the step works in the broader context.

  - id: final-qa
    status: pending
    prompt: |
      Comprehensive Quality Assurance for the entire sprint.

      ## Context
      Read: context/_shared-context.md for build/test commands
      Read: context/sprint-plan.md for success criteria

      ## Step 1: Full Build Verification
      Run ALL build checks:
      ```bash
      # Identify commands from _shared-context.md, typically:
      npm run build
      npm run typecheck
      npm run lint
      ```

      Record each result in the QA report.

      ## Step 2: Complete Test Suite
      Run the full test suite:
      ```bash
      npm test
      ```

      Record test results and any failures.

      ## Step 3: Integration Verification
      Verify all steps work together:
      - Check that modules properly import each other
      - Verify no circular dependencies introduced
      - Test end-to-end flow if applicable

      ## Step 4: Regression Check
      Compare against main branch:
      ```bash
      git diff main...HEAD --stat
      ```

      Verify:
      - No unintended changes to existing functionality
      - All modified files are expected per sprint-plan.md
      - No temporary/debug code left in

      ## Step 5: Review All Step QA Reports
      Read all artifacts/step-*-qa-report.md files
      - Verify all steps show PASS status
      - Consolidate any warnings or notes

      ## Step 6: Generate Sprint QA Report
      Create: artifacts/sprint-qa-report.md

      ```markdown
      # Sprint QA Report: 2026-01-18_ralph-mode-implementation

      ## Build Verification
      | Check | Result | Output |
      |-------|--------|--------|
      | Build | PASS/FAIL | [summary] |
      | TypeCheck | PASS/FAIL | [summary] |
      | Lint | PASS/FAIL | [summary] |

      ## Test Suite
      | Metric | Value |
      |--------|-------|
      | Tests Run | [count] |
      | Passed | [count] |
      | Failed | [count] |
      | Skipped | [count] |

      ## Integration Verification
      - [ ] Modules import correctly
      - [ ] No circular dependencies
      - [ ] End-to-end flow works

      ## Step QA Summary
      | Step | Status | Notes |
      |------|--------|-------|
      | step-0 | PASS | [brief note] |
      | step-1 | PASS | [brief note] |
      ...

      ## Regression Analysis
      [Summary of changes vs main branch]

      ## Issues Found
      [List any issues, or "None"]

      ## Overall Status: PASS / FAIL
      ```

      ## Step 7: Handle Outcome

      ### If PASS:
      - Commit the QA report:
        ```bash
        git add artifacts/sprint-qa-report.md
        git commit -m "qa: sprint-level verification passed"
        ```

      ### If FAIL:
      - Document specific failures in the report
      - Set status to needs-human with details of what failed
      - The sprint cannot proceed to summary/PR until issues are resolved
  - id: summary
    status: pending
    prompt: |
      Generate sprint summary deliverable for user review.

      ## Context
      Read: context/sprint-plan.md for original goals
      Read: artifacts/sprint-qa-report.md for verification results
      Read: All artifacts/step-*-qa-report.md for step details

      ## Step 1: Collect Commit History
      ```bash
      git log main..HEAD --oneline --no-decorate
      ```

      ## Step 2: Collect File Changes
      ```bash
      git diff main..HEAD --stat
      ```

      ## Step 3: Generate Sprint Summary
      Create: artifacts/sprint-summary.md

      ```markdown
      # Sprint Summary: 2026-01-18_ralph-mode-implementation

      ## What Was Accomplished

      ### Step 0: [Step title]
      - [Key accomplishment 1]
      - [Key accomplishment 2]
      **Files**: [list of files created/modified]

      ### Step 1: [Step title]
      ...

      ## Files Changed
      | File | Change Type | Description |
      |------|-------------|-------------|
      | [path] | Created/Modified/Deleted | [brief description] |

      ## Commits Made
      | Hash | Message |
      |------|---------|
      | [short hash] | [commit message] |

      ## Test Coverage
      [Summary from QA report]

      ## Verification Status
      - Build: PASS
      - TypeCheck: PASS
      - Lint: PASS
      - Tests: [X/Y passed]
      - Integration: PASS

      ## Known Issues / Follow-ups
      [List any, or "None identified"]

      ## Sprint Statistics
      - Steps completed: [X/Y]
      - Total commits: [count]
      - Files changed: [count]
      - Lines added: [count]
      - Lines removed: [count]
      ```

      ## Step 4: Commit Summary
      ```bash
      git add artifacts/sprint-summary.md
      git commit -m "docs: add sprint summary"
      ```
  - id: pr-create
    status: pending
    prompt: "Push the sprint branch and create a pull request.\n\n## Context\nRead: artifacts/sprint-summary.md for PR body content\nRead: artifacts/sprint-qa-report.md for verification checklist\n\n## Step 1: Ensure All Changes Committed\n```bash\ngit status\n```\nIf there are uncommitted changes, commit them appropriately.\n\n## Step 2: Push Branch\n```bash\ngit push -u origin sprint/2026-01-18_ralph-mode-implementation\n```\n\n## Step 3: Create Pull Request\nUse the sprint summary to create a well-structured PR:\n\n```bash\ngh pr create \\\n  --title \"Sprint: 2026-01-18_ralph-mode-implementation\" \\\n  --body \"$(cat <<'EOF'\n## Summary\n[Extract key points from sprint-summary.md]\n\n## Changes\n[List of major changes from summary]\n\n## Verification Checklist\n- [x] Build passes\n- [x] TypeCheck passes\n- [x] Lint passes\n- [x] Tests pass\n- [x] Integration verified\n- [x] No regressions\n\n## Test Results\n[Extract from sprint-qa-report.md]\n\n## Files Changed\n[File list from summary]\n\n---\nFull details in `artifacts/sprint-summary.md`\n\n\U0001F916 Generated with Sprint Workflow\nEOF\n)\"\n```\n\n## Step 4: Output PR URL\nCapture and display the PR URL:\n```bash\ngh pr view --json url -q '.url'\n```\n\n## Output\n- Branch pushed to remote\n- Pull request created\n- PR URL displayed for user\n"
current:
  phase: 1
  step: 3
  sub-phase: 1
stats:
  started-at: "2026-01-18T21:09:19Z"
  total-phases: 30
  completed-phases: 0
  total-steps: 5
  completed-steps: 0
  max-iterations: 1000000
  current-iteration: 17
