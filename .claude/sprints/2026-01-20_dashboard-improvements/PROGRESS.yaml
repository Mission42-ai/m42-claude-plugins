sprint-id: 2026-01-20_dashboard-improvements
status: in-progress
phases:
  - id: worktree-setup
    status: completed
    prompt: |
      Create a git worktree for isolated sprint development.

      ## Why Worktrees?
      Git worktrees allow multiple sprints to run in parallel, each with its own:
      - Working directory
      - Branch
      - Independent development state

      ## Step 1: Check Current Location
      ```bash
      # Determine if we're in a worktree or main repo
      git rev-parse --show-toplevel
      git worktree list
      ```

      ## Step 2: Determine Worktree Location
      The worktree structure should be:
      ```
      project-root/
        trees/
          2026-01-20_dashboard-improvements/   # ← Sprint worktree (we'll create this)
        main/              # or project files directly here
      ```

      If the project root doesn't have a `trees/` directory, create it:
      ```bash
      mkdir -p trees
      ```

      ## Step 3: Create the Worktree
      ```bash
      # Create worktree with new branch
      git worktree add trees/2026-01-20_dashboard-improvements -b sprint/2026-01-20_dashboard-improvements
      ```

      If the branch already exists:
      ```bash
      git worktree add trees/2026-01-20_dashboard-improvements sprint/2026-01-20_dashboard-improvements
      ```

      ## Step 4: Verify Worktree
      ```bash
      cd trees/2026-01-20_dashboard-improvements
      git status
      pwd
      ```

      ## Step 5: Copy Sprint Files to Worktree
      The sprint definition needs to be accessible from the worktree:
      ```bash
      # Copy the sprint directory to the worktree
      cp -r .claude/sprints/2026-01-20_dashboard-improvements trees/2026-01-20_dashboard-improvements/.claude/sprints/
      ```

      ## Step 6: Record Worktree Path
      Create: context/worktree-info.md

      ```markdown
      # Worktree Information

      ## Paths
      - **Worktree**: trees/2026-01-20_dashboard-improvements
      - **Branch**: sprint/2026-01-20_dashboard-improvements
      - **Main repo**: [path to main repo]

      ## Working in the Worktree
      All subsequent phases will work in the worktree directory.

      ## After Sprint Completion
      - Create PR from sprint/2026-01-20_dashboard-improvements branch
      - Clean up worktree: `git worktree remove trees/2026-01-20_dashboard-improvements`
      ```

      ## Output
      - Worktree created at `trees/2026-01-20_dashboard-improvements`
      - Branch `sprint/2026-01-20_dashboard-improvements` created
      - Sprint files copied to worktree
      - Worktree info documented

      ## IMPORTANT
      All subsequent phases must work within the worktree:
      `cd trees/2026-01-20_dashboard-improvements` before any operations.
    started-at: '2026-01-20T21:37:04.236Z'
    completed-at: '2026-01-20T21:38:08.440Z'
  - id: preflight
    status: completed
    prompt: |
      Create comprehensive sprint context for TDD-based plugin development.

      ## Your Task
      Analyze the sprint scope and prepare shared context for all development phases.

      ## Step 0: Switch to Worktree
      ```bash
      # Ensure we're working in the sprint worktree
      cd trees/2026-01-20_dashboard-improvements
      pwd  # Verify location
      ```

      ## Step 1: Verify Branch
      ```bash
      git branch --show-current  # Should show: sprint/2026-01-20_dashboard-improvements
      git status
      ```

      ## Step 2: Analyze Sprint Scope
      Read SPRINT.yaml to understand:
      - All steps and their relationships
      - Overall sprint goal
      - Technical requirements
      - Dependencies between steps

      ## Step 3: Research Project Context
      Investigate the codebase to understand:
      - Project architecture and structure
      - Existing patterns and conventions
      - Test frameworks and patterns used
      - Build/test/lint commands
      - Documentation structure

      ## Step 4: Documentation Inventory
      Catalog existing documentation that may need updates:
      ```bash
      # Find all documentation files
      find . -name "*.md" -type f | grep -E "(README|docs/|GUIDE|REFERENCE)" | head -50
      ```

      Create a documentation map showing what exists and may need updates.

      ## Step 5: Generate Shared Context
      Create: context/_shared-context.md

      ```markdown
      # Shared Sprint Context

      ## Project Architecture
      [High-level architecture overview relevant to this sprint]

      ## Test Patterns
      - Test framework: [framework used]
      - Test file location: [where tests live]
      - Test naming: [naming conventions]
      - Mocking patterns: [how mocks are done]

      ## Key Patterns
      - [Pattern 1]: [Where and how it's used]
      - [Pattern 2]: [Where and how it's used]

      ## Commands
      - Build: `[build command]`
      - Test: `[test command]`
      - Test (watch): `[watch command if available]`
      - Lint: `[lint command]`
      - TypeCheck: `[typecheck command]`

      ## Documentation Structure
      - User Guide: [path or "does not exist"]
      - Getting Started: [path or "does not exist"]
      - Reference: [path or "does not exist"]
      - API Docs: [path or "does not exist"]

      ## Dependencies
      ### Internal Modules
      - [Module]: [Purpose]

      ### External Packages
      - [Package]: [Usage]
      ```

      ## Step 6: Generate Sprint Plan
      Create: context/sprint-plan.md

      ```markdown
      # Sprint Plan: 2026-01-20_dashboard-improvements

      ## Goal
      [One paragraph describing what this sprint accomplishes]

      ## TDD Approach
      Each step follows: RED → GREEN → REFACTOR → QA

      ## Success Criteria
      - [ ] All gherkin scenarios pass (100% score)
      - [ ] All unit tests pass
      - [ ] Build passes
      - [ ] Documentation updated

      ## Step Breakdown

      ### Step 0: [Step title]
      **Scope**: [What this step does]
      **Tests to Write**: [Key test cases]
      **Files**: [Expected files to create/modify]
      **Docs Impact**: [Documentation that may need updates]

      [Continue for all steps]

      ## Documentation Update Plan
      | Doc | Status | Updates Needed |
      |-----|--------|----------------|
      | User Guide | [exists/new] | [description] |
      | Getting Started | [exists/new] | [description] |
      | Reference | [exists/new] | [description] |
      ```

      ## Output
      - Sprint branch created
      - context/_shared-context.md with project patterns
      - context/sprint-plan.md with TDD plan
      - Commit preflight artifacts:
        ```bash
        git add context/
        git commit -m "preflight: add shared context and TDD sprint plan"
        ```
    started-at: '2026-01-20T21:38:10.519Z'
    completed-at: '2026-01-20T21:41:55.808Z'
  - id: development
    status: in-progress
    steps:
      - id: step-0
        prompt: |
          Implement chat-like Live Activity UI showing assistant messages alongside tool calls.

          Requirements:
          1. Extend ActivityEvent type in activity-types.ts:
             - Add 'assistant' event type
             - Add text, isThinking fields

          2. Modify TranscriptionWatcher in transcription-watcher.ts:
             - Parse content_block_start with type "text"
             - Parse content_block_delta with text_delta
             - Accumulate text deltas with 500ms debouncing
             - Emit ActivityEvent with type='assistant'

          3. Update page.ts renderLiveActivity():
             - Assistant messages: chat bubble style, full content
             - Tool calls: grey/secondary style with better descriptions
             - TodoWrite → "Updated task list"
             - Edit → "Editing {filename}"
             - Read → "Reading {filename}"

          4. Add CSS styling for chat-like appearance

          Files:
          - plugins/m42-sprint/compiler/src/status-server/activity-types.ts
          - plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts
          - plugins/m42-sprint/compiler/src/status-server/page.ts

          Verification: Start a sprint and verify assistant messages appear in chat style
        status: completed
        phases:
          - id: context
            status: completed
            prompt: |
              Prepare context for TDD development.

              ## Step 0: Ensure Working in Worktree (if applicable)
              ```bash
              # If trees directory exists, switch to worktree
              if [ -d "trees/2026-01-20_dashboard-improvements" ]; then
                cd trees/2026-01-20_dashboard-improvements
              fi
              pwd
              git branch --show-current
              ```

              ## Step 1: Read Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Step 2: Understand the Step
              Implement chat-like Live Activity UI showing assistant messages alongside tool calls.

              Requirements:
              1. Extend ActivityEvent type in activity-types.ts:
                 - Add 'assistant' event type
                 - Add text, isThinking fields

              2. Modify TranscriptionWatcher in transcription-watcher.ts:
                 - Parse content_block_start with type "text"
                 - Parse content_block_delta with text_delta
                 - Accumulate text deltas with 500ms debouncing
                 - Emit ActivityEvent with type='assistant'

              3. Update page.ts renderLiveActivity():
                 - Assistant messages: chat bubble style, full content
                 - Tool calls: grey/secondary style with better descriptions
                 - TodoWrite → "Updated task list"
                 - Edit → "Editing {filename}"
                 - Read → "Reading {filename}"

              4. Add CSS styling for chat-like appearance

              Files:
              - plugins/m42-sprint/compiler/src/status-server/activity-types.ts
              - plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts

              Verification: Start a sprint and verify assistant messages appear in chat style


              ## Output
              Confirm understanding of:
              - Test patterns and locations
              - Build/test commands
              - The step requirements
            started-at: '2026-01-20T21:41:57.876Z'
            completed-at: '2026-01-20T21:42:42.141Z'
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              Implement chat-like Live Activity UI showing assistant messages alongside tool calls.

              Requirements:
              1. Extend ActivityEvent type in activity-types.ts:
                 - Add 'assistant' event type
                 - Add text, isThinking fields

              2. Modify TranscriptionWatcher in transcription-watcher.ts:
                 - Parse content_block_start with type "text"
                 - Parse content_block_delta with text_delta
                 - Accumulate text deltas with 500ms debouncing
                 - Emit ActivityEvent with type='assistant'

              3. Update page.ts renderLiveActivity():
                 - Assistant messages: chat bubble style, full content
                 - Tool calls: grey/secondary style with better descriptions
                 - TodoWrite → "Updated task list"
                 - Edit → "Editing {filename}"
                 - Read → "Reading {filename}"

              4. Add CSS styling for chat-like appearance

              Files:
              - plugins/m42-sprint/compiler/src/status-server/activity-types.ts
              - plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts

              Verification: Start a sprint and verify assistant messages appear in chat style


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/step-0-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-0

              ## Step Task
              Implement chat-like Live Activity UI showing assistant messages alongside tool calls.

              Requirements:
              1. Extend ActivityEvent type in activity-types.ts:
                 - Add 'assistant' event type
                 - Add text, isThinking fields

              2. Modify TranscriptionWatcher in transcription-watcher.ts:
                 - Parse content_block_start with type "text"
                 - Parse content_block_delta with text_delta
                 - Accumulate text deltas with 500ms debouncing
                 - Emit ActivityEvent with type='assistant'

              3. Update page.ts renderLiveActivity():
                 - Assistant messages: chat bubble style, full content
                 - Tool calls: grey/secondary style with better descriptions
                 - TodoWrite → "Updated task list"
                 - Edit → "Editing {filename}"
                 - Read → "Reading {filename}"

              4. Add CSS styling for chat-like appearance

              Files:
              - plugins/m42-sprint/compiler/src/status-server/activity-types.ts
              - plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts

              Verification: Start a sprint and verify assistant messages appear in chat style


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/step-0-gherkin.md
              git commit -m "test(step-0): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: '2026-01-20T21:42:44.206Z'
            completed-at: '2026-01-20T21:49:42.446Z'
          - id: green-context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Implement chat-like Live Activity UI showing assistant messages alongside tool calls.

              Requirements:
              1. Extend ActivityEvent type in activity-types.ts:
                 - Add 'assistant' event type
                 - Add text, isThinking fields

              2. Modify TranscriptionWatcher in transcription-watcher.ts:
                 - Parse content_block_start with type "text"
                 - Parse content_block_delta with text_delta
                 - Accumulate text deltas with 500ms debouncing
                 - Emit ActivityEvent with type='assistant'

              3. Update page.ts renderLiveActivity():
                 - Assistant messages: chat bubble style, full content
                 - Tool calls: grey/secondary style with better descriptions
                 - TodoWrite → "Updated task list"
                 - Edit → "Editing {filename}"
                 - Read → "Reading {filename}"

              4. Add CSS styling for chat-like appearance

              Files:
              - plugins/m42-sprint/compiler/src/status-server/activity-types.ts
              - plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts

              Verification: Start a sprint and verify assistant messages appear in chat style


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/step-0-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/step-0-context.md

              ```markdown
              # Step Context: step-0

              ## Task
              Implement chat-like Live Activity UI showing assistant messages alongside tool calls.

              Requirements:
              1. Extend ActivityEvent type in activity-types.ts:
                 - Add 'assistant' event type
                 - Add text, isThinking fields

              2. Modify TranscriptionWatcher in transcription-watcher.ts:
                 - Parse content_block_start with type "text"
                 - Parse content_block_delta with text_delta
                 - Accumulate text deltas with 500ms debouncing
                 - Emit ActivityEvent with type='assistant'

              3. Update page.ts renderLiveActivity():
                 - Assistant messages: chat bubble style, full content
                 - Tool calls: grey/secondary style with better descriptions
                 - TodoWrite → "Updated task list"
                 - Edit → "Editing {filename}"
                 - Read → "Reading {filename}"

              4. Add CSS styling for chat-like appearance

              Files:
              - plugins/m42-sprint/compiler/src/status-server/activity-types.ts
              - plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts

              Verification: Start a sprint and verify assistant messages appear in chat style


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/step-0-context.md
              git commit -m "context(step-0): gather implementation context"
              ```
            started-at: '2026-01-20T21:49:44.525Z'
            completed-at: '2026-01-20T21:51:25.461Z'
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              Implement chat-like Live Activity UI showing assistant messages alongside tool calls.

              Requirements:
              1. Extend ActivityEvent type in activity-types.ts:
                 - Add 'assistant' event type
                 - Add text, isThinking fields

              2. Modify TranscriptionWatcher in transcription-watcher.ts:
                 - Parse content_block_start with type "text"
                 - Parse content_block_delta with text_delta
                 - Accumulate text deltas with 500ms debouncing
                 - Emit ActivityEvent with type='assistant'

              3. Update page.ts renderLiveActivity():
                 - Assistant messages: chat bubble style, full content
                 - Tool calls: grey/secondary style with better descriptions
                 - TodoWrite → "Updated task list"
                 - Edit → "Editing {filename}"
                 - Read → "Reading {filename}"

              4. Add CSS styling for chat-like appearance

              Files:
              - plugins/m42-sprint/compiler/src/status-server/activity-types.ts
              - plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts

              Verification: Start a sprint and verify assistant messages appear in chat style


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/step-0-gherkin.md (scenarios to satisfy)
              3. context/step-0-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(step-0): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: '2026-01-20T21:51:27.530Z'
            completed-at: '2026-01-20T21:58:09.217Z'
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              Implement chat-like Live Activity UI showing assistant messages alongside tool calls.

              Requirements:
              1. Extend ActivityEvent type in activity-types.ts:
                 - Add 'assistant' event type
                 - Add text, isThinking fields

              2. Modify TranscriptionWatcher in transcription-watcher.ts:
                 - Parse content_block_start with type "text"
                 - Parse content_block_delta with text_delta
                 - Accumulate text deltas with 500ms debouncing
                 - Emit ActivityEvent with type='assistant'

              3. Update page.ts renderLiveActivity():
                 - Assistant messages: chat bubble style, full content
                 - Tool calls: grey/secondary style with better descriptions
                 - TodoWrite → "Updated task list"
                 - Edit → "Editing {filename}"
                 - Read → "Reading {filename}"

              4. Add CSS styling for chat-like appearance

              Files:
              - plugins/m42-sprint/compiler/src/status-server/activity-types.ts
              - plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts

              Verification: Start a sprint and verify assistant messages appear in chat style


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/step-0-context.md (target patterns)
              Read: artifacts/step-0-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(step-0): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: '2026-01-20T21:58:11.290Z'
            completed-at: '2026-01-20T22:02:29.965Z'
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-0-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/step-0-qa-report.md

              ```markdown
              # QA Report: step-0

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/step-0-qa-report.md
              git commit -m "qa(step-0): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for step-0.\n\nRead: artifacts/step-0-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/step-0-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: '2026-01-20T22:02:32.021Z'
            completed-at: '2026-01-20T22:05:38.165Z'
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Implement chat-like Live Activity UI showing assistant messages alongside tool calls.

              Requirements:
              1. Extend ActivityEvent type in activity-types.ts:
                 - Add 'assistant' event type
                 - Add text, isThinking fields

              2. Modify TranscriptionWatcher in transcription-watcher.ts:
                 - Parse content_block_start with type "text"
                 - Parse content_block_delta with text_delta
                 - Accumulate text deltas with 500ms debouncing
                 - Emit ActivityEvent with type='assistant'

              3. Update page.ts renderLiveActivity():
                 - Assistant messages: chat bubble style, full content
                 - Tool calls: grey/secondary style with better descriptions
                 - TodoWrite → "Updated task list"
                 - Edit → "Editing {filename}"
                 - Read → "Reading {filename}"

              4. Add CSS styling for chat-like appearance

              Files:
              - plugins/m42-sprint/compiler/src/status-server/activity-types.ts
              - plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts

              Verification: Start a sprint and verify assistant messages appear in chat style


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-0-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(step-0): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: '2026-01-20T22:05:40.229Z'
            completed-at: '2026-01-20T22:07:49.918Z'
        started-at: '2026-01-20T21:41:57.876Z'
        completed-at: '2026-01-20T22:07:49.918Z'
      - id: step-1
        prompt: |
          Add elapsed time display and prominent progress indicators.

          Requirements:
          1. Calculate elapsed in transforms.ts:
             - In buildSubPhaseNode(), buildStepNode(), buildTopPhaseNode()
             - If elapsed not set but started-at exists → calculate using calculateElapsed()

          2. Add prominent timer in page.ts:
             - Add sprint-timer div in header with ⏱ icon
             - Format as HH:MM:SS
             - Update every second
             - Large font, blue accent color

          3. Add step progress counter:
             - Count total steps from phases in transforms.ts
             - Add totalSteps to SprintHeader
             - Display "Step X of Y" in header

          Files:
          - plugins/m42-sprint/compiler/src/status-server/transforms.ts
          - plugins/m42-sprint/compiler/src/status-server/page.ts
          - plugins/m42-sprint/compiler/src/status-server/status-types.ts

          Verification:
          - Steps show elapsed time in sidebar
          - Prominent HH:MM:SS timer in header
          - "Step X of Y" displays
        status: completed
        phases:
          - id: context
            status: completed
            prompt: |
              Prepare context for TDD development.

              ## Step 0: Ensure Working in Worktree (if applicable)
              ```bash
              # If trees directory exists, switch to worktree
              if [ -d "trees/2026-01-20_dashboard-improvements" ]; then
                cd trees/2026-01-20_dashboard-improvements
              fi
              pwd
              git branch --show-current
              ```

              ## Step 1: Read Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Step 2: Understand the Step
              Add elapsed time display and prominent progress indicators.

              Requirements:
              1. Calculate elapsed in transforms.ts:
                 - In buildSubPhaseNode(), buildStepNode(), buildTopPhaseNode()
                 - If elapsed not set but started-at exists → calculate using calculateElapsed()

              2. Add prominent timer in page.ts:
                 - Add sprint-timer div in header with ⏱ icon
                 - Format as HH:MM:SS
                 - Update every second
                 - Large font, blue accent color

              3. Add step progress counter:
                 - Count total steps from phases in transforms.ts
                 - Add totalSteps to SprintHeader
                 - Display "Step X of Y" in header

              Files:
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/status-types.ts

              Verification:
              - Steps show elapsed time in sidebar
              - Prominent HH:MM:SS timer in header
              - "Step X of Y" displays


              ## Output
              Confirm understanding of:
              - Test patterns and locations
              - Build/test commands
              - The step requirements
            started-at: '2026-01-20T22:07:51.992Z'
            completed-at: '2026-01-20T22:09:17.970Z'
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              Add elapsed time display and prominent progress indicators.

              Requirements:
              1. Calculate elapsed in transforms.ts:
                 - In buildSubPhaseNode(), buildStepNode(), buildTopPhaseNode()
                 - If elapsed not set but started-at exists → calculate using calculateElapsed()

              2. Add prominent timer in page.ts:
                 - Add sprint-timer div in header with ⏱ icon
                 - Format as HH:MM:SS
                 - Update every second
                 - Large font, blue accent color

              3. Add step progress counter:
                 - Count total steps from phases in transforms.ts
                 - Add totalSteps to SprintHeader
                 - Display "Step X of Y" in header

              Files:
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/status-types.ts

              Verification:
              - Steps show elapsed time in sidebar
              - Prominent HH:MM:SS timer in header
              - "Step X of Y" displays


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/step-1-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-1

              ## Step Task
              Add elapsed time display and prominent progress indicators.

              Requirements:
              1. Calculate elapsed in transforms.ts:
                 - In buildSubPhaseNode(), buildStepNode(), buildTopPhaseNode()
                 - If elapsed not set but started-at exists → calculate using calculateElapsed()

              2. Add prominent timer in page.ts:
                 - Add sprint-timer div in header with ⏱ icon
                 - Format as HH:MM:SS
                 - Update every second
                 - Large font, blue accent color

              3. Add step progress counter:
                 - Count total steps from phases in transforms.ts
                 - Add totalSteps to SprintHeader
                 - Display "Step X of Y" in header

              Files:
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/status-types.ts

              Verification:
              - Steps show elapsed time in sidebar
              - Prominent HH:MM:SS timer in header
              - "Step X of Y" displays


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/step-1-gherkin.md
              git commit -m "test(step-1): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: '2026-01-20T22:09:20.064Z'
            completed-at: '2026-01-20T22:13:47.868Z'
          - id: green-context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Add elapsed time display and prominent progress indicators.

              Requirements:
              1. Calculate elapsed in transforms.ts:
                 - In buildSubPhaseNode(), buildStepNode(), buildTopPhaseNode()
                 - If elapsed not set but started-at exists → calculate using calculateElapsed()

              2. Add prominent timer in page.ts:
                 - Add sprint-timer div in header with ⏱ icon
                 - Format as HH:MM:SS
                 - Update every second
                 - Large font, blue accent color

              3. Add step progress counter:
                 - Count total steps from phases in transforms.ts
                 - Add totalSteps to SprintHeader
                 - Display "Step X of Y" in header

              Files:
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/status-types.ts

              Verification:
              - Steps show elapsed time in sidebar
              - Prominent HH:MM:SS timer in header
              - "Step X of Y" displays


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/step-1-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/step-1-context.md

              ```markdown
              # Step Context: step-1

              ## Task
              Add elapsed time display and prominent progress indicators.

              Requirements:
              1. Calculate elapsed in transforms.ts:
                 - In buildSubPhaseNode(), buildStepNode(), buildTopPhaseNode()
                 - If elapsed not set but started-at exists → calculate using calculateElapsed()

              2. Add prominent timer in page.ts:
                 - Add sprint-timer div in header with ⏱ icon
                 - Format as HH:MM:SS
                 - Update every second
                 - Large font, blue accent color

              3. Add step progress counter:
                 - Count total steps from phases in transforms.ts
                 - Add totalSteps to SprintHeader
                 - Display "Step X of Y" in header

              Files:
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/status-types.ts

              Verification:
              - Steps show elapsed time in sidebar
              - Prominent HH:MM:SS timer in header
              - "Step X of Y" displays


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/step-1-context.md
              git commit -m "context(step-1): gather implementation context"
              ```
            started-at: '2026-01-20T22:13:49.937Z'
            completed-at: '2026-01-20T22:16:02.534Z'
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              Add elapsed time display and prominent progress indicators.

              Requirements:
              1. Calculate elapsed in transforms.ts:
                 - In buildSubPhaseNode(), buildStepNode(), buildTopPhaseNode()
                 - If elapsed not set but started-at exists → calculate using calculateElapsed()

              2. Add prominent timer in page.ts:
                 - Add sprint-timer div in header with ⏱ icon
                 - Format as HH:MM:SS
                 - Update every second
                 - Large font, blue accent color

              3. Add step progress counter:
                 - Count total steps from phases in transforms.ts
                 - Add totalSteps to SprintHeader
                 - Display "Step X of Y" in header

              Files:
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/status-types.ts

              Verification:
              - Steps show elapsed time in sidebar
              - Prominent HH:MM:SS timer in header
              - "Step X of Y" displays


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/step-1-gherkin.md (scenarios to satisfy)
              3. context/step-1-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(step-1): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: '2026-01-20T22:16:04.591Z'
            completed-at: '2026-01-20T22:19:40.314Z'
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              Add elapsed time display and prominent progress indicators.

              Requirements:
              1. Calculate elapsed in transforms.ts:
                 - In buildSubPhaseNode(), buildStepNode(), buildTopPhaseNode()
                 - If elapsed not set but started-at exists → calculate using calculateElapsed()

              2. Add prominent timer in page.ts:
                 - Add sprint-timer div in header with ⏱ icon
                 - Format as HH:MM:SS
                 - Update every second
                 - Large font, blue accent color

              3. Add step progress counter:
                 - Count total steps from phases in transforms.ts
                 - Add totalSteps to SprintHeader
                 - Display "Step X of Y" in header

              Files:
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/status-types.ts

              Verification:
              - Steps show elapsed time in sidebar
              - Prominent HH:MM:SS timer in header
              - "Step X of Y" displays


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/step-1-context.md (target patterns)
              Read: artifacts/step-1-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(step-1): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: '2026-01-20T22:19:42.391Z'
            completed-at: '2026-01-20T22:22:32.304Z'
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-1-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/step-1-qa-report.md

              ```markdown
              # QA Report: step-1

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/step-1-qa-report.md
              git commit -m "qa(step-1): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for step-1.\n\nRead: artifacts/step-1-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/step-1-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: '2026-01-20T22:22:34.381Z'
            completed-at: '2026-01-20T22:23:53.036Z'
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Add elapsed time display and prominent progress indicators.

              Requirements:
              1. Calculate elapsed in transforms.ts:
                 - In buildSubPhaseNode(), buildStepNode(), buildTopPhaseNode()
                 - If elapsed not set but started-at exists → calculate using calculateElapsed()

              2. Add prominent timer in page.ts:
                 - Add sprint-timer div in header with ⏱ icon
                 - Format as HH:MM:SS
                 - Update every second
                 - Large font, blue accent color

              3. Add step progress counter:
                 - Count total steps from phases in transforms.ts
                 - Add totalSteps to SprintHeader
                 - Display "Step X of Y" in header

              Files:
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/status-types.ts

              Verification:
              - Steps show elapsed time in sidebar
              - Prominent HH:MM:SS timer in header
              - "Step X of Y" displays


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-1-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(step-1): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: '2026-01-20T22:23:55.101Z'
            completed-at: '2026-01-20T22:26:45.159Z'
        started-at: '2026-01-20T22:07:51.992Z'
        completed-at: '2026-01-20T22:26:45.159Z'
      - id: step-2
        prompt: |
          Fix sprint dropdown switching and add stale sprint detection.

          Requirements:
          1. Fix dropdown in page.ts:
             - Close existing SSE connection on change
             - Navigate to /sprint/{id} with full page reload
             - Add loading indicator

          2. Add heartbeat in loop.ts:
             - Write last-activity timestamp each iteration
             - Add process.on('SIGTERM') handler
             - Add process.on('SIGINT') handler
             - Mark sprint as 'interrupted' before exit

          3. Detect staleness in transforms.ts:
             - If in-progress but last-activity > 15 min → stale
             - Add isStale flag to status

          4. Show stale indicator in page.ts:
             - Display "Stale" badge next to status
             - Show "Resume Sprint" button

          5. Add resume endpoint in server.ts:
             - Add /api/sprint/:id/resume endpoint
             - Trigger sprint loop restart

          Files:
          - plugins/m42-sprint/compiler/src/status-server/page.ts
          - plugins/m42-sprint/compiler/src/status-server/server.ts
          - plugins/m42-sprint/compiler/src/status-server/transforms.ts
          - plugins/m42-sprint/runtime/src/loop.ts
          - plugins/m42-sprint/runtime/src/cli.ts

          Verification:
          - Switch sprints via dropdown, verify correct data loads
          - Kill sprint process, wait 15 min, verify "Stale" badge + "Resume" button
        status: completed
        phases:
          - id: context
            status: completed
            prompt: |
              Prepare context for TDD development.

              ## Step 0: Ensure Working in Worktree (if applicable)
              ```bash
              # If trees directory exists, switch to worktree
              if [ -d "trees/2026-01-20_dashboard-improvements" ]; then
                cd trees/2026-01-20_dashboard-improvements
              fi
              pwd
              git branch --show-current
              ```

              ## Step 1: Read Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Step 2: Understand the Step
              Fix sprint dropdown switching and add stale sprint detection.

              Requirements:
              1. Fix dropdown in page.ts:
                 - Close existing SSE connection on change
                 - Navigate to /sprint/{id} with full page reload
                 - Add loading indicator

              2. Add heartbeat in loop.ts:
                 - Write last-activity timestamp each iteration
                 - Add process.on('SIGTERM') handler
                 - Add process.on('SIGINT') handler
                 - Mark sprint as 'interrupted' before exit

              3. Detect staleness in transforms.ts:
                 - If in-progress but last-activity > 15 min → stale
                 - Add isStale flag to status

              4. Show stale indicator in page.ts:
                 - Display "Stale" badge next to status
                 - Show "Resume Sprint" button

              5. Add resume endpoint in server.ts:
                 - Add /api/sprint/:id/resume endpoint
                 - Trigger sprint loop restart

              Files:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/cli.ts

              Verification:
              - Switch sprints via dropdown, verify correct data loads
              - Kill sprint process, wait 15 min, verify "Stale" badge + "Resume" button


              ## Output
              Confirm understanding of:
              - Test patterns and locations
              - Build/test commands
              - The step requirements
            started-at: '2026-01-20T22:26:47.281Z'
            completed-at: '2026-01-20T22:27:10.335Z'
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              Fix sprint dropdown switching and add stale sprint detection.

              Requirements:
              1. Fix dropdown in page.ts:
                 - Close existing SSE connection on change
                 - Navigate to /sprint/{id} with full page reload
                 - Add loading indicator

              2. Add heartbeat in loop.ts:
                 - Write last-activity timestamp each iteration
                 - Add process.on('SIGTERM') handler
                 - Add process.on('SIGINT') handler
                 - Mark sprint as 'interrupted' before exit

              3. Detect staleness in transforms.ts:
                 - If in-progress but last-activity > 15 min → stale
                 - Add isStale flag to status

              4. Show stale indicator in page.ts:
                 - Display "Stale" badge next to status
                 - Show "Resume Sprint" button

              5. Add resume endpoint in server.ts:
                 - Add /api/sprint/:id/resume endpoint
                 - Trigger sprint loop restart

              Files:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/cli.ts

              Verification:
              - Switch sprints via dropdown, verify correct data loads
              - Kill sprint process, wait 15 min, verify "Stale" badge + "Resume" button


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/step-2-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-2

              ## Step Task
              Fix sprint dropdown switching and add stale sprint detection.

              Requirements:
              1. Fix dropdown in page.ts:
                 - Close existing SSE connection on change
                 - Navigate to /sprint/{id} with full page reload
                 - Add loading indicator

              2. Add heartbeat in loop.ts:
                 - Write last-activity timestamp each iteration
                 - Add process.on('SIGTERM') handler
                 - Add process.on('SIGINT') handler
                 - Mark sprint as 'interrupted' before exit

              3. Detect staleness in transforms.ts:
                 - If in-progress but last-activity > 15 min → stale
                 - Add isStale flag to status

              4. Show stale indicator in page.ts:
                 - Display "Stale" badge next to status
                 - Show "Resume Sprint" button

              5. Add resume endpoint in server.ts:
                 - Add /api/sprint/:id/resume endpoint
                 - Trigger sprint loop restart

              Files:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/cli.ts

              Verification:
              - Switch sprints via dropdown, verify correct data loads
              - Kill sprint process, wait 15 min, verify "Stale" badge + "Resume" button


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/step-2-gherkin.md
              git commit -m "test(step-2): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: '2026-01-20T22:27:10.666Z'
            completed-at: '2026-01-20T22:33:05.377Z'
          - id: green-context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Fix sprint dropdown switching and add stale sprint detection.

              Requirements:
              1. Fix dropdown in page.ts:
                 - Close existing SSE connection on change
                 - Navigate to /sprint/{id} with full page reload
                 - Add loading indicator

              2. Add heartbeat in loop.ts:
                 - Write last-activity timestamp each iteration
                 - Add process.on('SIGTERM') handler
                 - Add process.on('SIGINT') handler
                 - Mark sprint as 'interrupted' before exit

              3. Detect staleness in transforms.ts:
                 - If in-progress but last-activity > 15 min → stale
                 - Add isStale flag to status

              4. Show stale indicator in page.ts:
                 - Display "Stale" badge next to status
                 - Show "Resume Sprint" button

              5. Add resume endpoint in server.ts:
                 - Add /api/sprint/:id/resume endpoint
                 - Trigger sprint loop restart

              Files:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/cli.ts

              Verification:
              - Switch sprints via dropdown, verify correct data loads
              - Kill sprint process, wait 15 min, verify "Stale" badge + "Resume" button


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/step-2-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/step-2-context.md

              ```markdown
              # Step Context: step-2

              ## Task
              Fix sprint dropdown switching and add stale sprint detection.

              Requirements:
              1. Fix dropdown in page.ts:
                 - Close existing SSE connection on change
                 - Navigate to /sprint/{id} with full page reload
                 - Add loading indicator

              2. Add heartbeat in loop.ts:
                 - Write last-activity timestamp each iteration
                 - Add process.on('SIGTERM') handler
                 - Add process.on('SIGINT') handler
                 - Mark sprint as 'interrupted' before exit

              3. Detect staleness in transforms.ts:
                 - If in-progress but last-activity > 15 min → stale
                 - Add isStale flag to status

              4. Show stale indicator in page.ts:
                 - Display "Stale" badge next to status
                 - Show "Resume Sprint" button

              5. Add resume endpoint in server.ts:
                 - Add /api/sprint/:id/resume endpoint
                 - Trigger sprint loop restart

              Files:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/cli.ts

              Verification:
              - Switch sprints via dropdown, verify correct data loads
              - Kill sprint process, wait 15 min, verify "Stale" badge + "Resume" button


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/step-2-context.md
              git commit -m "context(step-2): gather implementation context"
              ```
            started-at: '2026-01-20T22:33:07.448Z'
            completed-at: '2026-01-20T22:34:58.341Z'
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              Fix sprint dropdown switching and add stale sprint detection.

              Requirements:
              1. Fix dropdown in page.ts:
                 - Close existing SSE connection on change
                 - Navigate to /sprint/{id} with full page reload
                 - Add loading indicator

              2. Add heartbeat in loop.ts:
                 - Write last-activity timestamp each iteration
                 - Add process.on('SIGTERM') handler
                 - Add process.on('SIGINT') handler
                 - Mark sprint as 'interrupted' before exit

              3. Detect staleness in transforms.ts:
                 - If in-progress but last-activity > 15 min → stale
                 - Add isStale flag to status

              4. Show stale indicator in page.ts:
                 - Display "Stale" badge next to status
                 - Show "Resume Sprint" button

              5. Add resume endpoint in server.ts:
                 - Add /api/sprint/:id/resume endpoint
                 - Trigger sprint loop restart

              Files:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/cli.ts

              Verification:
              - Switch sprints via dropdown, verify correct data loads
              - Kill sprint process, wait 15 min, verify "Stale" badge + "Resume" button


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/step-2-gherkin.md (scenarios to satisfy)
              3. context/step-2-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(step-2): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: '2026-01-20T22:35:00.404Z'
            completed-at: '2026-01-20T22:45:00.074Z'
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              Fix sprint dropdown switching and add stale sprint detection.

              Requirements:
              1. Fix dropdown in page.ts:
                 - Close existing SSE connection on change
                 - Navigate to /sprint/{id} with full page reload
                 - Add loading indicator

              2. Add heartbeat in loop.ts:
                 - Write last-activity timestamp each iteration
                 - Add process.on('SIGTERM') handler
                 - Add process.on('SIGINT') handler
                 - Mark sprint as 'interrupted' before exit

              3. Detect staleness in transforms.ts:
                 - If in-progress but last-activity > 15 min → stale
                 - Add isStale flag to status

              4. Show stale indicator in page.ts:
                 - Display "Stale" badge next to status
                 - Show "Resume Sprint" button

              5. Add resume endpoint in server.ts:
                 - Add /api/sprint/:id/resume endpoint
                 - Trigger sprint loop restart

              Files:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/cli.ts

              Verification:
              - Switch sprints via dropdown, verify correct data loads
              - Kill sprint process, wait 15 min, verify "Stale" badge + "Resume" button


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/step-2-context.md (target patterns)
              Read: artifacts/step-2-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(step-2): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: '2026-01-20T22:45:02.149Z'
            completed-at: '2026-01-20T22:49:35.544Z'
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-2-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/step-2-qa-report.md

              ```markdown
              # QA Report: step-2

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/step-2-qa-report.md
              git commit -m "qa(step-2): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for step-2.\n\nRead: artifacts/step-2-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/step-2-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: '2026-01-20T22:49:37.625Z'
            completed-at: '2026-01-20T22:51:50.309Z'
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Fix sprint dropdown switching and add stale sprint detection.

              Requirements:
              1. Fix dropdown in page.ts:
                 - Close existing SSE connection on change
                 - Navigate to /sprint/{id} with full page reload
                 - Add loading indicator

              2. Add heartbeat in loop.ts:
                 - Write last-activity timestamp each iteration
                 - Add process.on('SIGTERM') handler
                 - Add process.on('SIGINT') handler
                 - Mark sprint as 'interrupted' before exit

              3. Detect staleness in transforms.ts:
                 - If in-progress but last-activity > 15 min → stale
                 - Add isStale flag to status

              4. Show stale indicator in page.ts:
                 - Display "Stale" badge next to status
                 - Show "Resume Sprint" button

              5. Add resume endpoint in server.ts:
                 - Add /api/sprint/:id/resume endpoint
                 - Trigger sprint loop restart

              Files:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/cli.ts

              Verification:
              - Switch sprints via dropdown, verify correct data loads
              - Kill sprint process, wait 15 min, verify "Stale" badge + "Resume" button


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-2-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(step-2): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: '2026-01-20T22:51:52.368Z'
            completed-at: '2026-01-20T22:55:01.038Z'
        started-at: '2026-01-20T22:26:47.281Z'
        completed-at: '2026-01-20T22:55:01.038Z'
      - id: step-3
        prompt: |
          Enable referencing another workflow for a single phase (not just for-each).

          ## Overview
          Currently, `workflow:` can only be used with `for-each:` iterations:
          ```yaml
          phases:
            - id: development
              for-each: step
              workflow: tdd-step-workflow  # Works - iterates steps through workflow
          ```

          We want to also support workflow references WITHOUT for-each:
          ```yaml
          phases:
            - id: documentation
              workflow: documentation-workflow  # NEW - run entire workflow as single phase
            - id: qa
              prompt: |
                Run QA checks...  # Regular inline phase
          ```

          This makes workflows composable and reusable.

          ## Use Cases

          1. **Reusable documentation workflow**:
             ```yaml
             # plugin-development.yaml
             phases:
               - id: development
                 for-each: step
                 workflow: tdd-step-workflow
               - id: documentation
                 workflow: documentation-workflow  # Reuse in multiple parent workflows
               - id: qa
                 prompt: |
                   ...
             ```

          2. **Nested workflow composition**:
             ```yaml
             # full-release.yaml
             phases:
               - id: develop
                 workflow: plugin-development  # Run entire dev workflow
               - id: release
                 workflow: release-workflow    # Then run release workflow
             ```

          ## Requirements

          ### 1. Schema Changes

          Phase can have EITHER `prompt` OR `workflow` (mutually exclusive):
          ```typescript
          interface Phase {
            id: string;
            // Option A: Inline prompt
            prompt?: string;
            // Option B: Reference workflow (with optional for-each)
            workflow?: string;
            'for-each'?: 'step' | 'phase';
            // Common fields
            model?: string;
          }
          ```

          Validation:
          - If `workflow` specified without `for-each`: run entire workflow as single phase
          - If `workflow` specified with `for-each`: iterate items through workflow (existing behavior)
          - If `prompt` specified: inline phase (existing behavior)
          - Error if both `prompt` and `workflow` specified

          ### 2. Compiler Changes

          Update `plugins/m42-sprint/compiler/src/compile.ts`:

          1. Detect phases with `workflow:` but no `for-each:`
          2. Load the referenced workflow
          3. Expand its phases inline into PROGRESS.yaml
          4. Prefix phase IDs to avoid collisions: `{parent-phase-id}-{child-phase-id}`

          Example expansion:
          ```yaml
          # Input (SPRINT.yaml with workflow reference)
          phases:
            - id: docs
              workflow: documentation-workflow

          # Output (PROGRESS.yaml after compilation)
          phases:
            - id: docs-analyze
              prompt: "..." (from documentation-workflow)
            - id: docs-user-guide
              prompt: "..."
            - id: docs-reference
              prompt: "..."
          ```

          ### 3. Context Passing

          When expanding a referenced workflow:
          - Pass parent sprint context (sprint.id, sprint variables)
          - Pass parent phase context (phase.id becomes prefix)
          - Inherited model resolution still applies

          ### 4. Recursive Reference Detection

          Prevent infinite loops:
          - Track workflow stack during compilation
          - Error if workflow references itself (directly or indirectly)
          - Max depth limit (e.g., 5 levels)

          ## Files to Modify

          **Compiler:**
          - plugins/m42-sprint/compiler/src/compile.ts - expand workflow references
          - plugins/m42-sprint/compiler/src/types.ts - update Phase type
          - plugins/m42-sprint/compiler/src/workflow-loader.ts - recursive loading

          ## Verification

          1. Create a test workflow that references documentation-workflow:
             ```yaml
             workflow: test-workflow
             phases:
               - id: setup
                 prompt: "Setup task"
               - id: docs
                 workflow: documentation-workflow
               - id: cleanup
                 prompt: "Cleanup task"
             ```

          2. Compile and verify PROGRESS.yaml contains:
             - setup phase
             - docs-analyze, docs-user-guide, docs-reference (expanded)
             - cleanup phase

          3. Run the sprint and verify all phases execute in order
        status: completed
        phases:
          - id: context
            status: completed
            prompt: |
              Prepare context for TDD development.

              ## Step 0: Ensure Working in Worktree (if applicable)
              ```bash
              # If trees directory exists, switch to worktree
              if [ -d "trees/2026-01-20_dashboard-improvements" ]; then
                cd trees/2026-01-20_dashboard-improvements
              fi
              pwd
              git branch --show-current
              ```

              ## Step 1: Read Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Step 2: Understand the Step
              Enable referencing another workflow for a single phase (not just for-each).

              ## Overview
              Currently, `workflow:` can only be used with `for-each:` iterations:
              ```yaml
              phases:
                - id: development
                  for-each: step
                  workflow: tdd-step-workflow  # Works - iterates steps through workflow
              ```

              We want to also support workflow references WITHOUT for-each:
              ```yaml
              phases:
                - id: documentation
                  workflow: documentation-workflow  # NEW - run entire workflow as single phase
                - id: qa
                  prompt: |
                    Run QA checks...  # Regular inline phase
              ```

              This makes workflows composable and reusable.

              ## Use Cases

              1. **Reusable documentation workflow**:
                 ```yaml
                 # plugin-development.yaml
                 phases:
                   - id: development
                     for-each: step
                     workflow: tdd-step-workflow
                   - id: documentation
                     workflow: documentation-workflow  # Reuse in multiple parent workflows
                   - id: qa
                     prompt: |
                       ...
                 ```

              2. **Nested workflow composition**:
                 ```yaml
                 # full-release.yaml
                 phases:
                   - id: develop
                     workflow: plugin-development  # Run entire dev workflow
                   - id: release
                     workflow: release-workflow    # Then run release workflow
                 ```

              ## Requirements

              ### 1. Schema Changes

              Phase can have EITHER `prompt` OR `workflow` (mutually exclusive):
              ```typescript
              interface Phase {
                id: string;
                // Option A: Inline prompt
                prompt?: string;
                // Option B: Reference workflow (with optional for-each)
                workflow?: string;
                'for-each'?: 'step' | 'phase';
                // Common fields
                model?: string;
              }
              ```

              Validation:
              - If `workflow` specified without `for-each`: run entire workflow as single phase
              - If `workflow` specified with `for-each`: iterate items through workflow (existing behavior)
              - If `prompt` specified: inline phase (existing behavior)
              - Error if both `prompt` and `workflow` specified

              ### 2. Compiler Changes

              Update `plugins/m42-sprint/compiler/src/compile.ts`:

              1. Detect phases with `workflow:` but no `for-each:`
              2. Load the referenced workflow
              3. Expand its phases inline into PROGRESS.yaml
              4. Prefix phase IDs to avoid collisions: `{parent-phase-id}-{child-phase-id}`

              Example expansion:
              ```yaml
              # Input (SPRINT.yaml with workflow reference)
              phases:
                - id: docs
                  workflow: documentation-workflow

              # Output (PROGRESS.yaml after compilation)
              phases:
                - id: docs-analyze
                  prompt: "..." (from documentation-workflow)
                - id: docs-user-guide
                  prompt: "..."
                - id: docs-reference
                  prompt: "..."
              ```

              ### 3. Context Passing

              When expanding a referenced workflow:
              - Pass parent sprint context (sprint.id, sprint variables)
              - Pass parent phase context (phase.id becomes prefix)
              - Inherited model resolution still applies

              ### 4. Recursive Reference Detection

              Prevent infinite loops:
              - Track workflow stack during compilation
              - Error if workflow references itself (directly or indirectly)
              - Max depth limit (e.g., 5 levels)

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - expand workflow references
              - plugins/m42-sprint/compiler/src/types.ts - update Phase type
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - recursive loading

              ## Verification

              1. Create a test workflow that references documentation-workflow:
                 ```yaml
                 workflow: test-workflow
                 phases:
                   - id: setup
                     prompt: "Setup task"
                   - id: docs
                     workflow: documentation-workflow
                   - id: cleanup
                     prompt: "Cleanup task"
                 ```

              2. Compile and verify PROGRESS.yaml contains:
                 - setup phase
                 - docs-analyze, docs-user-guide, docs-reference (expanded)
                 - cleanup phase

              3. Run the sprint and verify all phases execute in order


              ## Output
              Confirm understanding of:
              - Test patterns and locations
              - Build/test commands
              - The step requirements
            started-at: '2026-01-20T22:55:03.098Z'
            completed-at: '2026-01-20T22:55:57.397Z'
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              Enable referencing another workflow for a single phase (not just for-each).

              ## Overview
              Currently, `workflow:` can only be used with `for-each:` iterations:
              ```yaml
              phases:
                - id: development
                  for-each: step
                  workflow: tdd-step-workflow  # Works - iterates steps through workflow
              ```

              We want to also support workflow references WITHOUT for-each:
              ```yaml
              phases:
                - id: documentation
                  workflow: documentation-workflow  # NEW - run entire workflow as single phase
                - id: qa
                  prompt: |
                    Run QA checks...  # Regular inline phase
              ```

              This makes workflows composable and reusable.

              ## Use Cases

              1. **Reusable documentation workflow**:
                 ```yaml
                 # plugin-development.yaml
                 phases:
                   - id: development
                     for-each: step
                     workflow: tdd-step-workflow
                   - id: documentation
                     workflow: documentation-workflow  # Reuse in multiple parent workflows
                   - id: qa
                     prompt: |
                       ...
                 ```

              2. **Nested workflow composition**:
                 ```yaml
                 # full-release.yaml
                 phases:
                   - id: develop
                     workflow: plugin-development  # Run entire dev workflow
                   - id: release
                     workflow: release-workflow    # Then run release workflow
                 ```

              ## Requirements

              ### 1. Schema Changes

              Phase can have EITHER `prompt` OR `workflow` (mutually exclusive):
              ```typescript
              interface Phase {
                id: string;
                // Option A: Inline prompt
                prompt?: string;
                // Option B: Reference workflow (with optional for-each)
                workflow?: string;
                'for-each'?: 'step' | 'phase';
                // Common fields
                model?: string;
              }
              ```

              Validation:
              - If `workflow` specified without `for-each`: run entire workflow as single phase
              - If `workflow` specified with `for-each`: iterate items through workflow (existing behavior)
              - If `prompt` specified: inline phase (existing behavior)
              - Error if both `prompt` and `workflow` specified

              ### 2. Compiler Changes

              Update `plugins/m42-sprint/compiler/src/compile.ts`:

              1. Detect phases with `workflow:` but no `for-each:`
              2. Load the referenced workflow
              3. Expand its phases inline into PROGRESS.yaml
              4. Prefix phase IDs to avoid collisions: `{parent-phase-id}-{child-phase-id}`

              Example expansion:
              ```yaml
              # Input (SPRINT.yaml with workflow reference)
              phases:
                - id: docs
                  workflow: documentation-workflow

              # Output (PROGRESS.yaml after compilation)
              phases:
                - id: docs-analyze
                  prompt: "..." (from documentation-workflow)
                - id: docs-user-guide
                  prompt: "..."
                - id: docs-reference
                  prompt: "..."
              ```

              ### 3. Context Passing

              When expanding a referenced workflow:
              - Pass parent sprint context (sprint.id, sprint variables)
              - Pass parent phase context (phase.id becomes prefix)
              - Inherited model resolution still applies

              ### 4. Recursive Reference Detection

              Prevent infinite loops:
              - Track workflow stack during compilation
              - Error if workflow references itself (directly or indirectly)
              - Max depth limit (e.g., 5 levels)

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - expand workflow references
              - plugins/m42-sprint/compiler/src/types.ts - update Phase type
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - recursive loading

              ## Verification

              1. Create a test workflow that references documentation-workflow:
                 ```yaml
                 workflow: test-workflow
                 phases:
                   - id: setup
                     prompt: "Setup task"
                   - id: docs
                     workflow: documentation-workflow
                   - id: cleanup
                     prompt: "Cleanup task"
                 ```

              2. Compile and verify PROGRESS.yaml contains:
                 - setup phase
                 - docs-analyze, docs-user-guide, docs-reference (expanded)
                 - cleanup phase

              3. Run the sprint and verify all phases execute in order


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/step-3-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-3

              ## Step Task
              Enable referencing another workflow for a single phase (not just for-each).

              ## Overview
              Currently, `workflow:` can only be used with `for-each:` iterations:
              ```yaml
              phases:
                - id: development
                  for-each: step
                  workflow: tdd-step-workflow  # Works - iterates steps through workflow
              ```

              We want to also support workflow references WITHOUT for-each:
              ```yaml
              phases:
                - id: documentation
                  workflow: documentation-workflow  # NEW - run entire workflow as single phase
                - id: qa
                  prompt: |
                    Run QA checks...  # Regular inline phase
              ```

              This makes workflows composable and reusable.

              ## Use Cases

              1. **Reusable documentation workflow**:
                 ```yaml
                 # plugin-development.yaml
                 phases:
                   - id: development
                     for-each: step
                     workflow: tdd-step-workflow
                   - id: documentation
                     workflow: documentation-workflow  # Reuse in multiple parent workflows
                   - id: qa
                     prompt: |
                       ...
                 ```

              2. **Nested workflow composition**:
                 ```yaml
                 # full-release.yaml
                 phases:
                   - id: develop
                     workflow: plugin-development  # Run entire dev workflow
                   - id: release
                     workflow: release-workflow    # Then run release workflow
                 ```

              ## Requirements

              ### 1. Schema Changes

              Phase can have EITHER `prompt` OR `workflow` (mutually exclusive):
              ```typescript
              interface Phase {
                id: string;
                // Option A: Inline prompt
                prompt?: string;
                // Option B: Reference workflow (with optional for-each)
                workflow?: string;
                'for-each'?: 'step' | 'phase';
                // Common fields
                model?: string;
              }
              ```

              Validation:
              - If `workflow` specified without `for-each`: run entire workflow as single phase
              - If `workflow` specified with `for-each`: iterate items through workflow (existing behavior)
              - If `prompt` specified: inline phase (existing behavior)
              - Error if both `prompt` and `workflow` specified

              ### 2. Compiler Changes

              Update `plugins/m42-sprint/compiler/src/compile.ts`:

              1. Detect phases with `workflow:` but no `for-each:`
              2. Load the referenced workflow
              3. Expand its phases inline into PROGRESS.yaml
              4. Prefix phase IDs to avoid collisions: `{parent-phase-id}-{child-phase-id}`

              Example expansion:
              ```yaml
              # Input (SPRINT.yaml with workflow reference)
              phases:
                - id: docs
                  workflow: documentation-workflow

              # Output (PROGRESS.yaml after compilation)
              phases:
                - id: docs-analyze
                  prompt: "..." (from documentation-workflow)
                - id: docs-user-guide
                  prompt: "..."
                - id: docs-reference
                  prompt: "..."
              ```

              ### 3. Context Passing

              When expanding a referenced workflow:
              - Pass parent sprint context (sprint.id, sprint variables)
              - Pass parent phase context (phase.id becomes prefix)
              - Inherited model resolution still applies

              ### 4. Recursive Reference Detection

              Prevent infinite loops:
              - Track workflow stack during compilation
              - Error if workflow references itself (directly or indirectly)
              - Max depth limit (e.g., 5 levels)

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - expand workflow references
              - plugins/m42-sprint/compiler/src/types.ts - update Phase type
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - recursive loading

              ## Verification

              1. Create a test workflow that references documentation-workflow:
                 ```yaml
                 workflow: test-workflow
                 phases:
                   - id: setup
                     prompt: "Setup task"
                   - id: docs
                     workflow: documentation-workflow
                   - id: cleanup
                     prompt: "Cleanup task"
                 ```

              2. Compile and verify PROGRESS.yaml contains:
                 - setup phase
                 - docs-analyze, docs-user-guide, docs-reference (expanded)
                 - cleanup phase

              3. Run the sprint and verify all phases execute in order


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/step-3-gherkin.md
              git commit -m "test(step-3): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: '2026-01-20T22:55:59.463Z'
            completed-at: '2026-01-20T23:00:07.126Z'
          - id: green-context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Enable referencing another workflow for a single phase (not just for-each).

              ## Overview
              Currently, `workflow:` can only be used with `for-each:` iterations:
              ```yaml
              phases:
                - id: development
                  for-each: step
                  workflow: tdd-step-workflow  # Works - iterates steps through workflow
              ```

              We want to also support workflow references WITHOUT for-each:
              ```yaml
              phases:
                - id: documentation
                  workflow: documentation-workflow  # NEW - run entire workflow as single phase
                - id: qa
                  prompt: |
                    Run QA checks...  # Regular inline phase
              ```

              This makes workflows composable and reusable.

              ## Use Cases

              1. **Reusable documentation workflow**:
                 ```yaml
                 # plugin-development.yaml
                 phases:
                   - id: development
                     for-each: step
                     workflow: tdd-step-workflow
                   - id: documentation
                     workflow: documentation-workflow  # Reuse in multiple parent workflows
                   - id: qa
                     prompt: |
                       ...
                 ```

              2. **Nested workflow composition**:
                 ```yaml
                 # full-release.yaml
                 phases:
                   - id: develop
                     workflow: plugin-development  # Run entire dev workflow
                   - id: release
                     workflow: release-workflow    # Then run release workflow
                 ```

              ## Requirements

              ### 1. Schema Changes

              Phase can have EITHER `prompt` OR `workflow` (mutually exclusive):
              ```typescript
              interface Phase {
                id: string;
                // Option A: Inline prompt
                prompt?: string;
                // Option B: Reference workflow (with optional for-each)
                workflow?: string;
                'for-each'?: 'step' | 'phase';
                // Common fields
                model?: string;
              }
              ```

              Validation:
              - If `workflow` specified without `for-each`: run entire workflow as single phase
              - If `workflow` specified with `for-each`: iterate items through workflow (existing behavior)
              - If `prompt` specified: inline phase (existing behavior)
              - Error if both `prompt` and `workflow` specified

              ### 2. Compiler Changes

              Update `plugins/m42-sprint/compiler/src/compile.ts`:

              1. Detect phases with `workflow:` but no `for-each:`
              2. Load the referenced workflow
              3. Expand its phases inline into PROGRESS.yaml
              4. Prefix phase IDs to avoid collisions: `{parent-phase-id}-{child-phase-id}`

              Example expansion:
              ```yaml
              # Input (SPRINT.yaml with workflow reference)
              phases:
                - id: docs
                  workflow: documentation-workflow

              # Output (PROGRESS.yaml after compilation)
              phases:
                - id: docs-analyze
                  prompt: "..." (from documentation-workflow)
                - id: docs-user-guide
                  prompt: "..."
                - id: docs-reference
                  prompt: "..."
              ```

              ### 3. Context Passing

              When expanding a referenced workflow:
              - Pass parent sprint context (sprint.id, sprint variables)
              - Pass parent phase context (phase.id becomes prefix)
              - Inherited model resolution still applies

              ### 4. Recursive Reference Detection

              Prevent infinite loops:
              - Track workflow stack during compilation
              - Error if workflow references itself (directly or indirectly)
              - Max depth limit (e.g., 5 levels)

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - expand workflow references
              - plugins/m42-sprint/compiler/src/types.ts - update Phase type
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - recursive loading

              ## Verification

              1. Create a test workflow that references documentation-workflow:
                 ```yaml
                 workflow: test-workflow
                 phases:
                   - id: setup
                     prompt: "Setup task"
                   - id: docs
                     workflow: documentation-workflow
                   - id: cleanup
                     prompt: "Cleanup task"
                 ```

              2. Compile and verify PROGRESS.yaml contains:
                 - setup phase
                 - docs-analyze, docs-user-guide, docs-reference (expanded)
                 - cleanup phase

              3. Run the sprint and verify all phases execute in order


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/step-3-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/step-3-context.md

              ```markdown
              # Step Context: step-3

              ## Task
              Enable referencing another workflow for a single phase (not just for-each).

              ## Overview
              Currently, `workflow:` can only be used with `for-each:` iterations:
              ```yaml
              phases:
                - id: development
                  for-each: step
                  workflow: tdd-step-workflow  # Works - iterates steps through workflow
              ```

              We want to also support workflow references WITHOUT for-each:
              ```yaml
              phases:
                - id: documentation
                  workflow: documentation-workflow  # NEW - run entire workflow as single phase
                - id: qa
                  prompt: |
                    Run QA checks...  # Regular inline phase
              ```

              This makes workflows composable and reusable.

              ## Use Cases

              1. **Reusable documentation workflow**:
                 ```yaml
                 # plugin-development.yaml
                 phases:
                   - id: development
                     for-each: step
                     workflow: tdd-step-workflow
                   - id: documentation
                     workflow: documentation-workflow  # Reuse in multiple parent workflows
                   - id: qa
                     prompt: |
                       ...
                 ```

              2. **Nested workflow composition**:
                 ```yaml
                 # full-release.yaml
                 phases:
                   - id: develop
                     workflow: plugin-development  # Run entire dev workflow
                   - id: release
                     workflow: release-workflow    # Then run release workflow
                 ```

              ## Requirements

              ### 1. Schema Changes

              Phase can have EITHER `prompt` OR `workflow` (mutually exclusive):
              ```typescript
              interface Phase {
                id: string;
                // Option A: Inline prompt
                prompt?: string;
                // Option B: Reference workflow (with optional for-each)
                workflow?: string;
                'for-each'?: 'step' | 'phase';
                // Common fields
                model?: string;
              }
              ```

              Validation:
              - If `workflow` specified without `for-each`: run entire workflow as single phase
              - If `workflow` specified with `for-each`: iterate items through workflow (existing behavior)
              - If `prompt` specified: inline phase (existing behavior)
              - Error if both `prompt` and `workflow` specified

              ### 2. Compiler Changes

              Update `plugins/m42-sprint/compiler/src/compile.ts`:

              1. Detect phases with `workflow:` but no `for-each:`
              2. Load the referenced workflow
              3. Expand its phases inline into PROGRESS.yaml
              4. Prefix phase IDs to avoid collisions: `{parent-phase-id}-{child-phase-id}`

              Example expansion:
              ```yaml
              # Input (SPRINT.yaml with workflow reference)
              phases:
                - id: docs
                  workflow: documentation-workflow

              # Output (PROGRESS.yaml after compilation)
              phases:
                - id: docs-analyze
                  prompt: "..." (from documentation-workflow)
                - id: docs-user-guide
                  prompt: "..."
                - id: docs-reference
                  prompt: "..."
              ```

              ### 3. Context Passing

              When expanding a referenced workflow:
              - Pass parent sprint context (sprint.id, sprint variables)
              - Pass parent phase context (phase.id becomes prefix)
              - Inherited model resolution still applies

              ### 4. Recursive Reference Detection

              Prevent infinite loops:
              - Track workflow stack during compilation
              - Error if workflow references itself (directly or indirectly)
              - Max depth limit (e.g., 5 levels)

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - expand workflow references
              - plugins/m42-sprint/compiler/src/types.ts - update Phase type
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - recursive loading

              ## Verification

              1. Create a test workflow that references documentation-workflow:
                 ```yaml
                 workflow: test-workflow
                 phases:
                   - id: setup
                     prompt: "Setup task"
                   - id: docs
                     workflow: documentation-workflow
                   - id: cleanup
                     prompt: "Cleanup task"
                 ```

              2. Compile and verify PROGRESS.yaml contains:
                 - setup phase
                 - docs-analyze, docs-user-guide, docs-reference (expanded)
                 - cleanup phase

              3. Run the sprint and verify all phases execute in order


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/step-3-context.md
              git commit -m "context(step-3): gather implementation context"
              ```
            started-at: '2026-01-20T23:00:09.192Z'
            completed-at: '2026-01-20T23:01:57.917Z'
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              Enable referencing another workflow for a single phase (not just for-each).

              ## Overview
              Currently, `workflow:` can only be used with `for-each:` iterations:
              ```yaml
              phases:
                - id: development
                  for-each: step
                  workflow: tdd-step-workflow  # Works - iterates steps through workflow
              ```

              We want to also support workflow references WITHOUT for-each:
              ```yaml
              phases:
                - id: documentation
                  workflow: documentation-workflow  # NEW - run entire workflow as single phase
                - id: qa
                  prompt: |
                    Run QA checks...  # Regular inline phase
              ```

              This makes workflows composable and reusable.

              ## Use Cases

              1. **Reusable documentation workflow**:
                 ```yaml
                 # plugin-development.yaml
                 phases:
                   - id: development
                     for-each: step
                     workflow: tdd-step-workflow
                   - id: documentation
                     workflow: documentation-workflow  # Reuse in multiple parent workflows
                   - id: qa
                     prompt: |
                       ...
                 ```

              2. **Nested workflow composition**:
                 ```yaml
                 # full-release.yaml
                 phases:
                   - id: develop
                     workflow: plugin-development  # Run entire dev workflow
                   - id: release
                     workflow: release-workflow    # Then run release workflow
                 ```

              ## Requirements

              ### 1. Schema Changes

              Phase can have EITHER `prompt` OR `workflow` (mutually exclusive):
              ```typescript
              interface Phase {
                id: string;
                // Option A: Inline prompt
                prompt?: string;
                // Option B: Reference workflow (with optional for-each)
                workflow?: string;
                'for-each'?: 'step' | 'phase';
                // Common fields
                model?: string;
              }
              ```

              Validation:
              - If `workflow` specified without `for-each`: run entire workflow as single phase
              - If `workflow` specified with `for-each`: iterate items through workflow (existing behavior)
              - If `prompt` specified: inline phase (existing behavior)
              - Error if both `prompt` and `workflow` specified

              ### 2. Compiler Changes

              Update `plugins/m42-sprint/compiler/src/compile.ts`:

              1. Detect phases with `workflow:` but no `for-each:`
              2. Load the referenced workflow
              3. Expand its phases inline into PROGRESS.yaml
              4. Prefix phase IDs to avoid collisions: `{parent-phase-id}-{child-phase-id}`

              Example expansion:
              ```yaml
              # Input (SPRINT.yaml with workflow reference)
              phases:
                - id: docs
                  workflow: documentation-workflow

              # Output (PROGRESS.yaml after compilation)
              phases:
                - id: docs-analyze
                  prompt: "..." (from documentation-workflow)
                - id: docs-user-guide
                  prompt: "..."
                - id: docs-reference
                  prompt: "..."
              ```

              ### 3. Context Passing

              When expanding a referenced workflow:
              - Pass parent sprint context (sprint.id, sprint variables)
              - Pass parent phase context (phase.id becomes prefix)
              - Inherited model resolution still applies

              ### 4. Recursive Reference Detection

              Prevent infinite loops:
              - Track workflow stack during compilation
              - Error if workflow references itself (directly or indirectly)
              - Max depth limit (e.g., 5 levels)

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - expand workflow references
              - plugins/m42-sprint/compiler/src/types.ts - update Phase type
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - recursive loading

              ## Verification

              1. Create a test workflow that references documentation-workflow:
                 ```yaml
                 workflow: test-workflow
                 phases:
                   - id: setup
                     prompt: "Setup task"
                   - id: docs
                     workflow: documentation-workflow
                   - id: cleanup
                     prompt: "Cleanup task"
                 ```

              2. Compile and verify PROGRESS.yaml contains:
                 - setup phase
                 - docs-analyze, docs-user-guide, docs-reference (expanded)
                 - cleanup phase

              3. Run the sprint and verify all phases execute in order


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/step-3-gherkin.md (scenarios to satisfy)
              3. context/step-3-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(step-3): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: '2026-01-20T23:01:59.988Z'
            completed-at: '2026-01-20T23:05:33.420Z'
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              Enable referencing another workflow for a single phase (not just for-each).

              ## Overview
              Currently, `workflow:` can only be used with `for-each:` iterations:
              ```yaml
              phases:
                - id: development
                  for-each: step
                  workflow: tdd-step-workflow  # Works - iterates steps through workflow
              ```

              We want to also support workflow references WITHOUT for-each:
              ```yaml
              phases:
                - id: documentation
                  workflow: documentation-workflow  # NEW - run entire workflow as single phase
                - id: qa
                  prompt: |
                    Run QA checks...  # Regular inline phase
              ```

              This makes workflows composable and reusable.

              ## Use Cases

              1. **Reusable documentation workflow**:
                 ```yaml
                 # plugin-development.yaml
                 phases:
                   - id: development
                     for-each: step
                     workflow: tdd-step-workflow
                   - id: documentation
                     workflow: documentation-workflow  # Reuse in multiple parent workflows
                   - id: qa
                     prompt: |
                       ...
                 ```

              2. **Nested workflow composition**:
                 ```yaml
                 # full-release.yaml
                 phases:
                   - id: develop
                     workflow: plugin-development  # Run entire dev workflow
                   - id: release
                     workflow: release-workflow    # Then run release workflow
                 ```

              ## Requirements

              ### 1. Schema Changes

              Phase can have EITHER `prompt` OR `workflow` (mutually exclusive):
              ```typescript
              interface Phase {
                id: string;
                // Option A: Inline prompt
                prompt?: string;
                // Option B: Reference workflow (with optional for-each)
                workflow?: string;
                'for-each'?: 'step' | 'phase';
                // Common fields
                model?: string;
              }
              ```

              Validation:
              - If `workflow` specified without `for-each`: run entire workflow as single phase
              - If `workflow` specified with `for-each`: iterate items through workflow (existing behavior)
              - If `prompt` specified: inline phase (existing behavior)
              - Error if both `prompt` and `workflow` specified

              ### 2. Compiler Changes

              Update `plugins/m42-sprint/compiler/src/compile.ts`:

              1. Detect phases with `workflow:` but no `for-each:`
              2. Load the referenced workflow
              3. Expand its phases inline into PROGRESS.yaml
              4. Prefix phase IDs to avoid collisions: `{parent-phase-id}-{child-phase-id}`

              Example expansion:
              ```yaml
              # Input (SPRINT.yaml with workflow reference)
              phases:
                - id: docs
                  workflow: documentation-workflow

              # Output (PROGRESS.yaml after compilation)
              phases:
                - id: docs-analyze
                  prompt: "..." (from documentation-workflow)
                - id: docs-user-guide
                  prompt: "..."
                - id: docs-reference
                  prompt: "..."
              ```

              ### 3. Context Passing

              When expanding a referenced workflow:
              - Pass parent sprint context (sprint.id, sprint variables)
              - Pass parent phase context (phase.id becomes prefix)
              - Inherited model resolution still applies

              ### 4. Recursive Reference Detection

              Prevent infinite loops:
              - Track workflow stack during compilation
              - Error if workflow references itself (directly or indirectly)
              - Max depth limit (e.g., 5 levels)

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - expand workflow references
              - plugins/m42-sprint/compiler/src/types.ts - update Phase type
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - recursive loading

              ## Verification

              1. Create a test workflow that references documentation-workflow:
                 ```yaml
                 workflow: test-workflow
                 phases:
                   - id: setup
                     prompt: "Setup task"
                   - id: docs
                     workflow: documentation-workflow
                   - id: cleanup
                     prompt: "Cleanup task"
                 ```

              2. Compile and verify PROGRESS.yaml contains:
                 - setup phase
                 - docs-analyze, docs-user-guide, docs-reference (expanded)
                 - cleanup phase

              3. Run the sprint and verify all phases execute in order


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/step-3-context.md (target patterns)
              Read: artifacts/step-3-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(step-3): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: '2026-01-20T23:05:35.495Z'
            completed-at: '2026-01-20T23:08:46.598Z'
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-3-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/step-3-qa-report.md

              ```markdown
              # QA Report: step-3

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/step-3-qa-report.md
              git commit -m "qa(step-3): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for step-3.\n\nRead: artifacts/step-3-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/step-3-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: '2026-01-20T23:08:48.675Z'
            completed-at: '2026-01-20T23:10:28.258Z'
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Enable referencing another workflow for a single phase (not just for-each).

              ## Overview
              Currently, `workflow:` can only be used with `for-each:` iterations:
              ```yaml
              phases:
                - id: development
                  for-each: step
                  workflow: tdd-step-workflow  # Works - iterates steps through workflow
              ```

              We want to also support workflow references WITHOUT for-each:
              ```yaml
              phases:
                - id: documentation
                  workflow: documentation-workflow  # NEW - run entire workflow as single phase
                - id: qa
                  prompt: |
                    Run QA checks...  # Regular inline phase
              ```

              This makes workflows composable and reusable.

              ## Use Cases

              1. **Reusable documentation workflow**:
                 ```yaml
                 # plugin-development.yaml
                 phases:
                   - id: development
                     for-each: step
                     workflow: tdd-step-workflow
                   - id: documentation
                     workflow: documentation-workflow  # Reuse in multiple parent workflows
                   - id: qa
                     prompt: |
                       ...
                 ```

              2. **Nested workflow composition**:
                 ```yaml
                 # full-release.yaml
                 phases:
                   - id: develop
                     workflow: plugin-development  # Run entire dev workflow
                   - id: release
                     workflow: release-workflow    # Then run release workflow
                 ```

              ## Requirements

              ### 1. Schema Changes

              Phase can have EITHER `prompt` OR `workflow` (mutually exclusive):
              ```typescript
              interface Phase {
                id: string;
                // Option A: Inline prompt
                prompt?: string;
                // Option B: Reference workflow (with optional for-each)
                workflow?: string;
                'for-each'?: 'step' | 'phase';
                // Common fields
                model?: string;
              }
              ```

              Validation:
              - If `workflow` specified without `for-each`: run entire workflow as single phase
              - If `workflow` specified with `for-each`: iterate items through workflow (existing behavior)
              - If `prompt` specified: inline phase (existing behavior)
              - Error if both `prompt` and `workflow` specified

              ### 2. Compiler Changes

              Update `plugins/m42-sprint/compiler/src/compile.ts`:

              1. Detect phases with `workflow:` but no `for-each:`
              2. Load the referenced workflow
              3. Expand its phases inline into PROGRESS.yaml
              4. Prefix phase IDs to avoid collisions: `{parent-phase-id}-{child-phase-id}`

              Example expansion:
              ```yaml
              # Input (SPRINT.yaml with workflow reference)
              phases:
                - id: docs
                  workflow: documentation-workflow

              # Output (PROGRESS.yaml after compilation)
              phases:
                - id: docs-analyze
                  prompt: "..." (from documentation-workflow)
                - id: docs-user-guide
                  prompt: "..."
                - id: docs-reference
                  prompt: "..."
              ```

              ### 3. Context Passing

              When expanding a referenced workflow:
              - Pass parent sprint context (sprint.id, sprint variables)
              - Pass parent phase context (phase.id becomes prefix)
              - Inherited model resolution still applies

              ### 4. Recursive Reference Detection

              Prevent infinite loops:
              - Track workflow stack during compilation
              - Error if workflow references itself (directly or indirectly)
              - Max depth limit (e.g., 5 levels)

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - expand workflow references
              - plugins/m42-sprint/compiler/src/types.ts - update Phase type
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - recursive loading

              ## Verification

              1. Create a test workflow that references documentation-workflow:
                 ```yaml
                 workflow: test-workflow
                 phases:
                   - id: setup
                     prompt: "Setup task"
                   - id: docs
                     workflow: documentation-workflow
                   - id: cleanup
                     prompt: "Cleanup task"
                 ```

              2. Compile and verify PROGRESS.yaml contains:
                 - setup phase
                 - docs-analyze, docs-user-guide, docs-reference (expanded)
                 - cleanup phase

              3. Run the sprint and verify all phases execute in order


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-3-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(step-3): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: '2026-01-20T23:10:30.365Z'
            completed-at: '2026-01-20T23:12:05.779Z'
        started-at: '2026-01-20T22:55:03.098Z'
        completed-at: '2026-01-20T23:12:05.779Z'
      - id: step-4
        prompt: |
          Implement configurable model selection with cascading override.

          ## Overview
          Allow setting the Claude model (sonnet, opus, haiku) at different levels:
          - workflow (default for all phases)
          - sprint (overrides workflow)
          - phase (overrides sprint)
          - step (overrides phase) - highest priority

          Override priority: step > phase > sprint > workflow

          ## Requirements

          ### 1. Schema Updates

          **SPRINT.yaml schema** - add optional `model` field:
          ```yaml
          workflow: plugin-development
          model: sonnet  # Sprint-level default (optional)

          steps:
            - prompt: |
                Complex task requiring more reasoning...
              model: opus  # Step-level override (optional)
            - prompt: |
                Simple task...
              # No model specified - inherits from sprint/workflow
          ```

          **Workflow YAML schema** - add optional `model` field:
          ```yaml
          name: My Workflow
          model: sonnet  # Workflow-level default (optional)

          phases:
            - id: planning
              model: opus  # Phase-level override (optional)
              prompt: |
                ...
            - id: implement
              # No model - inherits from workflow
              prompt: |
                ...
          ```

          ### 2. Compiler Changes (plugins/m42-sprint/compiler/)

          Update the compiler to:
          1. Parse `model` field from SPRINT.yaml at sprint level
          2. Parse `model` field from each step
          3. Parse `model` field from workflow YAML at workflow level
          4. Parse `model` field from each phase
          5. Store resolved model in PROGRESS.yaml for each phase

          **Resolution logic**:
          ```typescript
          function resolveModel(step, phase, sprint, workflow): string | undefined {
            return step.model ?? phase.model ?? sprint.model ?? workflow.model;
          }
          ```

          ### 3. Runtime Changes (plugins/m42-sprint/runtime/)

          Update the runtime loop to:
          1. Read the `model` field from current phase in PROGRESS.yaml
          2. Pass model to claude-runner when invoking Claude CLI
          3. Use `--model` flag in Claude CLI invocation

          **claude-runner.ts changes**:
          ```typescript
          interface ClaudeRunnerOptions {
            // ... existing options
            model?: 'sonnet' | 'opus' | 'haiku';
          }

          // In runClaude():
          const args = [
            '--print', 'text',
            // ... other args
          ];
          if (options.model) {
            args.push('--model', options.model);
          }
          ```

          ### 4. Dashboard Display (optional enhancement)

          Show current model in the sprint detail page:
          - Display model name next to phase in sidebar
          - Different icon/color for each model tier

          ## Files to Modify

          **Compiler:**
          - plugins/m42-sprint/compiler/src/compile.ts - parse model fields
          - plugins/m42-sprint/compiler/src/types.ts - add model to types
          - plugins/m42-sprint/compiler/src/workflow-loader.ts - parse workflow model

          **Runtime:**
          - plugins/m42-sprint/runtime/src/loop.ts - pass model to runner
          - plugins/m42-sprint/runtime/src/claude-runner.ts - add --model flag
          - plugins/m42-sprint/runtime/src/types.ts - add model to phase type

          **Dashboard (optional):**
          - plugins/m42-sprint/compiler/src/status-server/page.ts - display model
          - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include model

          ## Verification

          1. Create test sprint with mixed models:
             ```yaml
             model: sonnet
             steps:
               - prompt: "Task 1"           # Uses sonnet (sprint default)
               - prompt: "Task 2"
                 model: opus                # Uses opus (step override)
             ```

          2. Run the sprint and verify:
             - Task 1 runs with sonnet
             - Task 2 runs with opus

          3. Check PROGRESS.yaml contains resolved model for each phase
        status: completed
        phases:
          - id: context
            status: completed
            prompt: |
              Prepare context for TDD development.

              ## Step 0: Ensure Working in Worktree (if applicable)
              ```bash
              # If trees directory exists, switch to worktree
              if [ -d "trees/2026-01-20_dashboard-improvements" ]; then
                cd trees/2026-01-20_dashboard-improvements
              fi
              pwd
              git branch --show-current
              ```

              ## Step 1: Read Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Step 2: Understand the Step
              Implement configurable model selection with cascading override.

              ## Overview
              Allow setting the Claude model (sonnet, opus, haiku) at different levels:
              - workflow (default for all phases)
              - sprint (overrides workflow)
              - phase (overrides sprint)
              - step (overrides phase) - highest priority

              Override priority: step > phase > sprint > workflow

              ## Requirements

              ### 1. Schema Updates

              **SPRINT.yaml schema** - add optional `model` field:
              ```yaml
              workflow: plugin-development
              model: sonnet  # Sprint-level default (optional)

              steps:
                - prompt: |
                    Complex task requiring more reasoning...
                  model: opus  # Step-level override (optional)
                - prompt: |
                    Simple task...
                  # No model specified - inherits from sprint/workflow
              ```

              **Workflow YAML schema** - add optional `model` field:
              ```yaml
              name: My Workflow
              model: sonnet  # Workflow-level default (optional)

              phases:
                - id: planning
                  model: opus  # Phase-level override (optional)
                  prompt: |
                    ...
                - id: implement
                  # No model - inherits from workflow
                  prompt: |
                    ...
              ```

              ### 2. Compiler Changes (plugins/m42-sprint/compiler/)

              Update the compiler to:
              1. Parse `model` field from SPRINT.yaml at sprint level
              2. Parse `model` field from each step
              3. Parse `model` field from workflow YAML at workflow level
              4. Parse `model` field from each phase
              5. Store resolved model in PROGRESS.yaml for each phase

              **Resolution logic**:
              ```typescript
              function resolveModel(step, phase, sprint, workflow): string | undefined {
                return step.model ?? phase.model ?? sprint.model ?? workflow.model;
              }
              ```

              ### 3. Runtime Changes (plugins/m42-sprint/runtime/)

              Update the runtime loop to:
              1. Read the `model` field from current phase in PROGRESS.yaml
              2. Pass model to claude-runner when invoking Claude CLI
              3. Use `--model` flag in Claude CLI invocation

              **claude-runner.ts changes**:
              ```typescript
              interface ClaudeRunnerOptions {
                // ... existing options
                model?: 'sonnet' | 'opus' | 'haiku';
              }

              // In runClaude():
              const args = [
                '--print', 'text',
                // ... other args
              ];
              if (options.model) {
                args.push('--model', options.model);
              }
              ```

              ### 4. Dashboard Display (optional enhancement)

              Show current model in the sprint detail page:
              - Display model name next to phase in sidebar
              - Different icon/color for each model tier

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - parse model fields
              - plugins/m42-sprint/compiler/src/types.ts - add model to types
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - parse workflow model

              **Runtime:**
              - plugins/m42-sprint/runtime/src/loop.ts - pass model to runner
              - plugins/m42-sprint/runtime/src/claude-runner.ts - add --model flag
              - plugins/m42-sprint/runtime/src/types.ts - add model to phase type

              **Dashboard (optional):**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - display model
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include model

              ## Verification

              1. Create test sprint with mixed models:
                 ```yaml
                 model: sonnet
                 steps:
                   - prompt: "Task 1"           # Uses sonnet (sprint default)
                   - prompt: "Task 2"
                     model: opus                # Uses opus (step override)
                 ```

              2. Run the sprint and verify:
                 - Task 1 runs with sonnet
                 - Task 2 runs with opus

              3. Check PROGRESS.yaml contains resolved model for each phase


              ## Output
              Confirm understanding of:
              - Test patterns and locations
              - Build/test commands
              - The step requirements
            started-at: '2026-01-20T23:12:07.863Z'
            completed-at: '2026-01-20T23:12:31.145Z'
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              Implement configurable model selection with cascading override.

              ## Overview
              Allow setting the Claude model (sonnet, opus, haiku) at different levels:
              - workflow (default for all phases)
              - sprint (overrides workflow)
              - phase (overrides sprint)
              - step (overrides phase) - highest priority

              Override priority: step > phase > sprint > workflow

              ## Requirements

              ### 1. Schema Updates

              **SPRINT.yaml schema** - add optional `model` field:
              ```yaml
              workflow: plugin-development
              model: sonnet  # Sprint-level default (optional)

              steps:
                - prompt: |
                    Complex task requiring more reasoning...
                  model: opus  # Step-level override (optional)
                - prompt: |
                    Simple task...
                  # No model specified - inherits from sprint/workflow
              ```

              **Workflow YAML schema** - add optional `model` field:
              ```yaml
              name: My Workflow
              model: sonnet  # Workflow-level default (optional)

              phases:
                - id: planning
                  model: opus  # Phase-level override (optional)
                  prompt: |
                    ...
                - id: implement
                  # No model - inherits from workflow
                  prompt: |
                    ...
              ```

              ### 2. Compiler Changes (plugins/m42-sprint/compiler/)

              Update the compiler to:
              1. Parse `model` field from SPRINT.yaml at sprint level
              2. Parse `model` field from each step
              3. Parse `model` field from workflow YAML at workflow level
              4. Parse `model` field from each phase
              5. Store resolved model in PROGRESS.yaml for each phase

              **Resolution logic**:
              ```typescript
              function resolveModel(step, phase, sprint, workflow): string | undefined {
                return step.model ?? phase.model ?? sprint.model ?? workflow.model;
              }
              ```

              ### 3. Runtime Changes (plugins/m42-sprint/runtime/)

              Update the runtime loop to:
              1. Read the `model` field from current phase in PROGRESS.yaml
              2. Pass model to claude-runner when invoking Claude CLI
              3. Use `--model` flag in Claude CLI invocation

              **claude-runner.ts changes**:
              ```typescript
              interface ClaudeRunnerOptions {
                // ... existing options
                model?: 'sonnet' | 'opus' | 'haiku';
              }

              // In runClaude():
              const args = [
                '--print', 'text',
                // ... other args
              ];
              if (options.model) {
                args.push('--model', options.model);
              }
              ```

              ### 4. Dashboard Display (optional enhancement)

              Show current model in the sprint detail page:
              - Display model name next to phase in sidebar
              - Different icon/color for each model tier

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - parse model fields
              - plugins/m42-sprint/compiler/src/types.ts - add model to types
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - parse workflow model

              **Runtime:**
              - plugins/m42-sprint/runtime/src/loop.ts - pass model to runner
              - plugins/m42-sprint/runtime/src/claude-runner.ts - add --model flag
              - plugins/m42-sprint/runtime/src/types.ts - add model to phase type

              **Dashboard (optional):**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - display model
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include model

              ## Verification

              1. Create test sprint with mixed models:
                 ```yaml
                 model: sonnet
                 steps:
                   - prompt: "Task 1"           # Uses sonnet (sprint default)
                   - prompt: "Task 2"
                     model: opus                # Uses opus (step override)
                 ```

              2. Run the sprint and verify:
                 - Task 1 runs with sonnet
                 - Task 2 runs with opus

              3. Check PROGRESS.yaml contains resolved model for each phase


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/step-4-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-4

              ## Step Task
              Implement configurable model selection with cascading override.

              ## Overview
              Allow setting the Claude model (sonnet, opus, haiku) at different levels:
              - workflow (default for all phases)
              - sprint (overrides workflow)
              - phase (overrides sprint)
              - step (overrides phase) - highest priority

              Override priority: step > phase > sprint > workflow

              ## Requirements

              ### 1. Schema Updates

              **SPRINT.yaml schema** - add optional `model` field:
              ```yaml
              workflow: plugin-development
              model: sonnet  # Sprint-level default (optional)

              steps:
                - prompt: |
                    Complex task requiring more reasoning...
                  model: opus  # Step-level override (optional)
                - prompt: |
                    Simple task...
                  # No model specified - inherits from sprint/workflow
              ```

              **Workflow YAML schema** - add optional `model` field:
              ```yaml
              name: My Workflow
              model: sonnet  # Workflow-level default (optional)

              phases:
                - id: planning
                  model: opus  # Phase-level override (optional)
                  prompt: |
                    ...
                - id: implement
                  # No model - inherits from workflow
                  prompt: |
                    ...
              ```

              ### 2. Compiler Changes (plugins/m42-sprint/compiler/)

              Update the compiler to:
              1. Parse `model` field from SPRINT.yaml at sprint level
              2. Parse `model` field from each step
              3. Parse `model` field from workflow YAML at workflow level
              4. Parse `model` field from each phase
              5. Store resolved model in PROGRESS.yaml for each phase

              **Resolution logic**:
              ```typescript
              function resolveModel(step, phase, sprint, workflow): string | undefined {
                return step.model ?? phase.model ?? sprint.model ?? workflow.model;
              }
              ```

              ### 3. Runtime Changes (plugins/m42-sprint/runtime/)

              Update the runtime loop to:
              1. Read the `model` field from current phase in PROGRESS.yaml
              2. Pass model to claude-runner when invoking Claude CLI
              3. Use `--model` flag in Claude CLI invocation

              **claude-runner.ts changes**:
              ```typescript
              interface ClaudeRunnerOptions {
                // ... existing options
                model?: 'sonnet' | 'opus' | 'haiku';
              }

              // In runClaude():
              const args = [
                '--print', 'text',
                // ... other args
              ];
              if (options.model) {
                args.push('--model', options.model);
              }
              ```

              ### 4. Dashboard Display (optional enhancement)

              Show current model in the sprint detail page:
              - Display model name next to phase in sidebar
              - Different icon/color for each model tier

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - parse model fields
              - plugins/m42-sprint/compiler/src/types.ts - add model to types
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - parse workflow model

              **Runtime:**
              - plugins/m42-sprint/runtime/src/loop.ts - pass model to runner
              - plugins/m42-sprint/runtime/src/claude-runner.ts - add --model flag
              - plugins/m42-sprint/runtime/src/types.ts - add model to phase type

              **Dashboard (optional):**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - display model
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include model

              ## Verification

              1. Create test sprint with mixed models:
                 ```yaml
                 model: sonnet
                 steps:
                   - prompt: "Task 1"           # Uses sonnet (sprint default)
                   - prompt: "Task 2"
                     model: opus                # Uses opus (step override)
                 ```

              2. Run the sprint and verify:
                 - Task 1 runs with sonnet
                 - Task 2 runs with opus

              3. Check PROGRESS.yaml contains resolved model for each phase


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/step-4-gherkin.md
              git commit -m "test(step-4): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: '2026-01-20T23:12:33.199Z'
            completed-at: '2026-01-20T23:18:07.469Z'
          - id: green-context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Implement configurable model selection with cascading override.

              ## Overview
              Allow setting the Claude model (sonnet, opus, haiku) at different levels:
              - workflow (default for all phases)
              - sprint (overrides workflow)
              - phase (overrides sprint)
              - step (overrides phase) - highest priority

              Override priority: step > phase > sprint > workflow

              ## Requirements

              ### 1. Schema Updates

              **SPRINT.yaml schema** - add optional `model` field:
              ```yaml
              workflow: plugin-development
              model: sonnet  # Sprint-level default (optional)

              steps:
                - prompt: |
                    Complex task requiring more reasoning...
                  model: opus  # Step-level override (optional)
                - prompt: |
                    Simple task...
                  # No model specified - inherits from sprint/workflow
              ```

              **Workflow YAML schema** - add optional `model` field:
              ```yaml
              name: My Workflow
              model: sonnet  # Workflow-level default (optional)

              phases:
                - id: planning
                  model: opus  # Phase-level override (optional)
                  prompt: |
                    ...
                - id: implement
                  # No model - inherits from workflow
                  prompt: |
                    ...
              ```

              ### 2. Compiler Changes (plugins/m42-sprint/compiler/)

              Update the compiler to:
              1. Parse `model` field from SPRINT.yaml at sprint level
              2. Parse `model` field from each step
              3. Parse `model` field from workflow YAML at workflow level
              4. Parse `model` field from each phase
              5. Store resolved model in PROGRESS.yaml for each phase

              **Resolution logic**:
              ```typescript
              function resolveModel(step, phase, sprint, workflow): string | undefined {
                return step.model ?? phase.model ?? sprint.model ?? workflow.model;
              }
              ```

              ### 3. Runtime Changes (plugins/m42-sprint/runtime/)

              Update the runtime loop to:
              1. Read the `model` field from current phase in PROGRESS.yaml
              2. Pass model to claude-runner when invoking Claude CLI
              3. Use `--model` flag in Claude CLI invocation

              **claude-runner.ts changes**:
              ```typescript
              interface ClaudeRunnerOptions {
                // ... existing options
                model?: 'sonnet' | 'opus' | 'haiku';
              }

              // In runClaude():
              const args = [
                '--print', 'text',
                // ... other args
              ];
              if (options.model) {
                args.push('--model', options.model);
              }
              ```

              ### 4. Dashboard Display (optional enhancement)

              Show current model in the sprint detail page:
              - Display model name next to phase in sidebar
              - Different icon/color for each model tier

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - parse model fields
              - plugins/m42-sprint/compiler/src/types.ts - add model to types
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - parse workflow model

              **Runtime:**
              - plugins/m42-sprint/runtime/src/loop.ts - pass model to runner
              - plugins/m42-sprint/runtime/src/claude-runner.ts - add --model flag
              - plugins/m42-sprint/runtime/src/types.ts - add model to phase type

              **Dashboard (optional):**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - display model
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include model

              ## Verification

              1. Create test sprint with mixed models:
                 ```yaml
                 model: sonnet
                 steps:
                   - prompt: "Task 1"           # Uses sonnet (sprint default)
                   - prompt: "Task 2"
                     model: opus                # Uses opus (step override)
                 ```

              2. Run the sprint and verify:
                 - Task 1 runs with sonnet
                 - Task 2 runs with opus

              3. Check PROGRESS.yaml contains resolved model for each phase


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/step-4-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/step-4-context.md

              ```markdown
              # Step Context: step-4

              ## Task
              Implement configurable model selection with cascading override.

              ## Overview
              Allow setting the Claude model (sonnet, opus, haiku) at different levels:
              - workflow (default for all phases)
              - sprint (overrides workflow)
              - phase (overrides sprint)
              - step (overrides phase) - highest priority

              Override priority: step > phase > sprint > workflow

              ## Requirements

              ### 1. Schema Updates

              **SPRINT.yaml schema** - add optional `model` field:
              ```yaml
              workflow: plugin-development
              model: sonnet  # Sprint-level default (optional)

              steps:
                - prompt: |
                    Complex task requiring more reasoning...
                  model: opus  # Step-level override (optional)
                - prompt: |
                    Simple task...
                  # No model specified - inherits from sprint/workflow
              ```

              **Workflow YAML schema** - add optional `model` field:
              ```yaml
              name: My Workflow
              model: sonnet  # Workflow-level default (optional)

              phases:
                - id: planning
                  model: opus  # Phase-level override (optional)
                  prompt: |
                    ...
                - id: implement
                  # No model - inherits from workflow
                  prompt: |
                    ...
              ```

              ### 2. Compiler Changes (plugins/m42-sprint/compiler/)

              Update the compiler to:
              1. Parse `model` field from SPRINT.yaml at sprint level
              2. Parse `model` field from each step
              3. Parse `model` field from workflow YAML at workflow level
              4. Parse `model` field from each phase
              5. Store resolved model in PROGRESS.yaml for each phase

              **Resolution logic**:
              ```typescript
              function resolveModel(step, phase, sprint, workflow): string | undefined {
                return step.model ?? phase.model ?? sprint.model ?? workflow.model;
              }
              ```

              ### 3. Runtime Changes (plugins/m42-sprint/runtime/)

              Update the runtime loop to:
              1. Read the `model` field from current phase in PROGRESS.yaml
              2. Pass model to claude-runner when invoking Claude CLI
              3. Use `--model` flag in Claude CLI invocation

              **claude-runner.ts changes**:
              ```typescript
              interface ClaudeRunnerOptions {
                // ... existing options
                model?: 'sonnet' | 'opus' | 'haiku';
              }

              // In runClaude():
              const args = [
                '--print', 'text',
                // ... other args
              ];
              if (options.model) {
                args.push('--model', options.model);
              }
              ```

              ### 4. Dashboard Display (optional enhancement)

              Show current model in the sprint detail page:
              - Display model name next to phase in sidebar
              - Different icon/color for each model tier

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - parse model fields
              - plugins/m42-sprint/compiler/src/types.ts - add model to types
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - parse workflow model

              **Runtime:**
              - plugins/m42-sprint/runtime/src/loop.ts - pass model to runner
              - plugins/m42-sprint/runtime/src/claude-runner.ts - add --model flag
              - plugins/m42-sprint/runtime/src/types.ts - add model to phase type

              **Dashboard (optional):**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - display model
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include model

              ## Verification

              1. Create test sprint with mixed models:
                 ```yaml
                 model: sonnet
                 steps:
                   - prompt: "Task 1"           # Uses sonnet (sprint default)
                   - prompt: "Task 2"
                     model: opus                # Uses opus (step override)
                 ```

              2. Run the sprint and verify:
                 - Task 1 runs with sonnet
                 - Task 2 runs with opus

              3. Check PROGRESS.yaml contains resolved model for each phase


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/step-4-context.md
              git commit -m "context(step-4): gather implementation context"
              ```
            started-at: '2026-01-20T23:18:09.534Z'
            completed-at: '2026-01-20T23:19:58.846Z'
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              Implement configurable model selection with cascading override.

              ## Overview
              Allow setting the Claude model (sonnet, opus, haiku) at different levels:
              - workflow (default for all phases)
              - sprint (overrides workflow)
              - phase (overrides sprint)
              - step (overrides phase) - highest priority

              Override priority: step > phase > sprint > workflow

              ## Requirements

              ### 1. Schema Updates

              **SPRINT.yaml schema** - add optional `model` field:
              ```yaml
              workflow: plugin-development
              model: sonnet  # Sprint-level default (optional)

              steps:
                - prompt: |
                    Complex task requiring more reasoning...
                  model: opus  # Step-level override (optional)
                - prompt: |
                    Simple task...
                  # No model specified - inherits from sprint/workflow
              ```

              **Workflow YAML schema** - add optional `model` field:
              ```yaml
              name: My Workflow
              model: sonnet  # Workflow-level default (optional)

              phases:
                - id: planning
                  model: opus  # Phase-level override (optional)
                  prompt: |
                    ...
                - id: implement
                  # No model - inherits from workflow
                  prompt: |
                    ...
              ```

              ### 2. Compiler Changes (plugins/m42-sprint/compiler/)

              Update the compiler to:
              1. Parse `model` field from SPRINT.yaml at sprint level
              2. Parse `model` field from each step
              3. Parse `model` field from workflow YAML at workflow level
              4. Parse `model` field from each phase
              5. Store resolved model in PROGRESS.yaml for each phase

              **Resolution logic**:
              ```typescript
              function resolveModel(step, phase, sprint, workflow): string | undefined {
                return step.model ?? phase.model ?? sprint.model ?? workflow.model;
              }
              ```

              ### 3. Runtime Changes (plugins/m42-sprint/runtime/)

              Update the runtime loop to:
              1. Read the `model` field from current phase in PROGRESS.yaml
              2. Pass model to claude-runner when invoking Claude CLI
              3. Use `--model` flag in Claude CLI invocation

              **claude-runner.ts changes**:
              ```typescript
              interface ClaudeRunnerOptions {
                // ... existing options
                model?: 'sonnet' | 'opus' | 'haiku';
              }

              // In runClaude():
              const args = [
                '--print', 'text',
                // ... other args
              ];
              if (options.model) {
                args.push('--model', options.model);
              }
              ```

              ### 4. Dashboard Display (optional enhancement)

              Show current model in the sprint detail page:
              - Display model name next to phase in sidebar
              - Different icon/color for each model tier

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - parse model fields
              - plugins/m42-sprint/compiler/src/types.ts - add model to types
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - parse workflow model

              **Runtime:**
              - plugins/m42-sprint/runtime/src/loop.ts - pass model to runner
              - plugins/m42-sprint/runtime/src/claude-runner.ts - add --model flag
              - plugins/m42-sprint/runtime/src/types.ts - add model to phase type

              **Dashboard (optional):**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - display model
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include model

              ## Verification

              1. Create test sprint with mixed models:
                 ```yaml
                 model: sonnet
                 steps:
                   - prompt: "Task 1"           # Uses sonnet (sprint default)
                   - prompt: "Task 2"
                     model: opus                # Uses opus (step override)
                 ```

              2. Run the sprint and verify:
                 - Task 1 runs with sonnet
                 - Task 2 runs with opus

              3. Check PROGRESS.yaml contains resolved model for each phase


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/step-4-gherkin.md (scenarios to satisfy)
              3. context/step-4-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(step-4): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: '2026-01-20T23:20:00.910Z'
            completed-at: '2026-01-20T23:26:55.316Z'
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              Implement configurable model selection with cascading override.

              ## Overview
              Allow setting the Claude model (sonnet, opus, haiku) at different levels:
              - workflow (default for all phases)
              - sprint (overrides workflow)
              - phase (overrides sprint)
              - step (overrides phase) - highest priority

              Override priority: step > phase > sprint > workflow

              ## Requirements

              ### 1. Schema Updates

              **SPRINT.yaml schema** - add optional `model` field:
              ```yaml
              workflow: plugin-development
              model: sonnet  # Sprint-level default (optional)

              steps:
                - prompt: |
                    Complex task requiring more reasoning...
                  model: opus  # Step-level override (optional)
                - prompt: |
                    Simple task...
                  # No model specified - inherits from sprint/workflow
              ```

              **Workflow YAML schema** - add optional `model` field:
              ```yaml
              name: My Workflow
              model: sonnet  # Workflow-level default (optional)

              phases:
                - id: planning
                  model: opus  # Phase-level override (optional)
                  prompt: |
                    ...
                - id: implement
                  # No model - inherits from workflow
                  prompt: |
                    ...
              ```

              ### 2. Compiler Changes (plugins/m42-sprint/compiler/)

              Update the compiler to:
              1. Parse `model` field from SPRINT.yaml at sprint level
              2. Parse `model` field from each step
              3. Parse `model` field from workflow YAML at workflow level
              4. Parse `model` field from each phase
              5. Store resolved model in PROGRESS.yaml for each phase

              **Resolution logic**:
              ```typescript
              function resolveModel(step, phase, sprint, workflow): string | undefined {
                return step.model ?? phase.model ?? sprint.model ?? workflow.model;
              }
              ```

              ### 3. Runtime Changes (plugins/m42-sprint/runtime/)

              Update the runtime loop to:
              1. Read the `model` field from current phase in PROGRESS.yaml
              2. Pass model to claude-runner when invoking Claude CLI
              3. Use `--model` flag in Claude CLI invocation

              **claude-runner.ts changes**:
              ```typescript
              interface ClaudeRunnerOptions {
                // ... existing options
                model?: 'sonnet' | 'opus' | 'haiku';
              }

              // In runClaude():
              const args = [
                '--print', 'text',
                // ... other args
              ];
              if (options.model) {
                args.push('--model', options.model);
              }
              ```

              ### 4. Dashboard Display (optional enhancement)

              Show current model in the sprint detail page:
              - Display model name next to phase in sidebar
              - Different icon/color for each model tier

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - parse model fields
              - plugins/m42-sprint/compiler/src/types.ts - add model to types
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - parse workflow model

              **Runtime:**
              - plugins/m42-sprint/runtime/src/loop.ts - pass model to runner
              - plugins/m42-sprint/runtime/src/claude-runner.ts - add --model flag
              - plugins/m42-sprint/runtime/src/types.ts - add model to phase type

              **Dashboard (optional):**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - display model
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include model

              ## Verification

              1. Create test sprint with mixed models:
                 ```yaml
                 model: sonnet
                 steps:
                   - prompt: "Task 1"           # Uses sonnet (sprint default)
                   - prompt: "Task 2"
                     model: opus                # Uses opus (step override)
                 ```

              2. Run the sprint and verify:
                 - Task 1 runs with sonnet
                 - Task 2 runs with opus

              3. Check PROGRESS.yaml contains resolved model for each phase


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/step-4-context.md (target patterns)
              Read: artifacts/step-4-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(step-4): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: '2026-01-20T23:26:55.532Z'
            completed-at: '2026-01-20T23:30:34.030Z'
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-4-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/step-4-qa-report.md

              ```markdown
              # QA Report: step-4

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/step-4-qa-report.md
              git commit -m "qa(step-4): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for step-4.\n\nRead: artifacts/step-4-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/step-4-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: '2026-01-20T23:30:36.095Z'
            completed-at: '2026-01-20T23:33:41.745Z'
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Implement configurable model selection with cascading override.

              ## Overview
              Allow setting the Claude model (sonnet, opus, haiku) at different levels:
              - workflow (default for all phases)
              - sprint (overrides workflow)
              - phase (overrides sprint)
              - step (overrides phase) - highest priority

              Override priority: step > phase > sprint > workflow

              ## Requirements

              ### 1. Schema Updates

              **SPRINT.yaml schema** - add optional `model` field:
              ```yaml
              workflow: plugin-development
              model: sonnet  # Sprint-level default (optional)

              steps:
                - prompt: |
                    Complex task requiring more reasoning...
                  model: opus  # Step-level override (optional)
                - prompt: |
                    Simple task...
                  # No model specified - inherits from sprint/workflow
              ```

              **Workflow YAML schema** - add optional `model` field:
              ```yaml
              name: My Workflow
              model: sonnet  # Workflow-level default (optional)

              phases:
                - id: planning
                  model: opus  # Phase-level override (optional)
                  prompt: |
                    ...
                - id: implement
                  # No model - inherits from workflow
                  prompt: |
                    ...
              ```

              ### 2. Compiler Changes (plugins/m42-sprint/compiler/)

              Update the compiler to:
              1. Parse `model` field from SPRINT.yaml at sprint level
              2. Parse `model` field from each step
              3. Parse `model` field from workflow YAML at workflow level
              4. Parse `model` field from each phase
              5. Store resolved model in PROGRESS.yaml for each phase

              **Resolution logic**:
              ```typescript
              function resolveModel(step, phase, sprint, workflow): string | undefined {
                return step.model ?? phase.model ?? sprint.model ?? workflow.model;
              }
              ```

              ### 3. Runtime Changes (plugins/m42-sprint/runtime/)

              Update the runtime loop to:
              1. Read the `model` field from current phase in PROGRESS.yaml
              2. Pass model to claude-runner when invoking Claude CLI
              3. Use `--model` flag in Claude CLI invocation

              **claude-runner.ts changes**:
              ```typescript
              interface ClaudeRunnerOptions {
                // ... existing options
                model?: 'sonnet' | 'opus' | 'haiku';
              }

              // In runClaude():
              const args = [
                '--print', 'text',
                // ... other args
              ];
              if (options.model) {
                args.push('--model', options.model);
              }
              ```

              ### 4. Dashboard Display (optional enhancement)

              Show current model in the sprint detail page:
              - Display model name next to phase in sidebar
              - Different icon/color for each model tier

              ## Files to Modify

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - parse model fields
              - plugins/m42-sprint/compiler/src/types.ts - add model to types
              - plugins/m42-sprint/compiler/src/workflow-loader.ts - parse workflow model

              **Runtime:**
              - plugins/m42-sprint/runtime/src/loop.ts - pass model to runner
              - plugins/m42-sprint/runtime/src/claude-runner.ts - add --model flag
              - plugins/m42-sprint/runtime/src/types.ts - add model to phase type

              **Dashboard (optional):**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - display model
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include model

              ## Verification

              1. Create test sprint with mixed models:
                 ```yaml
                 model: sonnet
                 steps:
                   - prompt: "Task 1"           # Uses sonnet (sprint default)
                   - prompt: "Task 2"
                     model: opus                # Uses opus (step override)
                 ```

              2. Run the sprint and verify:
                 - Task 1 runs with sonnet
                 - Task 2 runs with opus

              3. Check PROGRESS.yaml contains resolved model for each phase


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-4-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(step-4): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: '2026-01-20T23:33:43.804Z'
            completed-at: '2026-01-20T23:36:21.748Z'
        started-at: '2026-01-20T23:12:07.863Z'
        completed-at: '2026-01-20T23:36:21.748Z'
      - id: step-5
        prompt: |
          Implement operator request system for discovered issues.

          ## Overview
          Claude can submit requests to the operator when it discovers issues during execution.
          All requests go to the operator queue - no auto-handling modes. The operator (a
          dedicated Claude instance) reviews requests, makes decisions with reasoning, and
          uses dynamic step injection to add work to the sprint.

          ## Phase Result JSON Schema (Agent Response)

          ```typescript
          interface PhaseResult {
            // Existing fields
            status: 'completed' | 'failed' | 'blocked';
            summary: string;
            artifacts?: string[];

            // NEW: Requests for operator review
            operatorRequests?: OperatorRequest[];
          }

          interface OperatorRequest {
            id: string;                    // Unique identifier (nanoid)
            title: string;                 // Short description
            description: string;           // Full description of what needs to be done
            priority: 'critical' | 'high' | 'medium' | 'low';
            type: 'bug' | 'improvement' | 'refactor' | 'test' | 'docs' | 'security';

            // Context for operator decision
            context?: {
              discoveredIn: string;        // Phase ID where discovered
              relatedFiles?: string[];
              codeSnippet?: string;        // Relevant code excerpt
              suggestedWorkflow?: string;  // Agent's suggestion (operator can override)
            };
          }
          ```

          ## Operator Response JSON Schema

          The operator responds with decisions AND reasoning:

          ```typescript
          interface OperatorDecision {
            requestId: string;             // Which request this decides
            decision: 'approve' | 'reject' | 'defer' | 'backlog';

            // Required: Explain the reasoning
            reasoning: string;             // Why this decision was made

            // If approved: injection details
            injection?: {
              workflow?: string;           // Workflow to compile (optional)
              prompt?: string;             // Direct prompt if no workflow
              position: InsertPosition;    // Where to inject
              model?: string;              // Model override
              idPrefix: string;            // Prefix for generated IDs
            };

            // If deferred: when to revisit
            deferredUntil?: 'end-of-phase' | 'end-of-sprint' | 'next-sprint';

            // If backlog: for human review (NOT auto-implemented)
            backlogEntry?: {
              category: string;            // e.g., 'tech-debt', 'feature', 'investigation'
              suggestedPriority: 'high' | 'medium' | 'low';
              notes: string;               // Additional context for human
            };

            // If rejected: why
            rejectionReason?: string;
          }

          interface OperatorResponse {
            decisions: OperatorDecision[];
            operatorLog: string;           // Summary of operator's analysis
            timestamp: string;
          }
          ```

          ## Decision Types

          | Decision | Behavior |
          |----------|----------|
          | `approve` | Inject step/workflow into sprint immediately |
          | `reject` | Decline with reason, no action taken |
          | `defer` | Queue for later in sprint (end-of-phase, end-of-sprint) |
          | `backlog` | **NEW**: Add to backlog for human review, NOT auto-implemented |

          The `backlog` decision is for items that:
          - Are valid but out of scope for current sprint
          - Need human judgment before implementation
          - Should be tracked but not automatically acted upon
          - May require discussion or prioritization

          ## Backlog Storage

          Backlog items stored in `BACKLOG.yaml` in sprint directory:

          ```yaml
          # .claude/sprints/<sprint-id>/BACKLOG.yaml
          items:
            - id: req_abc123
              title: "Refactor authentication to use OAuth2"
              description: "Current auth is basic, should upgrade..."
              category: tech-debt
              suggested-priority: medium
              operator-notes: "Valid improvement but significant scope. Needs arch review."
              source:
                request-id: req_abc123
                discovered-in: development-step-3
                discovered-at: 2026-01-20T10:00:00Z
              created-at: 2026-01-20T10:05:00Z
              status: pending-review  # pending-review | acknowledged | converted-to-issue
          ```

          ## Operator as Skill/Command

          The default operator is implemented as a **skill** that can be:
          - Used as-is with default prompt
          - Overridden at workflow or sprint level
          - Extended with custom logic

          ### Default Operator Skill

          Create: `.claude/skills/sprint-operator/skill.md`

          ```markdown
          # Sprint Operator

          You are the sprint operator responsible for reviewing discovered issues
          and deciding how to handle them.

          ## Your Responsibilities

          1. **Triage**: Assess each request's urgency and relevance
          2. **Decide**: Choose appropriate action (approve/reject/defer/backlog)
          3. **Reason**: Always explain your decision clearly
          4. **Place**: If approving, determine optimal injection point

          ## Decision Guidelines

          ### Approve when:
          - Issue blocks current sprint progress
          - Fix is small and well-defined
          - Directly related to sprint goals

          ### Reject when:
          - Request is invalid or duplicate
          - Already addressed elsewhere
          - Not actually an issue

          ### Defer when:
          - Valid but not urgent
          - Can wait until later in sprint
          - Dependencies not yet ready

          ### Backlog when:
          - Valid but out of scope for sprint
          - Needs human review/discussion
          - Significant scope or architectural impact
          - "Nice to have" improvements

          ## Context Available

          - Sprint goals and progress
          - Current phase and remaining work
          - Request details and context
          - Related files and code snippets
          ```

          ### Override in Workflow/Sprint

          ```yaml
          # workflow.yaml or SPRINT.yaml
          operator:
            enabled: true                  # Default: true
            model: sonnet                  # Model for operator (default: sonnet)
            skill: sprint-operator         # Default skill (can override)
            # OR provide custom prompt:
            prompt: |                      # Overrides skill if provided
              Custom operator instructions...
          ```

          ## Request Lifecycle

          ```
          Agent discovers issue → Creates OperatorRequest → Added to queue (status: pending)
                                                                  ↓
          Operator reviews (batch or immediate) → Makes decision with reasoning
                                                                  ↓
                                  ┌─────────────────────────────────┼─────────────────────────────────┐
                                  ↓                                 ↓                                 ↓
                             [approve]                          [reject]                          [defer]
                                  ↓                                 ↓                                 ↓
                        Inject step/workflow              Log rejection reason             Queue for later
                                  ↓                                 ↓                                 ↓
                         status: approved                  status: rejected                 status: deferred
          ```

          ## Requirements

          ### 1. Update Claude Runner

          Modify `claude-runner.ts` to:
          - Use `--output-format json` with schema including `operatorRequests`
          - Parse requests from response
          - Return them to the loop

          ### 2. Request Queue Storage

          Store requests in `PROGRESS.yaml` or separate file:
          ```yaml
          operator-queue:
            - id: req_abc123
              title: "Fix memory leak in parser"
              status: pending
              created-at: 2026-01-20T10:00:00Z
              discovered-in: development-step-2
              # ... rest of request

            - id: req_def456
              title: "Add input validation"
              status: approved
              decided-at: 2026-01-20T10:05:00Z
              decision:
                reasoning: "Security issue, should be addressed before QA"
                injection:
                  position: { type: after-current }
                  workflow: bugfix-workflow
              # ... rest
          ```

          ### 3. Operator Handler

          Create `operator.ts`:
          - Batch process pending requests (or immediate for critical)
          - Run operator prompt with context
          - Parse decisions and reasoning
          - Execute injections for approved requests
          - Update queue status

          ### 4. Operator Trigger Points

          When does operator run?
          - After each phase completes (if pending requests exist)
          - Immediately for `critical` priority requests
          - Can be triggered manually from dashboard

          ## Files to Modify

          **Runtime:**
          - plugins/m42-sprint/runtime/src/claude-runner.ts - parse operatorRequests
          - plugins/m42-sprint/runtime/src/loop.ts - queue requests, trigger operator
          - plugins/m42-sprint/runtime/src/operator.ts - NEW: operator logic with skill loading
          - plugins/m42-sprint/runtime/src/backlog.ts - NEW: backlog management
          - plugins/m42-sprint/runtime/src/types.ts - request/decision types

          **Compiler:**
          - plugins/m42-sprint/compiler/src/types.ts - operator config in workflow schema

          **Skill:**
          - plugins/m42-sprint/skills/sprint-operator/skill.md - NEW: default operator skill

          ## Verification

          1. Create phase that submits operator request:
             ```yaml
             - prompt: |
                 Review the code. If you find issues, add them to operatorRequests.
             ```

          2. Verify request appears in queue with status: pending
          3. Verify operator runs using default skill and makes decision with reasoning
          4. Verify approved requests get injected correctly
          5. Verify rejected/deferred requests logged properly
          6. Verify backlog items written to BACKLOG.yaml for human review
          7. Verify custom operator prompt overrides default skill
        status: completed
        phases:
          - id: context
            status: completed
            prompt: |
              Prepare context for TDD development.

              ## Step 0: Ensure Working in Worktree (if applicable)
              ```bash
              # If trees directory exists, switch to worktree
              if [ -d "trees/2026-01-20_dashboard-improvements" ]; then
                cd trees/2026-01-20_dashboard-improvements
              fi
              pwd
              git branch --show-current
              ```

              ## Step 1: Read Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Step 2: Understand the Step
              Implement operator request system for discovered issues.

              ## Overview
              Claude can submit requests to the operator when it discovers issues during execution.
              All requests go to the operator queue - no auto-handling modes. The operator (a
              dedicated Claude instance) reviews requests, makes decisions with reasoning, and
              uses dynamic step injection to add work to the sprint.

              ## Phase Result JSON Schema (Agent Response)

              ```typescript
              interface PhaseResult {
                // Existing fields
                status: 'completed' | 'failed' | 'blocked';
                summary: string;
                artifacts?: string[];

                // NEW: Requests for operator review
                operatorRequests?: OperatorRequest[];
              }

              interface OperatorRequest {
                id: string;                    // Unique identifier (nanoid)
                title: string;                 // Short description
                description: string;           // Full description of what needs to be done
                priority: 'critical' | 'high' | 'medium' | 'low';
                type: 'bug' | 'improvement' | 'refactor' | 'test' | 'docs' | 'security';

                // Context for operator decision
                context?: {
                  discoveredIn: string;        // Phase ID where discovered
                  relatedFiles?: string[];
                  codeSnippet?: string;        // Relevant code excerpt
                  suggestedWorkflow?: string;  // Agent's suggestion (operator can override)
                };
              }
              ```

              ## Operator Response JSON Schema

              The operator responds with decisions AND reasoning:

              ```typescript
              interface OperatorDecision {
                requestId: string;             // Which request this decides
                decision: 'approve' | 'reject' | 'defer' | 'backlog';

                // Required: Explain the reasoning
                reasoning: string;             // Why this decision was made

                // If approved: injection details
                injection?: {
                  workflow?: string;           // Workflow to compile (optional)
                  prompt?: string;             // Direct prompt if no workflow
                  position: InsertPosition;    // Where to inject
                  model?: string;              // Model override
                  idPrefix: string;            // Prefix for generated IDs
                };

                // If deferred: when to revisit
                deferredUntil?: 'end-of-phase' | 'end-of-sprint' | 'next-sprint';

                // If backlog: for human review (NOT auto-implemented)
                backlogEntry?: {
                  category: string;            // e.g., 'tech-debt', 'feature', 'investigation'
                  suggestedPriority: 'high' | 'medium' | 'low';
                  notes: string;               // Additional context for human
                };

                // If rejected: why
                rejectionReason?: string;
              }

              interface OperatorResponse {
                decisions: OperatorDecision[];
                operatorLog: string;           // Summary of operator's analysis
                timestamp: string;
              }
              ```

              ## Decision Types

              | Decision | Behavior |
              |----------|----------|
              | `approve` | Inject step/workflow into sprint immediately |
              | `reject` | Decline with reason, no action taken |
              | `defer` | Queue for later in sprint (end-of-phase, end-of-sprint) |
              | `backlog` | **NEW**: Add to backlog for human review, NOT auto-implemented |

              The `backlog` decision is for items that:
              - Are valid but out of scope for current sprint
              - Need human judgment before implementation
              - Should be tracked but not automatically acted upon
              - May require discussion or prioritization

              ## Backlog Storage

              Backlog items stored in `BACKLOG.yaml` in sprint directory:

              ```yaml
              # .claude/sprints/<sprint-id>/BACKLOG.yaml
              items:
                - id: req_abc123
                  title: "Refactor authentication to use OAuth2"
                  description: "Current auth is basic, should upgrade..."
                  category: tech-debt
                  suggested-priority: medium
                  operator-notes: "Valid improvement but significant scope. Needs arch review."
                  source:
                    request-id: req_abc123
                    discovered-in: development-step-3
                    discovered-at: 2026-01-20T10:00:00Z
                  created-at: 2026-01-20T10:05:00Z
                  status: pending-review  # pending-review | acknowledged | converted-to-issue
              ```

              ## Operator as Skill/Command

              The default operator is implemented as a **skill** that can be:
              - Used as-is with default prompt
              - Overridden at workflow or sprint level
              - Extended with custom logic

              ### Default Operator Skill

              Create: `.claude/skills/sprint-operator/skill.md`

              ```markdown
              # Sprint Operator

              You are the sprint operator responsible for reviewing discovered issues
              and deciding how to handle them.

              ## Your Responsibilities

              1. **Triage**: Assess each request's urgency and relevance
              2. **Decide**: Choose appropriate action (approve/reject/defer/backlog)
              3. **Reason**: Always explain your decision clearly
              4. **Place**: If approving, determine optimal injection point

              ## Decision Guidelines

              ### Approve when:
              - Issue blocks current sprint progress
              - Fix is small and well-defined
              - Directly related to sprint goals

              ### Reject when:
              - Request is invalid or duplicate
              - Already addressed elsewhere
              - Not actually an issue

              ### Defer when:
              - Valid but not urgent
              - Can wait until later in sprint
              - Dependencies not yet ready

              ### Backlog when:
              - Valid but out of scope for sprint
              - Needs human review/discussion
              - Significant scope or architectural impact
              - "Nice to have" improvements

              ## Context Available

              - Sprint goals and progress
              - Current phase and remaining work
              - Request details and context
              - Related files and code snippets
              ```

              ### Override in Workflow/Sprint

              ```yaml
              # workflow.yaml or SPRINT.yaml
              operator:
                enabled: true                  # Default: true
                model: sonnet                  # Model for operator (default: sonnet)
                skill: sprint-operator         # Default skill (can override)
                # OR provide custom prompt:
                prompt: |                      # Overrides skill if provided
                  Custom operator instructions...
              ```

              ## Request Lifecycle

              ```
              Agent discovers issue → Creates OperatorRequest → Added to queue (status: pending)
                                                                      ↓
              Operator reviews (batch or immediate) → Makes decision with reasoning
                                                                      ↓
                                      ┌─────────────────────────────────┼─────────────────────────────────┐
                                      ↓                                 ↓                                 ↓
                                 [approve]                          [reject]                          [defer]
                                      ↓                                 ↓                                 ↓
                            Inject step/workflow              Log rejection reason             Queue for later
                                      ↓                                 ↓                                 ↓
                             status: approved                  status: rejected                 status: deferred
              ```

              ## Requirements

              ### 1. Update Claude Runner

              Modify `claude-runner.ts` to:
              - Use `--output-format json` with schema including `operatorRequests`
              - Parse requests from response
              - Return them to the loop

              ### 2. Request Queue Storage

              Store requests in `PROGRESS.yaml` or separate file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  title: "Fix memory leak in parser"
                  status: pending
                  created-at: 2026-01-20T10:00:00Z
                  discovered-in: development-step-2
                  # ... rest of request

                - id: req_def456
                  title: "Add input validation"
                  status: approved
                  decided-at: 2026-01-20T10:05:00Z
                  decision:
                    reasoning: "Security issue, should be addressed before QA"
                    injection:
                      position: { type: after-current }
                      workflow: bugfix-workflow
                  # ... rest
              ```

              ### 3. Operator Handler

              Create `operator.ts`:
              - Batch process pending requests (or immediate for critical)
              - Run operator prompt with context
              - Parse decisions and reasoning
              - Execute injections for approved requests
              - Update queue status

              ### 4. Operator Trigger Points

              When does operator run?
              - After each phase completes (if pending requests exist)
              - Immediately for `critical` priority requests
              - Can be triggered manually from dashboard

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/claude-runner.ts - parse operatorRequests
              - plugins/m42-sprint/runtime/src/loop.ts - queue requests, trigger operator
              - plugins/m42-sprint/runtime/src/operator.ts - NEW: operator logic with skill loading
              - plugins/m42-sprint/runtime/src/backlog.ts - NEW: backlog management
              - plugins/m42-sprint/runtime/src/types.ts - request/decision types

              **Compiler:**
              - plugins/m42-sprint/compiler/src/types.ts - operator config in workflow schema

              **Skill:**
              - plugins/m42-sprint/skills/sprint-operator/skill.md - NEW: default operator skill

              ## Verification

              1. Create phase that submits operator request:
                 ```yaml
                 - prompt: |
                     Review the code. If you find issues, add them to operatorRequests.
                 ```

              2. Verify request appears in queue with status: pending
              3. Verify operator runs using default skill and makes decision with reasoning
              4. Verify approved requests get injected correctly
              5. Verify rejected/deferred requests logged properly
              6. Verify backlog items written to BACKLOG.yaml for human review
              7. Verify custom operator prompt overrides default skill


              ## Output
              Confirm understanding of:
              - Test patterns and locations
              - Build/test commands
              - The step requirements
            started-at: '2026-01-20T23:36:23.819Z'
            completed-at: '2026-01-20T23:37:18.937Z'
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              Implement operator request system for discovered issues.

              ## Overview
              Claude can submit requests to the operator when it discovers issues during execution.
              All requests go to the operator queue - no auto-handling modes. The operator (a
              dedicated Claude instance) reviews requests, makes decisions with reasoning, and
              uses dynamic step injection to add work to the sprint.

              ## Phase Result JSON Schema (Agent Response)

              ```typescript
              interface PhaseResult {
                // Existing fields
                status: 'completed' | 'failed' | 'blocked';
                summary: string;
                artifacts?: string[];

                // NEW: Requests for operator review
                operatorRequests?: OperatorRequest[];
              }

              interface OperatorRequest {
                id: string;                    // Unique identifier (nanoid)
                title: string;                 // Short description
                description: string;           // Full description of what needs to be done
                priority: 'critical' | 'high' | 'medium' | 'low';
                type: 'bug' | 'improvement' | 'refactor' | 'test' | 'docs' | 'security';

                // Context for operator decision
                context?: {
                  discoveredIn: string;        // Phase ID where discovered
                  relatedFiles?: string[];
                  codeSnippet?: string;        // Relevant code excerpt
                  suggestedWorkflow?: string;  // Agent's suggestion (operator can override)
                };
              }
              ```

              ## Operator Response JSON Schema

              The operator responds with decisions AND reasoning:

              ```typescript
              interface OperatorDecision {
                requestId: string;             // Which request this decides
                decision: 'approve' | 'reject' | 'defer' | 'backlog';

                // Required: Explain the reasoning
                reasoning: string;             // Why this decision was made

                // If approved: injection details
                injection?: {
                  workflow?: string;           // Workflow to compile (optional)
                  prompt?: string;             // Direct prompt if no workflow
                  position: InsertPosition;    // Where to inject
                  model?: string;              // Model override
                  idPrefix: string;            // Prefix for generated IDs
                };

                // If deferred: when to revisit
                deferredUntil?: 'end-of-phase' | 'end-of-sprint' | 'next-sprint';

                // If backlog: for human review (NOT auto-implemented)
                backlogEntry?: {
                  category: string;            // e.g., 'tech-debt', 'feature', 'investigation'
                  suggestedPriority: 'high' | 'medium' | 'low';
                  notes: string;               // Additional context for human
                };

                // If rejected: why
                rejectionReason?: string;
              }

              interface OperatorResponse {
                decisions: OperatorDecision[];
                operatorLog: string;           // Summary of operator's analysis
                timestamp: string;
              }
              ```

              ## Decision Types

              | Decision | Behavior |
              |----------|----------|
              | `approve` | Inject step/workflow into sprint immediately |
              | `reject` | Decline with reason, no action taken |
              | `defer` | Queue for later in sprint (end-of-phase, end-of-sprint) |
              | `backlog` | **NEW**: Add to backlog for human review, NOT auto-implemented |

              The `backlog` decision is for items that:
              - Are valid but out of scope for current sprint
              - Need human judgment before implementation
              - Should be tracked but not automatically acted upon
              - May require discussion or prioritization

              ## Backlog Storage

              Backlog items stored in `BACKLOG.yaml` in sprint directory:

              ```yaml
              # .claude/sprints/<sprint-id>/BACKLOG.yaml
              items:
                - id: req_abc123
                  title: "Refactor authentication to use OAuth2"
                  description: "Current auth is basic, should upgrade..."
                  category: tech-debt
                  suggested-priority: medium
                  operator-notes: "Valid improvement but significant scope. Needs arch review."
                  source:
                    request-id: req_abc123
                    discovered-in: development-step-3
                    discovered-at: 2026-01-20T10:00:00Z
                  created-at: 2026-01-20T10:05:00Z
                  status: pending-review  # pending-review | acknowledged | converted-to-issue
              ```

              ## Operator as Skill/Command

              The default operator is implemented as a **skill** that can be:
              - Used as-is with default prompt
              - Overridden at workflow or sprint level
              - Extended with custom logic

              ### Default Operator Skill

              Create: `.claude/skills/sprint-operator/skill.md`

              ```markdown
              # Sprint Operator

              You are the sprint operator responsible for reviewing discovered issues
              and deciding how to handle them.

              ## Your Responsibilities

              1. **Triage**: Assess each request's urgency and relevance
              2. **Decide**: Choose appropriate action (approve/reject/defer/backlog)
              3. **Reason**: Always explain your decision clearly
              4. **Place**: If approving, determine optimal injection point

              ## Decision Guidelines

              ### Approve when:
              - Issue blocks current sprint progress
              - Fix is small and well-defined
              - Directly related to sprint goals

              ### Reject when:
              - Request is invalid or duplicate
              - Already addressed elsewhere
              - Not actually an issue

              ### Defer when:
              - Valid but not urgent
              - Can wait until later in sprint
              - Dependencies not yet ready

              ### Backlog when:
              - Valid but out of scope for sprint
              - Needs human review/discussion
              - Significant scope or architectural impact
              - "Nice to have" improvements

              ## Context Available

              - Sprint goals and progress
              - Current phase and remaining work
              - Request details and context
              - Related files and code snippets
              ```

              ### Override in Workflow/Sprint

              ```yaml
              # workflow.yaml or SPRINT.yaml
              operator:
                enabled: true                  # Default: true
                model: sonnet                  # Model for operator (default: sonnet)
                skill: sprint-operator         # Default skill (can override)
                # OR provide custom prompt:
                prompt: |                      # Overrides skill if provided
                  Custom operator instructions...
              ```

              ## Request Lifecycle

              ```
              Agent discovers issue → Creates OperatorRequest → Added to queue (status: pending)
                                                                      ↓
              Operator reviews (batch or immediate) → Makes decision with reasoning
                                                                      ↓
                                      ┌─────────────────────────────────┼─────────────────────────────────┐
                                      ↓                                 ↓                                 ↓
                                 [approve]                          [reject]                          [defer]
                                      ↓                                 ↓                                 ↓
                            Inject step/workflow              Log rejection reason             Queue for later
                                      ↓                                 ↓                                 ↓
                             status: approved                  status: rejected                 status: deferred
              ```

              ## Requirements

              ### 1. Update Claude Runner

              Modify `claude-runner.ts` to:
              - Use `--output-format json` with schema including `operatorRequests`
              - Parse requests from response
              - Return them to the loop

              ### 2. Request Queue Storage

              Store requests in `PROGRESS.yaml` or separate file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  title: "Fix memory leak in parser"
                  status: pending
                  created-at: 2026-01-20T10:00:00Z
                  discovered-in: development-step-2
                  # ... rest of request

                - id: req_def456
                  title: "Add input validation"
                  status: approved
                  decided-at: 2026-01-20T10:05:00Z
                  decision:
                    reasoning: "Security issue, should be addressed before QA"
                    injection:
                      position: { type: after-current }
                      workflow: bugfix-workflow
                  # ... rest
              ```

              ### 3. Operator Handler

              Create `operator.ts`:
              - Batch process pending requests (or immediate for critical)
              - Run operator prompt with context
              - Parse decisions and reasoning
              - Execute injections for approved requests
              - Update queue status

              ### 4. Operator Trigger Points

              When does operator run?
              - After each phase completes (if pending requests exist)
              - Immediately for `critical` priority requests
              - Can be triggered manually from dashboard

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/claude-runner.ts - parse operatorRequests
              - plugins/m42-sprint/runtime/src/loop.ts - queue requests, trigger operator
              - plugins/m42-sprint/runtime/src/operator.ts - NEW: operator logic with skill loading
              - plugins/m42-sprint/runtime/src/backlog.ts - NEW: backlog management
              - plugins/m42-sprint/runtime/src/types.ts - request/decision types

              **Compiler:**
              - plugins/m42-sprint/compiler/src/types.ts - operator config in workflow schema

              **Skill:**
              - plugins/m42-sprint/skills/sprint-operator/skill.md - NEW: default operator skill

              ## Verification

              1. Create phase that submits operator request:
                 ```yaml
                 - prompt: |
                     Review the code. If you find issues, add them to operatorRequests.
                 ```

              2. Verify request appears in queue with status: pending
              3. Verify operator runs using default skill and makes decision with reasoning
              4. Verify approved requests get injected correctly
              5. Verify rejected/deferred requests logged properly
              6. Verify backlog items written to BACKLOG.yaml for human review
              7. Verify custom operator prompt overrides default skill


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/step-5-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-5

              ## Step Task
              Implement operator request system for discovered issues.

              ## Overview
              Claude can submit requests to the operator when it discovers issues during execution.
              All requests go to the operator queue - no auto-handling modes. The operator (a
              dedicated Claude instance) reviews requests, makes decisions with reasoning, and
              uses dynamic step injection to add work to the sprint.

              ## Phase Result JSON Schema (Agent Response)

              ```typescript
              interface PhaseResult {
                // Existing fields
                status: 'completed' | 'failed' | 'blocked';
                summary: string;
                artifacts?: string[];

                // NEW: Requests for operator review
                operatorRequests?: OperatorRequest[];
              }

              interface OperatorRequest {
                id: string;                    // Unique identifier (nanoid)
                title: string;                 // Short description
                description: string;           // Full description of what needs to be done
                priority: 'critical' | 'high' | 'medium' | 'low';
                type: 'bug' | 'improvement' | 'refactor' | 'test' | 'docs' | 'security';

                // Context for operator decision
                context?: {
                  discoveredIn: string;        // Phase ID where discovered
                  relatedFiles?: string[];
                  codeSnippet?: string;        // Relevant code excerpt
                  suggestedWorkflow?: string;  // Agent's suggestion (operator can override)
                };
              }
              ```

              ## Operator Response JSON Schema

              The operator responds with decisions AND reasoning:

              ```typescript
              interface OperatorDecision {
                requestId: string;             // Which request this decides
                decision: 'approve' | 'reject' | 'defer' | 'backlog';

                // Required: Explain the reasoning
                reasoning: string;             // Why this decision was made

                // If approved: injection details
                injection?: {
                  workflow?: string;           // Workflow to compile (optional)
                  prompt?: string;             // Direct prompt if no workflow
                  position: InsertPosition;    // Where to inject
                  model?: string;              // Model override
                  idPrefix: string;            // Prefix for generated IDs
                };

                // If deferred: when to revisit
                deferredUntil?: 'end-of-phase' | 'end-of-sprint' | 'next-sprint';

                // If backlog: for human review (NOT auto-implemented)
                backlogEntry?: {
                  category: string;            // e.g., 'tech-debt', 'feature', 'investigation'
                  suggestedPriority: 'high' | 'medium' | 'low';
                  notes: string;               // Additional context for human
                };

                // If rejected: why
                rejectionReason?: string;
              }

              interface OperatorResponse {
                decisions: OperatorDecision[];
                operatorLog: string;           // Summary of operator's analysis
                timestamp: string;
              }
              ```

              ## Decision Types

              | Decision | Behavior |
              |----------|----------|
              | `approve` | Inject step/workflow into sprint immediately |
              | `reject` | Decline with reason, no action taken |
              | `defer` | Queue for later in sprint (end-of-phase, end-of-sprint) |
              | `backlog` | **NEW**: Add to backlog for human review, NOT auto-implemented |

              The `backlog` decision is for items that:
              - Are valid but out of scope for current sprint
              - Need human judgment before implementation
              - Should be tracked but not automatically acted upon
              - May require discussion or prioritization

              ## Backlog Storage

              Backlog items stored in `BACKLOG.yaml` in sprint directory:

              ```yaml
              # .claude/sprints/<sprint-id>/BACKLOG.yaml
              items:
                - id: req_abc123
                  title: "Refactor authentication to use OAuth2"
                  description: "Current auth is basic, should upgrade..."
                  category: tech-debt
                  suggested-priority: medium
                  operator-notes: "Valid improvement but significant scope. Needs arch review."
                  source:
                    request-id: req_abc123
                    discovered-in: development-step-3
                    discovered-at: 2026-01-20T10:00:00Z
                  created-at: 2026-01-20T10:05:00Z
                  status: pending-review  # pending-review | acknowledged | converted-to-issue
              ```

              ## Operator as Skill/Command

              The default operator is implemented as a **skill** that can be:
              - Used as-is with default prompt
              - Overridden at workflow or sprint level
              - Extended with custom logic

              ### Default Operator Skill

              Create: `.claude/skills/sprint-operator/skill.md`

              ```markdown
              # Sprint Operator

              You are the sprint operator responsible for reviewing discovered issues
              and deciding how to handle them.

              ## Your Responsibilities

              1. **Triage**: Assess each request's urgency and relevance
              2. **Decide**: Choose appropriate action (approve/reject/defer/backlog)
              3. **Reason**: Always explain your decision clearly
              4. **Place**: If approving, determine optimal injection point

              ## Decision Guidelines

              ### Approve when:
              - Issue blocks current sprint progress
              - Fix is small and well-defined
              - Directly related to sprint goals

              ### Reject when:
              - Request is invalid or duplicate
              - Already addressed elsewhere
              - Not actually an issue

              ### Defer when:
              - Valid but not urgent
              - Can wait until later in sprint
              - Dependencies not yet ready

              ### Backlog when:
              - Valid but out of scope for sprint
              - Needs human review/discussion
              - Significant scope or architectural impact
              - "Nice to have" improvements

              ## Context Available

              - Sprint goals and progress
              - Current phase and remaining work
              - Request details and context
              - Related files and code snippets
              ```

              ### Override in Workflow/Sprint

              ```yaml
              # workflow.yaml or SPRINT.yaml
              operator:
                enabled: true                  # Default: true
                model: sonnet                  # Model for operator (default: sonnet)
                skill: sprint-operator         # Default skill (can override)
                # OR provide custom prompt:
                prompt: |                      # Overrides skill if provided
                  Custom operator instructions...
              ```

              ## Request Lifecycle

              ```
              Agent discovers issue → Creates OperatorRequest → Added to queue (status: pending)
                                                                      ↓
              Operator reviews (batch or immediate) → Makes decision with reasoning
                                                                      ↓
                                      ┌─────────────────────────────────┼─────────────────────────────────┐
                                      ↓                                 ↓                                 ↓
                                 [approve]                          [reject]                          [defer]
                                      ↓                                 ↓                                 ↓
                            Inject step/workflow              Log rejection reason             Queue for later
                                      ↓                                 ↓                                 ↓
                             status: approved                  status: rejected                 status: deferred
              ```

              ## Requirements

              ### 1. Update Claude Runner

              Modify `claude-runner.ts` to:
              - Use `--output-format json` with schema including `operatorRequests`
              - Parse requests from response
              - Return them to the loop

              ### 2. Request Queue Storage

              Store requests in `PROGRESS.yaml` or separate file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  title: "Fix memory leak in parser"
                  status: pending
                  created-at: 2026-01-20T10:00:00Z
                  discovered-in: development-step-2
                  # ... rest of request

                - id: req_def456
                  title: "Add input validation"
                  status: approved
                  decided-at: 2026-01-20T10:05:00Z
                  decision:
                    reasoning: "Security issue, should be addressed before QA"
                    injection:
                      position: { type: after-current }
                      workflow: bugfix-workflow
                  # ... rest
              ```

              ### 3. Operator Handler

              Create `operator.ts`:
              - Batch process pending requests (or immediate for critical)
              - Run operator prompt with context
              - Parse decisions and reasoning
              - Execute injections for approved requests
              - Update queue status

              ### 4. Operator Trigger Points

              When does operator run?
              - After each phase completes (if pending requests exist)
              - Immediately for `critical` priority requests
              - Can be triggered manually from dashboard

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/claude-runner.ts - parse operatorRequests
              - plugins/m42-sprint/runtime/src/loop.ts - queue requests, trigger operator
              - plugins/m42-sprint/runtime/src/operator.ts - NEW: operator logic with skill loading
              - plugins/m42-sprint/runtime/src/backlog.ts - NEW: backlog management
              - plugins/m42-sprint/runtime/src/types.ts - request/decision types

              **Compiler:**
              - plugins/m42-sprint/compiler/src/types.ts - operator config in workflow schema

              **Skill:**
              - plugins/m42-sprint/skills/sprint-operator/skill.md - NEW: default operator skill

              ## Verification

              1. Create phase that submits operator request:
                 ```yaml
                 - prompt: |
                     Review the code. If you find issues, add them to operatorRequests.
                 ```

              2. Verify request appears in queue with status: pending
              3. Verify operator runs using default skill and makes decision with reasoning
              4. Verify approved requests get injected correctly
              5. Verify rejected/deferred requests logged properly
              6. Verify backlog items written to BACKLOG.yaml for human review
              7. Verify custom operator prompt overrides default skill


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/step-5-gherkin.md
              git commit -m "test(step-5): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: '2026-01-20T23:37:20.998Z'
            completed-at: '2026-01-20T23:44:16.895Z'
          - id: green-context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Implement operator request system for discovered issues.

              ## Overview
              Claude can submit requests to the operator when it discovers issues during execution.
              All requests go to the operator queue - no auto-handling modes. The operator (a
              dedicated Claude instance) reviews requests, makes decisions with reasoning, and
              uses dynamic step injection to add work to the sprint.

              ## Phase Result JSON Schema (Agent Response)

              ```typescript
              interface PhaseResult {
                // Existing fields
                status: 'completed' | 'failed' | 'blocked';
                summary: string;
                artifacts?: string[];

                // NEW: Requests for operator review
                operatorRequests?: OperatorRequest[];
              }

              interface OperatorRequest {
                id: string;                    // Unique identifier (nanoid)
                title: string;                 // Short description
                description: string;           // Full description of what needs to be done
                priority: 'critical' | 'high' | 'medium' | 'low';
                type: 'bug' | 'improvement' | 'refactor' | 'test' | 'docs' | 'security';

                // Context for operator decision
                context?: {
                  discoveredIn: string;        // Phase ID where discovered
                  relatedFiles?: string[];
                  codeSnippet?: string;        // Relevant code excerpt
                  suggestedWorkflow?: string;  // Agent's suggestion (operator can override)
                };
              }
              ```

              ## Operator Response JSON Schema

              The operator responds with decisions AND reasoning:

              ```typescript
              interface OperatorDecision {
                requestId: string;             // Which request this decides
                decision: 'approve' | 'reject' | 'defer' | 'backlog';

                // Required: Explain the reasoning
                reasoning: string;             // Why this decision was made

                // If approved: injection details
                injection?: {
                  workflow?: string;           // Workflow to compile (optional)
                  prompt?: string;             // Direct prompt if no workflow
                  position: InsertPosition;    // Where to inject
                  model?: string;              // Model override
                  idPrefix: string;            // Prefix for generated IDs
                };

                // If deferred: when to revisit
                deferredUntil?: 'end-of-phase' | 'end-of-sprint' | 'next-sprint';

                // If backlog: for human review (NOT auto-implemented)
                backlogEntry?: {
                  category: string;            // e.g., 'tech-debt', 'feature', 'investigation'
                  suggestedPriority: 'high' | 'medium' | 'low';
                  notes: string;               // Additional context for human
                };

                // If rejected: why
                rejectionReason?: string;
              }

              interface OperatorResponse {
                decisions: OperatorDecision[];
                operatorLog: string;           // Summary of operator's analysis
                timestamp: string;
              }
              ```

              ## Decision Types

              | Decision | Behavior |
              |----------|----------|
              | `approve` | Inject step/workflow into sprint immediately |
              | `reject` | Decline with reason, no action taken |
              | `defer` | Queue for later in sprint (end-of-phase, end-of-sprint) |
              | `backlog` | **NEW**: Add to backlog for human review, NOT auto-implemented |

              The `backlog` decision is for items that:
              - Are valid but out of scope for current sprint
              - Need human judgment before implementation
              - Should be tracked but not automatically acted upon
              - May require discussion or prioritization

              ## Backlog Storage

              Backlog items stored in `BACKLOG.yaml` in sprint directory:

              ```yaml
              # .claude/sprints/<sprint-id>/BACKLOG.yaml
              items:
                - id: req_abc123
                  title: "Refactor authentication to use OAuth2"
                  description: "Current auth is basic, should upgrade..."
                  category: tech-debt
                  suggested-priority: medium
                  operator-notes: "Valid improvement but significant scope. Needs arch review."
                  source:
                    request-id: req_abc123
                    discovered-in: development-step-3
                    discovered-at: 2026-01-20T10:00:00Z
                  created-at: 2026-01-20T10:05:00Z
                  status: pending-review  # pending-review | acknowledged | converted-to-issue
              ```

              ## Operator as Skill/Command

              The default operator is implemented as a **skill** that can be:
              - Used as-is with default prompt
              - Overridden at workflow or sprint level
              - Extended with custom logic

              ### Default Operator Skill

              Create: `.claude/skills/sprint-operator/skill.md`

              ```markdown
              # Sprint Operator

              You are the sprint operator responsible for reviewing discovered issues
              and deciding how to handle them.

              ## Your Responsibilities

              1. **Triage**: Assess each request's urgency and relevance
              2. **Decide**: Choose appropriate action (approve/reject/defer/backlog)
              3. **Reason**: Always explain your decision clearly
              4. **Place**: If approving, determine optimal injection point

              ## Decision Guidelines

              ### Approve when:
              - Issue blocks current sprint progress
              - Fix is small and well-defined
              - Directly related to sprint goals

              ### Reject when:
              - Request is invalid or duplicate
              - Already addressed elsewhere
              - Not actually an issue

              ### Defer when:
              - Valid but not urgent
              - Can wait until later in sprint
              - Dependencies not yet ready

              ### Backlog when:
              - Valid but out of scope for sprint
              - Needs human review/discussion
              - Significant scope or architectural impact
              - "Nice to have" improvements

              ## Context Available

              - Sprint goals and progress
              - Current phase and remaining work
              - Request details and context
              - Related files and code snippets
              ```

              ### Override in Workflow/Sprint

              ```yaml
              # workflow.yaml or SPRINT.yaml
              operator:
                enabled: true                  # Default: true
                model: sonnet                  # Model for operator (default: sonnet)
                skill: sprint-operator         # Default skill (can override)
                # OR provide custom prompt:
                prompt: |                      # Overrides skill if provided
                  Custom operator instructions...
              ```

              ## Request Lifecycle

              ```
              Agent discovers issue → Creates OperatorRequest → Added to queue (status: pending)
                                                                      ↓
              Operator reviews (batch or immediate) → Makes decision with reasoning
                                                                      ↓
                                      ┌─────────────────────────────────┼─────────────────────────────────┐
                                      ↓                                 ↓                                 ↓
                                 [approve]                          [reject]                          [defer]
                                      ↓                                 ↓                                 ↓
                            Inject step/workflow              Log rejection reason             Queue for later
                                      ↓                                 ↓                                 ↓
                             status: approved                  status: rejected                 status: deferred
              ```

              ## Requirements

              ### 1. Update Claude Runner

              Modify `claude-runner.ts` to:
              - Use `--output-format json` with schema including `operatorRequests`
              - Parse requests from response
              - Return them to the loop

              ### 2. Request Queue Storage

              Store requests in `PROGRESS.yaml` or separate file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  title: "Fix memory leak in parser"
                  status: pending
                  created-at: 2026-01-20T10:00:00Z
                  discovered-in: development-step-2
                  # ... rest of request

                - id: req_def456
                  title: "Add input validation"
                  status: approved
                  decided-at: 2026-01-20T10:05:00Z
                  decision:
                    reasoning: "Security issue, should be addressed before QA"
                    injection:
                      position: { type: after-current }
                      workflow: bugfix-workflow
                  # ... rest
              ```

              ### 3. Operator Handler

              Create `operator.ts`:
              - Batch process pending requests (or immediate for critical)
              - Run operator prompt with context
              - Parse decisions and reasoning
              - Execute injections for approved requests
              - Update queue status

              ### 4. Operator Trigger Points

              When does operator run?
              - After each phase completes (if pending requests exist)
              - Immediately for `critical` priority requests
              - Can be triggered manually from dashboard

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/claude-runner.ts - parse operatorRequests
              - plugins/m42-sprint/runtime/src/loop.ts - queue requests, trigger operator
              - plugins/m42-sprint/runtime/src/operator.ts - NEW: operator logic with skill loading
              - plugins/m42-sprint/runtime/src/backlog.ts - NEW: backlog management
              - plugins/m42-sprint/runtime/src/types.ts - request/decision types

              **Compiler:**
              - plugins/m42-sprint/compiler/src/types.ts - operator config in workflow schema

              **Skill:**
              - plugins/m42-sprint/skills/sprint-operator/skill.md - NEW: default operator skill

              ## Verification

              1. Create phase that submits operator request:
                 ```yaml
                 - prompt: |
                     Review the code. If you find issues, add them to operatorRequests.
                 ```

              2. Verify request appears in queue with status: pending
              3. Verify operator runs using default skill and makes decision with reasoning
              4. Verify approved requests get injected correctly
              5. Verify rejected/deferred requests logged properly
              6. Verify backlog items written to BACKLOG.yaml for human review
              7. Verify custom operator prompt overrides default skill


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/step-5-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/step-5-context.md

              ```markdown
              # Step Context: step-5

              ## Task
              Implement operator request system for discovered issues.

              ## Overview
              Claude can submit requests to the operator when it discovers issues during execution.
              All requests go to the operator queue - no auto-handling modes. The operator (a
              dedicated Claude instance) reviews requests, makes decisions with reasoning, and
              uses dynamic step injection to add work to the sprint.

              ## Phase Result JSON Schema (Agent Response)

              ```typescript
              interface PhaseResult {
                // Existing fields
                status: 'completed' | 'failed' | 'blocked';
                summary: string;
                artifacts?: string[];

                // NEW: Requests for operator review
                operatorRequests?: OperatorRequest[];
              }

              interface OperatorRequest {
                id: string;                    // Unique identifier (nanoid)
                title: string;                 // Short description
                description: string;           // Full description of what needs to be done
                priority: 'critical' | 'high' | 'medium' | 'low';
                type: 'bug' | 'improvement' | 'refactor' | 'test' | 'docs' | 'security';

                // Context for operator decision
                context?: {
                  discoveredIn: string;        // Phase ID where discovered
                  relatedFiles?: string[];
                  codeSnippet?: string;        // Relevant code excerpt
                  suggestedWorkflow?: string;  // Agent's suggestion (operator can override)
                };
              }
              ```

              ## Operator Response JSON Schema

              The operator responds with decisions AND reasoning:

              ```typescript
              interface OperatorDecision {
                requestId: string;             // Which request this decides
                decision: 'approve' | 'reject' | 'defer' | 'backlog';

                // Required: Explain the reasoning
                reasoning: string;             // Why this decision was made

                // If approved: injection details
                injection?: {
                  workflow?: string;           // Workflow to compile (optional)
                  prompt?: string;             // Direct prompt if no workflow
                  position: InsertPosition;    // Where to inject
                  model?: string;              // Model override
                  idPrefix: string;            // Prefix for generated IDs
                };

                // If deferred: when to revisit
                deferredUntil?: 'end-of-phase' | 'end-of-sprint' | 'next-sprint';

                // If backlog: for human review (NOT auto-implemented)
                backlogEntry?: {
                  category: string;            // e.g., 'tech-debt', 'feature', 'investigation'
                  suggestedPriority: 'high' | 'medium' | 'low';
                  notes: string;               // Additional context for human
                };

                // If rejected: why
                rejectionReason?: string;
              }

              interface OperatorResponse {
                decisions: OperatorDecision[];
                operatorLog: string;           // Summary of operator's analysis
                timestamp: string;
              }
              ```

              ## Decision Types

              | Decision | Behavior |
              |----------|----------|
              | `approve` | Inject step/workflow into sprint immediately |
              | `reject` | Decline with reason, no action taken |
              | `defer` | Queue for later in sprint (end-of-phase, end-of-sprint) |
              | `backlog` | **NEW**: Add to backlog for human review, NOT auto-implemented |

              The `backlog` decision is for items that:
              - Are valid but out of scope for current sprint
              - Need human judgment before implementation
              - Should be tracked but not automatically acted upon
              - May require discussion or prioritization

              ## Backlog Storage

              Backlog items stored in `BACKLOG.yaml` in sprint directory:

              ```yaml
              # .claude/sprints/<sprint-id>/BACKLOG.yaml
              items:
                - id: req_abc123
                  title: "Refactor authentication to use OAuth2"
                  description: "Current auth is basic, should upgrade..."
                  category: tech-debt
                  suggested-priority: medium
                  operator-notes: "Valid improvement but significant scope. Needs arch review."
                  source:
                    request-id: req_abc123
                    discovered-in: development-step-3
                    discovered-at: 2026-01-20T10:00:00Z
                  created-at: 2026-01-20T10:05:00Z
                  status: pending-review  # pending-review | acknowledged | converted-to-issue
              ```

              ## Operator as Skill/Command

              The default operator is implemented as a **skill** that can be:
              - Used as-is with default prompt
              - Overridden at workflow or sprint level
              - Extended with custom logic

              ### Default Operator Skill

              Create: `.claude/skills/sprint-operator/skill.md`

              ```markdown
              # Sprint Operator

              You are the sprint operator responsible for reviewing discovered issues
              and deciding how to handle them.

              ## Your Responsibilities

              1. **Triage**: Assess each request's urgency and relevance
              2. **Decide**: Choose appropriate action (approve/reject/defer/backlog)
              3. **Reason**: Always explain your decision clearly
              4. **Place**: If approving, determine optimal injection point

              ## Decision Guidelines

              ### Approve when:
              - Issue blocks current sprint progress
              - Fix is small and well-defined
              - Directly related to sprint goals

              ### Reject when:
              - Request is invalid or duplicate
              - Already addressed elsewhere
              - Not actually an issue

              ### Defer when:
              - Valid but not urgent
              - Can wait until later in sprint
              - Dependencies not yet ready

              ### Backlog when:
              - Valid but out of scope for sprint
              - Needs human review/discussion
              - Significant scope or architectural impact
              - "Nice to have" improvements

              ## Context Available

              - Sprint goals and progress
              - Current phase and remaining work
              - Request details and context
              - Related files and code snippets
              ```

              ### Override in Workflow/Sprint

              ```yaml
              # workflow.yaml or SPRINT.yaml
              operator:
                enabled: true                  # Default: true
                model: sonnet                  # Model for operator (default: sonnet)
                skill: sprint-operator         # Default skill (can override)
                # OR provide custom prompt:
                prompt: |                      # Overrides skill if provided
                  Custom operator instructions...
              ```

              ## Request Lifecycle

              ```
              Agent discovers issue → Creates OperatorRequest → Added to queue (status: pending)
                                                                      ↓
              Operator reviews (batch or immediate) → Makes decision with reasoning
                                                                      ↓
                                      ┌─────────────────────────────────┼─────────────────────────────────┐
                                      ↓                                 ↓                                 ↓
                                 [approve]                          [reject]                          [defer]
                                      ↓                                 ↓                                 ↓
                            Inject step/workflow              Log rejection reason             Queue for later
                                      ↓                                 ↓                                 ↓
                             status: approved                  status: rejected                 status: deferred
              ```

              ## Requirements

              ### 1. Update Claude Runner

              Modify `claude-runner.ts` to:
              - Use `--output-format json` with schema including `operatorRequests`
              - Parse requests from response
              - Return them to the loop

              ### 2. Request Queue Storage

              Store requests in `PROGRESS.yaml` or separate file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  title: "Fix memory leak in parser"
                  status: pending
                  created-at: 2026-01-20T10:00:00Z
                  discovered-in: development-step-2
                  # ... rest of request

                - id: req_def456
                  title: "Add input validation"
                  status: approved
                  decided-at: 2026-01-20T10:05:00Z
                  decision:
                    reasoning: "Security issue, should be addressed before QA"
                    injection:
                      position: { type: after-current }
                      workflow: bugfix-workflow
                  # ... rest
              ```

              ### 3. Operator Handler

              Create `operator.ts`:
              - Batch process pending requests (or immediate for critical)
              - Run operator prompt with context
              - Parse decisions and reasoning
              - Execute injections for approved requests
              - Update queue status

              ### 4. Operator Trigger Points

              When does operator run?
              - After each phase completes (if pending requests exist)
              - Immediately for `critical` priority requests
              - Can be triggered manually from dashboard

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/claude-runner.ts - parse operatorRequests
              - plugins/m42-sprint/runtime/src/loop.ts - queue requests, trigger operator
              - plugins/m42-sprint/runtime/src/operator.ts - NEW: operator logic with skill loading
              - plugins/m42-sprint/runtime/src/backlog.ts - NEW: backlog management
              - plugins/m42-sprint/runtime/src/types.ts - request/decision types

              **Compiler:**
              - plugins/m42-sprint/compiler/src/types.ts - operator config in workflow schema

              **Skill:**
              - plugins/m42-sprint/skills/sprint-operator/skill.md - NEW: default operator skill

              ## Verification

              1. Create phase that submits operator request:
                 ```yaml
                 - prompt: |
                     Review the code. If you find issues, add them to operatorRequests.
                 ```

              2. Verify request appears in queue with status: pending
              3. Verify operator runs using default skill and makes decision with reasoning
              4. Verify approved requests get injected correctly
              5. Verify rejected/deferred requests logged properly
              6. Verify backlog items written to BACKLOG.yaml for human review
              7. Verify custom operator prompt overrides default skill


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/step-5-context.md
              git commit -m "context(step-5): gather implementation context"
              ```
            started-at: '2026-01-20T23:44:17.094Z'
            completed-at: '2026-01-20T23:46:20.416Z'
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              Implement operator request system for discovered issues.

              ## Overview
              Claude can submit requests to the operator when it discovers issues during execution.
              All requests go to the operator queue - no auto-handling modes. The operator (a
              dedicated Claude instance) reviews requests, makes decisions with reasoning, and
              uses dynamic step injection to add work to the sprint.

              ## Phase Result JSON Schema (Agent Response)

              ```typescript
              interface PhaseResult {
                // Existing fields
                status: 'completed' | 'failed' | 'blocked';
                summary: string;
                artifacts?: string[];

                // NEW: Requests for operator review
                operatorRequests?: OperatorRequest[];
              }

              interface OperatorRequest {
                id: string;                    // Unique identifier (nanoid)
                title: string;                 // Short description
                description: string;           // Full description of what needs to be done
                priority: 'critical' | 'high' | 'medium' | 'low';
                type: 'bug' | 'improvement' | 'refactor' | 'test' | 'docs' | 'security';

                // Context for operator decision
                context?: {
                  discoveredIn: string;        // Phase ID where discovered
                  relatedFiles?: string[];
                  codeSnippet?: string;        // Relevant code excerpt
                  suggestedWorkflow?: string;  // Agent's suggestion (operator can override)
                };
              }
              ```

              ## Operator Response JSON Schema

              The operator responds with decisions AND reasoning:

              ```typescript
              interface OperatorDecision {
                requestId: string;             // Which request this decides
                decision: 'approve' | 'reject' | 'defer' | 'backlog';

                // Required: Explain the reasoning
                reasoning: string;             // Why this decision was made

                // If approved: injection details
                injection?: {
                  workflow?: string;           // Workflow to compile (optional)
                  prompt?: string;             // Direct prompt if no workflow
                  position: InsertPosition;    // Where to inject
                  model?: string;              // Model override
                  idPrefix: string;            // Prefix for generated IDs
                };

                // If deferred: when to revisit
                deferredUntil?: 'end-of-phase' | 'end-of-sprint' | 'next-sprint';

                // If backlog: for human review (NOT auto-implemented)
                backlogEntry?: {
                  category: string;            // e.g., 'tech-debt', 'feature', 'investigation'
                  suggestedPriority: 'high' | 'medium' | 'low';
                  notes: string;               // Additional context for human
                };

                // If rejected: why
                rejectionReason?: string;
              }

              interface OperatorResponse {
                decisions: OperatorDecision[];
                operatorLog: string;           // Summary of operator's analysis
                timestamp: string;
              }
              ```

              ## Decision Types

              | Decision | Behavior |
              |----------|----------|
              | `approve` | Inject step/workflow into sprint immediately |
              | `reject` | Decline with reason, no action taken |
              | `defer` | Queue for later in sprint (end-of-phase, end-of-sprint) |
              | `backlog` | **NEW**: Add to backlog for human review, NOT auto-implemented |

              The `backlog` decision is for items that:
              - Are valid but out of scope for current sprint
              - Need human judgment before implementation
              - Should be tracked but not automatically acted upon
              - May require discussion or prioritization

              ## Backlog Storage

              Backlog items stored in `BACKLOG.yaml` in sprint directory:

              ```yaml
              # .claude/sprints/<sprint-id>/BACKLOG.yaml
              items:
                - id: req_abc123
                  title: "Refactor authentication to use OAuth2"
                  description: "Current auth is basic, should upgrade..."
                  category: tech-debt
                  suggested-priority: medium
                  operator-notes: "Valid improvement but significant scope. Needs arch review."
                  source:
                    request-id: req_abc123
                    discovered-in: development-step-3
                    discovered-at: 2026-01-20T10:00:00Z
                  created-at: 2026-01-20T10:05:00Z
                  status: pending-review  # pending-review | acknowledged | converted-to-issue
              ```

              ## Operator as Skill/Command

              The default operator is implemented as a **skill** that can be:
              - Used as-is with default prompt
              - Overridden at workflow or sprint level
              - Extended with custom logic

              ### Default Operator Skill

              Create: `.claude/skills/sprint-operator/skill.md`

              ```markdown
              # Sprint Operator

              You are the sprint operator responsible for reviewing discovered issues
              and deciding how to handle them.

              ## Your Responsibilities

              1. **Triage**: Assess each request's urgency and relevance
              2. **Decide**: Choose appropriate action (approve/reject/defer/backlog)
              3. **Reason**: Always explain your decision clearly
              4. **Place**: If approving, determine optimal injection point

              ## Decision Guidelines

              ### Approve when:
              - Issue blocks current sprint progress
              - Fix is small and well-defined
              - Directly related to sprint goals

              ### Reject when:
              - Request is invalid or duplicate
              - Already addressed elsewhere
              - Not actually an issue

              ### Defer when:
              - Valid but not urgent
              - Can wait until later in sprint
              - Dependencies not yet ready

              ### Backlog when:
              - Valid but out of scope for sprint
              - Needs human review/discussion
              - Significant scope or architectural impact
              - "Nice to have" improvements

              ## Context Available

              - Sprint goals and progress
              - Current phase and remaining work
              - Request details and context
              - Related files and code snippets
              ```

              ### Override in Workflow/Sprint

              ```yaml
              # workflow.yaml or SPRINT.yaml
              operator:
                enabled: true                  # Default: true
                model: sonnet                  # Model for operator (default: sonnet)
                skill: sprint-operator         # Default skill (can override)
                # OR provide custom prompt:
                prompt: |                      # Overrides skill if provided
                  Custom operator instructions...
              ```

              ## Request Lifecycle

              ```
              Agent discovers issue → Creates OperatorRequest → Added to queue (status: pending)
                                                                      ↓
              Operator reviews (batch or immediate) → Makes decision with reasoning
                                                                      ↓
                                      ┌─────────────────────────────────┼─────────────────────────────────┐
                                      ↓                                 ↓                                 ↓
                                 [approve]                          [reject]                          [defer]
                                      ↓                                 ↓                                 ↓
                            Inject step/workflow              Log rejection reason             Queue for later
                                      ↓                                 ↓                                 ↓
                             status: approved                  status: rejected                 status: deferred
              ```

              ## Requirements

              ### 1. Update Claude Runner

              Modify `claude-runner.ts` to:
              - Use `--output-format json` with schema including `operatorRequests`
              - Parse requests from response
              - Return them to the loop

              ### 2. Request Queue Storage

              Store requests in `PROGRESS.yaml` or separate file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  title: "Fix memory leak in parser"
                  status: pending
                  created-at: 2026-01-20T10:00:00Z
                  discovered-in: development-step-2
                  # ... rest of request

                - id: req_def456
                  title: "Add input validation"
                  status: approved
                  decided-at: 2026-01-20T10:05:00Z
                  decision:
                    reasoning: "Security issue, should be addressed before QA"
                    injection:
                      position: { type: after-current }
                      workflow: bugfix-workflow
                  # ... rest
              ```

              ### 3. Operator Handler

              Create `operator.ts`:
              - Batch process pending requests (or immediate for critical)
              - Run operator prompt with context
              - Parse decisions and reasoning
              - Execute injections for approved requests
              - Update queue status

              ### 4. Operator Trigger Points

              When does operator run?
              - After each phase completes (if pending requests exist)
              - Immediately for `critical` priority requests
              - Can be triggered manually from dashboard

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/claude-runner.ts - parse operatorRequests
              - plugins/m42-sprint/runtime/src/loop.ts - queue requests, trigger operator
              - plugins/m42-sprint/runtime/src/operator.ts - NEW: operator logic with skill loading
              - plugins/m42-sprint/runtime/src/backlog.ts - NEW: backlog management
              - plugins/m42-sprint/runtime/src/types.ts - request/decision types

              **Compiler:**
              - plugins/m42-sprint/compiler/src/types.ts - operator config in workflow schema

              **Skill:**
              - plugins/m42-sprint/skills/sprint-operator/skill.md - NEW: default operator skill

              ## Verification

              1. Create phase that submits operator request:
                 ```yaml
                 - prompt: |
                     Review the code. If you find issues, add them to operatorRequests.
                 ```

              2. Verify request appears in queue with status: pending
              3. Verify operator runs using default skill and makes decision with reasoning
              4. Verify approved requests get injected correctly
              5. Verify rejected/deferred requests logged properly
              6. Verify backlog items written to BACKLOG.yaml for human review
              7. Verify custom operator prompt overrides default skill


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/step-5-gherkin.md (scenarios to satisfy)
              3. context/step-5-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(step-5): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: '2026-01-20T23:46:22.481Z'
            completed-at: '2026-01-20T23:50:35.424Z'
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              Implement operator request system for discovered issues.

              ## Overview
              Claude can submit requests to the operator when it discovers issues during execution.
              All requests go to the operator queue - no auto-handling modes. The operator (a
              dedicated Claude instance) reviews requests, makes decisions with reasoning, and
              uses dynamic step injection to add work to the sprint.

              ## Phase Result JSON Schema (Agent Response)

              ```typescript
              interface PhaseResult {
                // Existing fields
                status: 'completed' | 'failed' | 'blocked';
                summary: string;
                artifacts?: string[];

                // NEW: Requests for operator review
                operatorRequests?: OperatorRequest[];
              }

              interface OperatorRequest {
                id: string;                    // Unique identifier (nanoid)
                title: string;                 // Short description
                description: string;           // Full description of what needs to be done
                priority: 'critical' | 'high' | 'medium' | 'low';
                type: 'bug' | 'improvement' | 'refactor' | 'test' | 'docs' | 'security';

                // Context for operator decision
                context?: {
                  discoveredIn: string;        // Phase ID where discovered
                  relatedFiles?: string[];
                  codeSnippet?: string;        // Relevant code excerpt
                  suggestedWorkflow?: string;  // Agent's suggestion (operator can override)
                };
              }
              ```

              ## Operator Response JSON Schema

              The operator responds with decisions AND reasoning:

              ```typescript
              interface OperatorDecision {
                requestId: string;             // Which request this decides
                decision: 'approve' | 'reject' | 'defer' | 'backlog';

                // Required: Explain the reasoning
                reasoning: string;             // Why this decision was made

                // If approved: injection details
                injection?: {
                  workflow?: string;           // Workflow to compile (optional)
                  prompt?: string;             // Direct prompt if no workflow
                  position: InsertPosition;    // Where to inject
                  model?: string;              // Model override
                  idPrefix: string;            // Prefix for generated IDs
                };

                // If deferred: when to revisit
                deferredUntil?: 'end-of-phase' | 'end-of-sprint' | 'next-sprint';

                // If backlog: for human review (NOT auto-implemented)
                backlogEntry?: {
                  category: string;            // e.g., 'tech-debt', 'feature', 'investigation'
                  suggestedPriority: 'high' | 'medium' | 'low';
                  notes: string;               // Additional context for human
                };

                // If rejected: why
                rejectionReason?: string;
              }

              interface OperatorResponse {
                decisions: OperatorDecision[];
                operatorLog: string;           // Summary of operator's analysis
                timestamp: string;
              }
              ```

              ## Decision Types

              | Decision | Behavior |
              |----------|----------|
              | `approve` | Inject step/workflow into sprint immediately |
              | `reject` | Decline with reason, no action taken |
              | `defer` | Queue for later in sprint (end-of-phase, end-of-sprint) |
              | `backlog` | **NEW**: Add to backlog for human review, NOT auto-implemented |

              The `backlog` decision is for items that:
              - Are valid but out of scope for current sprint
              - Need human judgment before implementation
              - Should be tracked but not automatically acted upon
              - May require discussion or prioritization

              ## Backlog Storage

              Backlog items stored in `BACKLOG.yaml` in sprint directory:

              ```yaml
              # .claude/sprints/<sprint-id>/BACKLOG.yaml
              items:
                - id: req_abc123
                  title: "Refactor authentication to use OAuth2"
                  description: "Current auth is basic, should upgrade..."
                  category: tech-debt
                  suggested-priority: medium
                  operator-notes: "Valid improvement but significant scope. Needs arch review."
                  source:
                    request-id: req_abc123
                    discovered-in: development-step-3
                    discovered-at: 2026-01-20T10:00:00Z
                  created-at: 2026-01-20T10:05:00Z
                  status: pending-review  # pending-review | acknowledged | converted-to-issue
              ```

              ## Operator as Skill/Command

              The default operator is implemented as a **skill** that can be:
              - Used as-is with default prompt
              - Overridden at workflow or sprint level
              - Extended with custom logic

              ### Default Operator Skill

              Create: `.claude/skills/sprint-operator/skill.md`

              ```markdown
              # Sprint Operator

              You are the sprint operator responsible for reviewing discovered issues
              and deciding how to handle them.

              ## Your Responsibilities

              1. **Triage**: Assess each request's urgency and relevance
              2. **Decide**: Choose appropriate action (approve/reject/defer/backlog)
              3. **Reason**: Always explain your decision clearly
              4. **Place**: If approving, determine optimal injection point

              ## Decision Guidelines

              ### Approve when:
              - Issue blocks current sprint progress
              - Fix is small and well-defined
              - Directly related to sprint goals

              ### Reject when:
              - Request is invalid or duplicate
              - Already addressed elsewhere
              - Not actually an issue

              ### Defer when:
              - Valid but not urgent
              - Can wait until later in sprint
              - Dependencies not yet ready

              ### Backlog when:
              - Valid but out of scope for sprint
              - Needs human review/discussion
              - Significant scope or architectural impact
              - "Nice to have" improvements

              ## Context Available

              - Sprint goals and progress
              - Current phase and remaining work
              - Request details and context
              - Related files and code snippets
              ```

              ### Override in Workflow/Sprint

              ```yaml
              # workflow.yaml or SPRINT.yaml
              operator:
                enabled: true                  # Default: true
                model: sonnet                  # Model for operator (default: sonnet)
                skill: sprint-operator         # Default skill (can override)
                # OR provide custom prompt:
                prompt: |                      # Overrides skill if provided
                  Custom operator instructions...
              ```

              ## Request Lifecycle

              ```
              Agent discovers issue → Creates OperatorRequest → Added to queue (status: pending)
                                                                      ↓
              Operator reviews (batch or immediate) → Makes decision with reasoning
                                                                      ↓
                                      ┌─────────────────────────────────┼─────────────────────────────────┐
                                      ↓                                 ↓                                 ↓
                                 [approve]                          [reject]                          [defer]
                                      ↓                                 ↓                                 ↓
                            Inject step/workflow              Log rejection reason             Queue for later
                                      ↓                                 ↓                                 ↓
                             status: approved                  status: rejected                 status: deferred
              ```

              ## Requirements

              ### 1. Update Claude Runner

              Modify `claude-runner.ts` to:
              - Use `--output-format json` with schema including `operatorRequests`
              - Parse requests from response
              - Return them to the loop

              ### 2. Request Queue Storage

              Store requests in `PROGRESS.yaml` or separate file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  title: "Fix memory leak in parser"
                  status: pending
                  created-at: 2026-01-20T10:00:00Z
                  discovered-in: development-step-2
                  # ... rest of request

                - id: req_def456
                  title: "Add input validation"
                  status: approved
                  decided-at: 2026-01-20T10:05:00Z
                  decision:
                    reasoning: "Security issue, should be addressed before QA"
                    injection:
                      position: { type: after-current }
                      workflow: bugfix-workflow
                  # ... rest
              ```

              ### 3. Operator Handler

              Create `operator.ts`:
              - Batch process pending requests (or immediate for critical)
              - Run operator prompt with context
              - Parse decisions and reasoning
              - Execute injections for approved requests
              - Update queue status

              ### 4. Operator Trigger Points

              When does operator run?
              - After each phase completes (if pending requests exist)
              - Immediately for `critical` priority requests
              - Can be triggered manually from dashboard

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/claude-runner.ts - parse operatorRequests
              - plugins/m42-sprint/runtime/src/loop.ts - queue requests, trigger operator
              - plugins/m42-sprint/runtime/src/operator.ts - NEW: operator logic with skill loading
              - plugins/m42-sprint/runtime/src/backlog.ts - NEW: backlog management
              - plugins/m42-sprint/runtime/src/types.ts - request/decision types

              **Compiler:**
              - plugins/m42-sprint/compiler/src/types.ts - operator config in workflow schema

              **Skill:**
              - plugins/m42-sprint/skills/sprint-operator/skill.md - NEW: default operator skill

              ## Verification

              1. Create phase that submits operator request:
                 ```yaml
                 - prompt: |
                     Review the code. If you find issues, add them to operatorRequests.
                 ```

              2. Verify request appears in queue with status: pending
              3. Verify operator runs using default skill and makes decision with reasoning
              4. Verify approved requests get injected correctly
              5. Verify rejected/deferred requests logged properly
              6. Verify backlog items written to BACKLOG.yaml for human review
              7. Verify custom operator prompt overrides default skill


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/step-5-context.md (target patterns)
              Read: artifacts/step-5-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(step-5): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: '2026-01-20T23:50:37.505Z'
            completed-at: '2026-01-20T23:57:33.310Z'
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-5-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/step-5-qa-report.md

              ```markdown
              # QA Report: step-5

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/step-5-qa-report.md
              git commit -m "qa(step-5): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for step-5.\n\nRead: artifacts/step-5-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/step-5-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: '2026-01-20T23:57:35.417Z'
            completed-at: '2026-01-21T00:09:17.408Z'
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Implement operator request system for discovered issues.

              ## Overview
              Claude can submit requests to the operator when it discovers issues during execution.
              All requests go to the operator queue - no auto-handling modes. The operator (a
              dedicated Claude instance) reviews requests, makes decisions with reasoning, and
              uses dynamic step injection to add work to the sprint.

              ## Phase Result JSON Schema (Agent Response)

              ```typescript
              interface PhaseResult {
                // Existing fields
                status: 'completed' | 'failed' | 'blocked';
                summary: string;
                artifacts?: string[];

                // NEW: Requests for operator review
                operatorRequests?: OperatorRequest[];
              }

              interface OperatorRequest {
                id: string;                    // Unique identifier (nanoid)
                title: string;                 // Short description
                description: string;           // Full description of what needs to be done
                priority: 'critical' | 'high' | 'medium' | 'low';
                type: 'bug' | 'improvement' | 'refactor' | 'test' | 'docs' | 'security';

                // Context for operator decision
                context?: {
                  discoveredIn: string;        // Phase ID where discovered
                  relatedFiles?: string[];
                  codeSnippet?: string;        // Relevant code excerpt
                  suggestedWorkflow?: string;  // Agent's suggestion (operator can override)
                };
              }
              ```

              ## Operator Response JSON Schema

              The operator responds with decisions AND reasoning:

              ```typescript
              interface OperatorDecision {
                requestId: string;             // Which request this decides
                decision: 'approve' | 'reject' | 'defer' | 'backlog';

                // Required: Explain the reasoning
                reasoning: string;             // Why this decision was made

                // If approved: injection details
                injection?: {
                  workflow?: string;           // Workflow to compile (optional)
                  prompt?: string;             // Direct prompt if no workflow
                  position: InsertPosition;    // Where to inject
                  model?: string;              // Model override
                  idPrefix: string;            // Prefix for generated IDs
                };

                // If deferred: when to revisit
                deferredUntil?: 'end-of-phase' | 'end-of-sprint' | 'next-sprint';

                // If backlog: for human review (NOT auto-implemented)
                backlogEntry?: {
                  category: string;            // e.g., 'tech-debt', 'feature', 'investigation'
                  suggestedPriority: 'high' | 'medium' | 'low';
                  notes: string;               // Additional context for human
                };

                // If rejected: why
                rejectionReason?: string;
              }

              interface OperatorResponse {
                decisions: OperatorDecision[];
                operatorLog: string;           // Summary of operator's analysis
                timestamp: string;
              }
              ```

              ## Decision Types

              | Decision | Behavior |
              |----------|----------|
              | `approve` | Inject step/workflow into sprint immediately |
              | `reject` | Decline with reason, no action taken |
              | `defer` | Queue for later in sprint (end-of-phase, end-of-sprint) |
              | `backlog` | **NEW**: Add to backlog for human review, NOT auto-implemented |

              The `backlog` decision is for items that:
              - Are valid but out of scope for current sprint
              - Need human judgment before implementation
              - Should be tracked but not automatically acted upon
              - May require discussion or prioritization

              ## Backlog Storage

              Backlog items stored in `BACKLOG.yaml` in sprint directory:

              ```yaml
              # .claude/sprints/<sprint-id>/BACKLOG.yaml
              items:
                - id: req_abc123
                  title: "Refactor authentication to use OAuth2"
                  description: "Current auth is basic, should upgrade..."
                  category: tech-debt
                  suggested-priority: medium
                  operator-notes: "Valid improvement but significant scope. Needs arch review."
                  source:
                    request-id: req_abc123
                    discovered-in: development-step-3
                    discovered-at: 2026-01-20T10:00:00Z
                  created-at: 2026-01-20T10:05:00Z
                  status: pending-review  # pending-review | acknowledged | converted-to-issue
              ```

              ## Operator as Skill/Command

              The default operator is implemented as a **skill** that can be:
              - Used as-is with default prompt
              - Overridden at workflow or sprint level
              - Extended with custom logic

              ### Default Operator Skill

              Create: `.claude/skills/sprint-operator/skill.md`

              ```markdown
              # Sprint Operator

              You are the sprint operator responsible for reviewing discovered issues
              and deciding how to handle them.

              ## Your Responsibilities

              1. **Triage**: Assess each request's urgency and relevance
              2. **Decide**: Choose appropriate action (approve/reject/defer/backlog)
              3. **Reason**: Always explain your decision clearly
              4. **Place**: If approving, determine optimal injection point

              ## Decision Guidelines

              ### Approve when:
              - Issue blocks current sprint progress
              - Fix is small and well-defined
              - Directly related to sprint goals

              ### Reject when:
              - Request is invalid or duplicate
              - Already addressed elsewhere
              - Not actually an issue

              ### Defer when:
              - Valid but not urgent
              - Can wait until later in sprint
              - Dependencies not yet ready

              ### Backlog when:
              - Valid but out of scope for sprint
              - Needs human review/discussion
              - Significant scope or architectural impact
              - "Nice to have" improvements

              ## Context Available

              - Sprint goals and progress
              - Current phase and remaining work
              - Request details and context
              - Related files and code snippets
              ```

              ### Override in Workflow/Sprint

              ```yaml
              # workflow.yaml or SPRINT.yaml
              operator:
                enabled: true                  # Default: true
                model: sonnet                  # Model for operator (default: sonnet)
                skill: sprint-operator         # Default skill (can override)
                # OR provide custom prompt:
                prompt: |                      # Overrides skill if provided
                  Custom operator instructions...
              ```

              ## Request Lifecycle

              ```
              Agent discovers issue → Creates OperatorRequest → Added to queue (status: pending)
                                                                      ↓
              Operator reviews (batch or immediate) → Makes decision with reasoning
                                                                      ↓
                                      ┌─────────────────────────────────┼─────────────────────────────────┐
                                      ↓                                 ↓                                 ↓
                                 [approve]                          [reject]                          [defer]
                                      ↓                                 ↓                                 ↓
                            Inject step/workflow              Log rejection reason             Queue for later
                                      ↓                                 ↓                                 ↓
                             status: approved                  status: rejected                 status: deferred
              ```

              ## Requirements

              ### 1. Update Claude Runner

              Modify `claude-runner.ts` to:
              - Use `--output-format json` with schema including `operatorRequests`
              - Parse requests from response
              - Return them to the loop

              ### 2. Request Queue Storage

              Store requests in `PROGRESS.yaml` or separate file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  title: "Fix memory leak in parser"
                  status: pending
                  created-at: 2026-01-20T10:00:00Z
                  discovered-in: development-step-2
                  # ... rest of request

                - id: req_def456
                  title: "Add input validation"
                  status: approved
                  decided-at: 2026-01-20T10:05:00Z
                  decision:
                    reasoning: "Security issue, should be addressed before QA"
                    injection:
                      position: { type: after-current }
                      workflow: bugfix-workflow
                  # ... rest
              ```

              ### 3. Operator Handler

              Create `operator.ts`:
              - Batch process pending requests (or immediate for critical)
              - Run operator prompt with context
              - Parse decisions and reasoning
              - Execute injections for approved requests
              - Update queue status

              ### 4. Operator Trigger Points

              When does operator run?
              - After each phase completes (if pending requests exist)
              - Immediately for `critical` priority requests
              - Can be triggered manually from dashboard

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/claude-runner.ts - parse operatorRequests
              - plugins/m42-sprint/runtime/src/loop.ts - queue requests, trigger operator
              - plugins/m42-sprint/runtime/src/operator.ts - NEW: operator logic with skill loading
              - plugins/m42-sprint/runtime/src/backlog.ts - NEW: backlog management
              - plugins/m42-sprint/runtime/src/types.ts - request/decision types

              **Compiler:**
              - plugins/m42-sprint/compiler/src/types.ts - operator config in workflow schema

              **Skill:**
              - plugins/m42-sprint/skills/sprint-operator/skill.md - NEW: default operator skill

              ## Verification

              1. Create phase that submits operator request:
                 ```yaml
                 - prompt: |
                     Review the code. If you find issues, add them to operatorRequests.
                 ```

              2. Verify request appears in queue with status: pending
              3. Verify operator runs using default skill and makes decision with reasoning
              4. Verify approved requests get injected correctly
              5. Verify rejected/deferred requests logged properly
              6. Verify backlog items written to BACKLOG.yaml for human review
              7. Verify custom operator prompt overrides default skill


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-5-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(step-5): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: '2026-01-21T00:09:19.477Z'
            completed-at: '2026-01-21T00:11:53.369Z'
        started-at: '2026-01-20T23:36:23.819Z'
        completed-at: '2026-01-21T00:11:53.369Z'
      - id: step-6
        prompt: |
          Implement dynamic step injection into running sprints.

          ## Overview
          Allow adding steps to PROGRESS.yaml at runtime:
          - Add single steps to a specific position
          - Compile a workflow to add multiple steps
          - Choose insertion point (after current, end of phase, specific position)

          This is required for the operator and suggested-steps features.

          ## API Design

          ### Single Step Injection

          ```typescript
          interface StepInjection {
            step: {
              id: string;
              prompt: string;
              model?: string;
            };
            position: InsertPosition;
          }

          type InsertPosition =
            | { type: 'after-current' }                    // After currently executing step
            | { type: 'after-step'; stepId: string }      // After specific step
            | { type: 'end-of-phase'; phaseId: string }   // At end of specific phase
            | { type: 'end-of-workflow' }                 // At very end
            | { type: 'before-step'; stepId: string };    // Before specific step
          ```

          ### Workflow-Based Injection

          ```typescript
          interface WorkflowInjection {
            workflow: string;           // Workflow name to compile
            context?: {                 // Context for the workflow
              step?: StepDefinition;    // If workflow uses for-each: step
              variables?: Record<string, any>;
            };
            position: InsertPosition;
            idPrefix: string;           // Prefix for generated phase IDs
          }
          ```

          ## Implementation

          ### 1. Progress File Manipulation

          Create `progress-injector.ts`:

          ```typescript
          export class ProgressInjector {
            constructor(private progressPath: string) {}

            // Inject single step
            async injectStep(injection: StepInjection): Promise<void> {
              const progress = await this.loadProgress();
              const insertIndex = this.resolvePosition(progress, injection.position);

              // Create phase entry
              const phase = {
                id: injection.step.id,
                prompt: injection.step.prompt,
                status: 'pending',
                model: injection.step.model,
                injected: true,  // Mark as dynamically injected
                'injected-at': new Date().toISOString(),
              };

              // Insert at position
              progress.phases.splice(insertIndex, 0, phase);

              // Recalculate stats
              this.updateStats(progress);

              await this.saveProgress(progress);
            }

            // Inject compiled workflow
            async injectWorkflow(injection: WorkflowInjection): Promise<void> {
              // Load and compile workflow
              const compiledPhases = await compileWorkflow(
                injection.workflow,
                injection.context
              );

              // Prefix IDs
              const prefixedPhases = compiledPhases.map(phase => ({
                ...phase,
                id: `${injection.idPrefix}-${phase.id}`,
                injected: true,
                'injected-at': new Date().toISOString(),
              }));

              // Insert all phases at position
              const progress = await this.loadProgress();
              const insertIndex = this.resolvePosition(progress, injection.position);
              progress.phases.splice(insertIndex, 0, ...prefixedPhases);

              this.updateStats(progress);
              await this.saveProgress(progress);
            }

            private resolvePosition(progress: Progress, pos: InsertPosition): number {
              switch (pos.type) {
                case 'after-current':
                  return this.findCurrentIndex(progress) + 1;
                case 'after-step':
                  return this.findStepIndex(progress, pos.stepId) + 1;
                case 'before-step':
                  return this.findStepIndex(progress, pos.stepId);
                case 'end-of-phase':
                  return this.findPhaseEndIndex(progress, pos.phaseId);
                case 'end-of-workflow':
                  return progress.phases.length;
              }
            }
          }
          ```

          ### 2. Integration with Loop

          Modify `loop.ts` to:
          - Detect injected steps (phases with `injected: true`)
          - Handle them like regular phases
          - Log injection events to activity

          ### 3. Dashboard Display

          Show injected steps distinctly:
          - Different icon/badge for injected steps
          - Show injection timestamp
          - Indicate source (operator, suggested-step, manual)

          ### 4. CLI Command (Optional)

          Add command for manual injection:
          ```bash
          m42-sprint inject-step <sprint-path> \
            --prompt "Fix the bug in auth.ts" \
            --position after-current \
            --workflow bugfix-workflow
          ```

          ## Files to Modify

          **Runtime:**
          - plugins/m42-sprint/runtime/src/progress-injector.ts - NEW: injection logic
          - plugins/m42-sprint/runtime/src/loop.ts - integrate injector
          - plugins/m42-sprint/runtime/src/cli.ts - add inject-step command

          **Compiler:**
          - plugins/m42-sprint/compiler/src/compile.ts - export compile function for runtime use

          **Dashboard:**
          - plugins/m42-sprint/compiler/src/status-server/page.ts - show injected badge
          - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include injection info

          ## Verification

          1. Inject a step manually via API:
             ```typescript
             const injector = new ProgressInjector(progressPath);
             await injector.injectStep({
               step: { id: 'hotfix-1', prompt: 'Fix critical bug' },
               position: { type: 'after-current' }
             });
             ```

          2. Verify PROGRESS.yaml updated correctly
          3. Verify loop executes injected step
          4. Verify dashboard shows injected badge

          5. Test workflow injection:
             ```typescript
             await injector.injectWorkflow({
               workflow: 'bugfix-workflow',
               context: { variables: { issue: 'Auth token expiry' } },
               position: { type: 'end-of-phase', phaseId: 'development' },
               idPrefix: 'hotfix'
             });
             ```
        status: in-progress
        phases:
          - id: context
            status: completed
            prompt: |
              Prepare context for TDD development.

              ## Step 0: Ensure Working in Worktree (if applicable)
              ```bash
              # If trees directory exists, switch to worktree
              if [ -d "trees/2026-01-20_dashboard-improvements" ]; then
                cd trees/2026-01-20_dashboard-improvements
              fi
              pwd
              git branch --show-current
              ```

              ## Step 1: Read Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Step 2: Understand the Step
              Implement dynamic step injection into running sprints.

              ## Overview
              Allow adding steps to PROGRESS.yaml at runtime:
              - Add single steps to a specific position
              - Compile a workflow to add multiple steps
              - Choose insertion point (after current, end of phase, specific position)

              This is required for the operator and suggested-steps features.

              ## API Design

              ### Single Step Injection

              ```typescript
              interface StepInjection {
                step: {
                  id: string;
                  prompt: string;
                  model?: string;
                };
                position: InsertPosition;
              }

              type InsertPosition =
                | { type: 'after-current' }                    // After currently executing step
                | { type: 'after-step'; stepId: string }      // After specific step
                | { type: 'end-of-phase'; phaseId: string }   // At end of specific phase
                | { type: 'end-of-workflow' }                 // At very end
                | { type: 'before-step'; stepId: string };    // Before specific step
              ```

              ### Workflow-Based Injection

              ```typescript
              interface WorkflowInjection {
                workflow: string;           // Workflow name to compile
                context?: {                 // Context for the workflow
                  step?: StepDefinition;    // If workflow uses for-each: step
                  variables?: Record<string, any>;
                };
                position: InsertPosition;
                idPrefix: string;           // Prefix for generated phase IDs
              }
              ```

              ## Implementation

              ### 1. Progress File Manipulation

              Create `progress-injector.ts`:

              ```typescript
              export class ProgressInjector {
                constructor(private progressPath: string) {}

                // Inject single step
                async injectStep(injection: StepInjection): Promise<void> {
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);

                  // Create phase entry
                  const phase = {
                    id: injection.step.id,
                    prompt: injection.step.prompt,
                    status: 'pending',
                    model: injection.step.model,
                    injected: true,  // Mark as dynamically injected
                    'injected-at': new Date().toISOString(),
                  };

                  // Insert at position
                  progress.phases.splice(insertIndex, 0, phase);

                  // Recalculate stats
                  this.updateStats(progress);

                  await this.saveProgress(progress);
                }

                // Inject compiled workflow
                async injectWorkflow(injection: WorkflowInjection): Promise<void> {
                  // Load and compile workflow
                  const compiledPhases = await compileWorkflow(
                    injection.workflow,
                    injection.context
                  );

                  // Prefix IDs
                  const prefixedPhases = compiledPhases.map(phase => ({
                    ...phase,
                    id: `${injection.idPrefix}-${phase.id}`,
                    injected: true,
                    'injected-at': new Date().toISOString(),
                  }));

                  // Insert all phases at position
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);
                  progress.phases.splice(insertIndex, 0, ...prefixedPhases);

                  this.updateStats(progress);
                  await this.saveProgress(progress);
                }

                private resolvePosition(progress: Progress, pos: InsertPosition): number {
                  switch (pos.type) {
                    case 'after-current':
                      return this.findCurrentIndex(progress) + 1;
                    case 'after-step':
                      return this.findStepIndex(progress, pos.stepId) + 1;
                    case 'before-step':
                      return this.findStepIndex(progress, pos.stepId);
                    case 'end-of-phase':
                      return this.findPhaseEndIndex(progress, pos.phaseId);
                    case 'end-of-workflow':
                      return progress.phases.length;
                  }
                }
              }
              ```

              ### 2. Integration with Loop

              Modify `loop.ts` to:
              - Detect injected steps (phases with `injected: true`)
              - Handle them like regular phases
              - Log injection events to activity

              ### 3. Dashboard Display

              Show injected steps distinctly:
              - Different icon/badge for injected steps
              - Show injection timestamp
              - Indicate source (operator, suggested-step, manual)

              ### 4. CLI Command (Optional)

              Add command for manual injection:
              ```bash
              m42-sprint inject-step <sprint-path> \
                --prompt "Fix the bug in auth.ts" \
                --position after-current \
                --workflow bugfix-workflow
              ```

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/progress-injector.ts - NEW: injection logic
              - plugins/m42-sprint/runtime/src/loop.ts - integrate injector
              - plugins/m42-sprint/runtime/src/cli.ts - add inject-step command

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - export compile function for runtime use

              **Dashboard:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - show injected badge
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include injection info

              ## Verification

              1. Inject a step manually via API:
                 ```typescript
                 const injector = new ProgressInjector(progressPath);
                 await injector.injectStep({
                   step: { id: 'hotfix-1', prompt: 'Fix critical bug' },
                   position: { type: 'after-current' }
                 });
                 ```

              2. Verify PROGRESS.yaml updated correctly
              3. Verify loop executes injected step
              4. Verify dashboard shows injected badge

              5. Test workflow injection:
                 ```typescript
                 await injector.injectWorkflow({
                   workflow: 'bugfix-workflow',
                   context: { variables: { issue: 'Auth token expiry' } },
                   position: { type: 'end-of-phase', phaseId: 'development' },
                   idPrefix: 'hotfix'
                 });
                 ```


              ## Output
              Confirm understanding of:
              - Test patterns and locations
              - Build/test commands
              - The step requirements
            started-at: '2026-01-21T00:11:55.461Z'
            completed-at: '2026-01-21T00:12:20.510Z'
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              Implement dynamic step injection into running sprints.

              ## Overview
              Allow adding steps to PROGRESS.yaml at runtime:
              - Add single steps to a specific position
              - Compile a workflow to add multiple steps
              - Choose insertion point (after current, end of phase, specific position)

              This is required for the operator and suggested-steps features.

              ## API Design

              ### Single Step Injection

              ```typescript
              interface StepInjection {
                step: {
                  id: string;
                  prompt: string;
                  model?: string;
                };
                position: InsertPosition;
              }

              type InsertPosition =
                | { type: 'after-current' }                    // After currently executing step
                | { type: 'after-step'; stepId: string }      // After specific step
                | { type: 'end-of-phase'; phaseId: string }   // At end of specific phase
                | { type: 'end-of-workflow' }                 // At very end
                | { type: 'before-step'; stepId: string };    // Before specific step
              ```

              ### Workflow-Based Injection

              ```typescript
              interface WorkflowInjection {
                workflow: string;           // Workflow name to compile
                context?: {                 // Context for the workflow
                  step?: StepDefinition;    // If workflow uses for-each: step
                  variables?: Record<string, any>;
                };
                position: InsertPosition;
                idPrefix: string;           // Prefix for generated phase IDs
              }
              ```

              ## Implementation

              ### 1. Progress File Manipulation

              Create `progress-injector.ts`:

              ```typescript
              export class ProgressInjector {
                constructor(private progressPath: string) {}

                // Inject single step
                async injectStep(injection: StepInjection): Promise<void> {
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);

                  // Create phase entry
                  const phase = {
                    id: injection.step.id,
                    prompt: injection.step.prompt,
                    status: 'pending',
                    model: injection.step.model,
                    injected: true,  // Mark as dynamically injected
                    'injected-at': new Date().toISOString(),
                  };

                  // Insert at position
                  progress.phases.splice(insertIndex, 0, phase);

                  // Recalculate stats
                  this.updateStats(progress);

                  await this.saveProgress(progress);
                }

                // Inject compiled workflow
                async injectWorkflow(injection: WorkflowInjection): Promise<void> {
                  // Load and compile workflow
                  const compiledPhases = await compileWorkflow(
                    injection.workflow,
                    injection.context
                  );

                  // Prefix IDs
                  const prefixedPhases = compiledPhases.map(phase => ({
                    ...phase,
                    id: `${injection.idPrefix}-${phase.id}`,
                    injected: true,
                    'injected-at': new Date().toISOString(),
                  }));

                  // Insert all phases at position
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);
                  progress.phases.splice(insertIndex, 0, ...prefixedPhases);

                  this.updateStats(progress);
                  await this.saveProgress(progress);
                }

                private resolvePosition(progress: Progress, pos: InsertPosition): number {
                  switch (pos.type) {
                    case 'after-current':
                      return this.findCurrentIndex(progress) + 1;
                    case 'after-step':
                      return this.findStepIndex(progress, pos.stepId) + 1;
                    case 'before-step':
                      return this.findStepIndex(progress, pos.stepId);
                    case 'end-of-phase':
                      return this.findPhaseEndIndex(progress, pos.phaseId);
                    case 'end-of-workflow':
                      return progress.phases.length;
                  }
                }
              }
              ```

              ### 2. Integration with Loop

              Modify `loop.ts` to:
              - Detect injected steps (phases with `injected: true`)
              - Handle them like regular phases
              - Log injection events to activity

              ### 3. Dashboard Display

              Show injected steps distinctly:
              - Different icon/badge for injected steps
              - Show injection timestamp
              - Indicate source (operator, suggested-step, manual)

              ### 4. CLI Command (Optional)

              Add command for manual injection:
              ```bash
              m42-sprint inject-step <sprint-path> \
                --prompt "Fix the bug in auth.ts" \
                --position after-current \
                --workflow bugfix-workflow
              ```

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/progress-injector.ts - NEW: injection logic
              - plugins/m42-sprint/runtime/src/loop.ts - integrate injector
              - plugins/m42-sprint/runtime/src/cli.ts - add inject-step command

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - export compile function for runtime use

              **Dashboard:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - show injected badge
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include injection info

              ## Verification

              1. Inject a step manually via API:
                 ```typescript
                 const injector = new ProgressInjector(progressPath);
                 await injector.injectStep({
                   step: { id: 'hotfix-1', prompt: 'Fix critical bug' },
                   position: { type: 'after-current' }
                 });
                 ```

              2. Verify PROGRESS.yaml updated correctly
              3. Verify loop executes injected step
              4. Verify dashboard shows injected badge

              5. Test workflow injection:
                 ```typescript
                 await injector.injectWorkflow({
                   workflow: 'bugfix-workflow',
                   context: { variables: { issue: 'Auth token expiry' } },
                   position: { type: 'end-of-phase', phaseId: 'development' },
                   idPrefix: 'hotfix'
                 });
                 ```


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/step-6-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-6

              ## Step Task
              Implement dynamic step injection into running sprints.

              ## Overview
              Allow adding steps to PROGRESS.yaml at runtime:
              - Add single steps to a specific position
              - Compile a workflow to add multiple steps
              - Choose insertion point (after current, end of phase, specific position)

              This is required for the operator and suggested-steps features.

              ## API Design

              ### Single Step Injection

              ```typescript
              interface StepInjection {
                step: {
                  id: string;
                  prompt: string;
                  model?: string;
                };
                position: InsertPosition;
              }

              type InsertPosition =
                | { type: 'after-current' }                    // After currently executing step
                | { type: 'after-step'; stepId: string }      // After specific step
                | { type: 'end-of-phase'; phaseId: string }   // At end of specific phase
                | { type: 'end-of-workflow' }                 // At very end
                | { type: 'before-step'; stepId: string };    // Before specific step
              ```

              ### Workflow-Based Injection

              ```typescript
              interface WorkflowInjection {
                workflow: string;           // Workflow name to compile
                context?: {                 // Context for the workflow
                  step?: StepDefinition;    // If workflow uses for-each: step
                  variables?: Record<string, any>;
                };
                position: InsertPosition;
                idPrefix: string;           // Prefix for generated phase IDs
              }
              ```

              ## Implementation

              ### 1. Progress File Manipulation

              Create `progress-injector.ts`:

              ```typescript
              export class ProgressInjector {
                constructor(private progressPath: string) {}

                // Inject single step
                async injectStep(injection: StepInjection): Promise<void> {
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);

                  // Create phase entry
                  const phase = {
                    id: injection.step.id,
                    prompt: injection.step.prompt,
                    status: 'pending',
                    model: injection.step.model,
                    injected: true,  // Mark as dynamically injected
                    'injected-at': new Date().toISOString(),
                  };

                  // Insert at position
                  progress.phases.splice(insertIndex, 0, phase);

                  // Recalculate stats
                  this.updateStats(progress);

                  await this.saveProgress(progress);
                }

                // Inject compiled workflow
                async injectWorkflow(injection: WorkflowInjection): Promise<void> {
                  // Load and compile workflow
                  const compiledPhases = await compileWorkflow(
                    injection.workflow,
                    injection.context
                  );

                  // Prefix IDs
                  const prefixedPhases = compiledPhases.map(phase => ({
                    ...phase,
                    id: `${injection.idPrefix}-${phase.id}`,
                    injected: true,
                    'injected-at': new Date().toISOString(),
                  }));

                  // Insert all phases at position
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);
                  progress.phases.splice(insertIndex, 0, ...prefixedPhases);

                  this.updateStats(progress);
                  await this.saveProgress(progress);
                }

                private resolvePosition(progress: Progress, pos: InsertPosition): number {
                  switch (pos.type) {
                    case 'after-current':
                      return this.findCurrentIndex(progress) + 1;
                    case 'after-step':
                      return this.findStepIndex(progress, pos.stepId) + 1;
                    case 'before-step':
                      return this.findStepIndex(progress, pos.stepId);
                    case 'end-of-phase':
                      return this.findPhaseEndIndex(progress, pos.phaseId);
                    case 'end-of-workflow':
                      return progress.phases.length;
                  }
                }
              }
              ```

              ### 2. Integration with Loop

              Modify `loop.ts` to:
              - Detect injected steps (phases with `injected: true`)
              - Handle them like regular phases
              - Log injection events to activity

              ### 3. Dashboard Display

              Show injected steps distinctly:
              - Different icon/badge for injected steps
              - Show injection timestamp
              - Indicate source (operator, suggested-step, manual)

              ### 4. CLI Command (Optional)

              Add command for manual injection:
              ```bash
              m42-sprint inject-step <sprint-path> \
                --prompt "Fix the bug in auth.ts" \
                --position after-current \
                --workflow bugfix-workflow
              ```

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/progress-injector.ts - NEW: injection logic
              - plugins/m42-sprint/runtime/src/loop.ts - integrate injector
              - plugins/m42-sprint/runtime/src/cli.ts - add inject-step command

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - export compile function for runtime use

              **Dashboard:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - show injected badge
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include injection info

              ## Verification

              1. Inject a step manually via API:
                 ```typescript
                 const injector = new ProgressInjector(progressPath);
                 await injector.injectStep({
                   step: { id: 'hotfix-1', prompt: 'Fix critical bug' },
                   position: { type: 'after-current' }
                 });
                 ```

              2. Verify PROGRESS.yaml updated correctly
              3. Verify loop executes injected step
              4. Verify dashboard shows injected badge

              5. Test workflow injection:
                 ```typescript
                 await injector.injectWorkflow({
                   workflow: 'bugfix-workflow',
                   context: { variables: { issue: 'Auth token expiry' } },
                   position: { type: 'end-of-phase', phaseId: 'development' },
                   idPrefix: 'hotfix'
                 });
                 ```


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/step-6-gherkin.md
              git commit -m "test(step-6): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: '2026-01-21T00:12:22.572Z'
            completed-at: '2026-01-21T00:16:17.245Z'
          - id: green-context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Implement dynamic step injection into running sprints.

              ## Overview
              Allow adding steps to PROGRESS.yaml at runtime:
              - Add single steps to a specific position
              - Compile a workflow to add multiple steps
              - Choose insertion point (after current, end of phase, specific position)

              This is required for the operator and suggested-steps features.

              ## API Design

              ### Single Step Injection

              ```typescript
              interface StepInjection {
                step: {
                  id: string;
                  prompt: string;
                  model?: string;
                };
                position: InsertPosition;
              }

              type InsertPosition =
                | { type: 'after-current' }                    // After currently executing step
                | { type: 'after-step'; stepId: string }      // After specific step
                | { type: 'end-of-phase'; phaseId: string }   // At end of specific phase
                | { type: 'end-of-workflow' }                 // At very end
                | { type: 'before-step'; stepId: string };    // Before specific step
              ```

              ### Workflow-Based Injection

              ```typescript
              interface WorkflowInjection {
                workflow: string;           // Workflow name to compile
                context?: {                 // Context for the workflow
                  step?: StepDefinition;    // If workflow uses for-each: step
                  variables?: Record<string, any>;
                };
                position: InsertPosition;
                idPrefix: string;           // Prefix for generated phase IDs
              }
              ```

              ## Implementation

              ### 1. Progress File Manipulation

              Create `progress-injector.ts`:

              ```typescript
              export class ProgressInjector {
                constructor(private progressPath: string) {}

                // Inject single step
                async injectStep(injection: StepInjection): Promise<void> {
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);

                  // Create phase entry
                  const phase = {
                    id: injection.step.id,
                    prompt: injection.step.prompt,
                    status: 'pending',
                    model: injection.step.model,
                    injected: true,  // Mark as dynamically injected
                    'injected-at': new Date().toISOString(),
                  };

                  // Insert at position
                  progress.phases.splice(insertIndex, 0, phase);

                  // Recalculate stats
                  this.updateStats(progress);

                  await this.saveProgress(progress);
                }

                // Inject compiled workflow
                async injectWorkflow(injection: WorkflowInjection): Promise<void> {
                  // Load and compile workflow
                  const compiledPhases = await compileWorkflow(
                    injection.workflow,
                    injection.context
                  );

                  // Prefix IDs
                  const prefixedPhases = compiledPhases.map(phase => ({
                    ...phase,
                    id: `${injection.idPrefix}-${phase.id}`,
                    injected: true,
                    'injected-at': new Date().toISOString(),
                  }));

                  // Insert all phases at position
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);
                  progress.phases.splice(insertIndex, 0, ...prefixedPhases);

                  this.updateStats(progress);
                  await this.saveProgress(progress);
                }

                private resolvePosition(progress: Progress, pos: InsertPosition): number {
                  switch (pos.type) {
                    case 'after-current':
                      return this.findCurrentIndex(progress) + 1;
                    case 'after-step':
                      return this.findStepIndex(progress, pos.stepId) + 1;
                    case 'before-step':
                      return this.findStepIndex(progress, pos.stepId);
                    case 'end-of-phase':
                      return this.findPhaseEndIndex(progress, pos.phaseId);
                    case 'end-of-workflow':
                      return progress.phases.length;
                  }
                }
              }
              ```

              ### 2. Integration with Loop

              Modify `loop.ts` to:
              - Detect injected steps (phases with `injected: true`)
              - Handle them like regular phases
              - Log injection events to activity

              ### 3. Dashboard Display

              Show injected steps distinctly:
              - Different icon/badge for injected steps
              - Show injection timestamp
              - Indicate source (operator, suggested-step, manual)

              ### 4. CLI Command (Optional)

              Add command for manual injection:
              ```bash
              m42-sprint inject-step <sprint-path> \
                --prompt "Fix the bug in auth.ts" \
                --position after-current \
                --workflow bugfix-workflow
              ```

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/progress-injector.ts - NEW: injection logic
              - plugins/m42-sprint/runtime/src/loop.ts - integrate injector
              - plugins/m42-sprint/runtime/src/cli.ts - add inject-step command

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - export compile function for runtime use

              **Dashboard:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - show injected badge
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include injection info

              ## Verification

              1. Inject a step manually via API:
                 ```typescript
                 const injector = new ProgressInjector(progressPath);
                 await injector.injectStep({
                   step: { id: 'hotfix-1', prompt: 'Fix critical bug' },
                   position: { type: 'after-current' }
                 });
                 ```

              2. Verify PROGRESS.yaml updated correctly
              3. Verify loop executes injected step
              4. Verify dashboard shows injected badge

              5. Test workflow injection:
                 ```typescript
                 await injector.injectWorkflow({
                   workflow: 'bugfix-workflow',
                   context: { variables: { issue: 'Auth token expiry' } },
                   position: { type: 'end-of-phase', phaseId: 'development' },
                   idPrefix: 'hotfix'
                 });
                 ```


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/step-6-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/step-6-context.md

              ```markdown
              # Step Context: step-6

              ## Task
              Implement dynamic step injection into running sprints.

              ## Overview
              Allow adding steps to PROGRESS.yaml at runtime:
              - Add single steps to a specific position
              - Compile a workflow to add multiple steps
              - Choose insertion point (after current, end of phase, specific position)

              This is required for the operator and suggested-steps features.

              ## API Design

              ### Single Step Injection

              ```typescript
              interface StepInjection {
                step: {
                  id: string;
                  prompt: string;
                  model?: string;
                };
                position: InsertPosition;
              }

              type InsertPosition =
                | { type: 'after-current' }                    // After currently executing step
                | { type: 'after-step'; stepId: string }      // After specific step
                | { type: 'end-of-phase'; phaseId: string }   // At end of specific phase
                | { type: 'end-of-workflow' }                 // At very end
                | { type: 'before-step'; stepId: string };    // Before specific step
              ```

              ### Workflow-Based Injection

              ```typescript
              interface WorkflowInjection {
                workflow: string;           // Workflow name to compile
                context?: {                 // Context for the workflow
                  step?: StepDefinition;    // If workflow uses for-each: step
                  variables?: Record<string, any>;
                };
                position: InsertPosition;
                idPrefix: string;           // Prefix for generated phase IDs
              }
              ```

              ## Implementation

              ### 1. Progress File Manipulation

              Create `progress-injector.ts`:

              ```typescript
              export class ProgressInjector {
                constructor(private progressPath: string) {}

                // Inject single step
                async injectStep(injection: StepInjection): Promise<void> {
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);

                  // Create phase entry
                  const phase = {
                    id: injection.step.id,
                    prompt: injection.step.prompt,
                    status: 'pending',
                    model: injection.step.model,
                    injected: true,  // Mark as dynamically injected
                    'injected-at': new Date().toISOString(),
                  };

                  // Insert at position
                  progress.phases.splice(insertIndex, 0, phase);

                  // Recalculate stats
                  this.updateStats(progress);

                  await this.saveProgress(progress);
                }

                // Inject compiled workflow
                async injectWorkflow(injection: WorkflowInjection): Promise<void> {
                  // Load and compile workflow
                  const compiledPhases = await compileWorkflow(
                    injection.workflow,
                    injection.context
                  );

                  // Prefix IDs
                  const prefixedPhases = compiledPhases.map(phase => ({
                    ...phase,
                    id: `${injection.idPrefix}-${phase.id}`,
                    injected: true,
                    'injected-at': new Date().toISOString(),
                  }));

                  // Insert all phases at position
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);
                  progress.phases.splice(insertIndex, 0, ...prefixedPhases);

                  this.updateStats(progress);
                  await this.saveProgress(progress);
                }

                private resolvePosition(progress: Progress, pos: InsertPosition): number {
                  switch (pos.type) {
                    case 'after-current':
                      return this.findCurrentIndex(progress) + 1;
                    case 'after-step':
                      return this.findStepIndex(progress, pos.stepId) + 1;
                    case 'before-step':
                      return this.findStepIndex(progress, pos.stepId);
                    case 'end-of-phase':
                      return this.findPhaseEndIndex(progress, pos.phaseId);
                    case 'end-of-workflow':
                      return progress.phases.length;
                  }
                }
              }
              ```

              ### 2. Integration with Loop

              Modify `loop.ts` to:
              - Detect injected steps (phases with `injected: true`)
              - Handle them like regular phases
              - Log injection events to activity

              ### 3. Dashboard Display

              Show injected steps distinctly:
              - Different icon/badge for injected steps
              - Show injection timestamp
              - Indicate source (operator, suggested-step, manual)

              ### 4. CLI Command (Optional)

              Add command for manual injection:
              ```bash
              m42-sprint inject-step <sprint-path> \
                --prompt "Fix the bug in auth.ts" \
                --position after-current \
                --workflow bugfix-workflow
              ```

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/progress-injector.ts - NEW: injection logic
              - plugins/m42-sprint/runtime/src/loop.ts - integrate injector
              - plugins/m42-sprint/runtime/src/cli.ts - add inject-step command

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - export compile function for runtime use

              **Dashboard:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - show injected badge
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include injection info

              ## Verification

              1. Inject a step manually via API:
                 ```typescript
                 const injector = new ProgressInjector(progressPath);
                 await injector.injectStep({
                   step: { id: 'hotfix-1', prompt: 'Fix critical bug' },
                   position: { type: 'after-current' }
                 });
                 ```

              2. Verify PROGRESS.yaml updated correctly
              3. Verify loop executes injected step
              4. Verify dashboard shows injected badge

              5. Test workflow injection:
                 ```typescript
                 await injector.injectWorkflow({
                   workflow: 'bugfix-workflow',
                   context: { variables: { issue: 'Auth token expiry' } },
                   position: { type: 'end-of-phase', phaseId: 'development' },
                   idPrefix: 'hotfix'
                 });
                 ```


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/step-6-context.md
              git commit -m "context(step-6): gather implementation context"
              ```
            started-at: '2026-01-21T00:16:19.328Z'
            completed-at: '2026-01-21T00:19:19.686Z'
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              Implement dynamic step injection into running sprints.

              ## Overview
              Allow adding steps to PROGRESS.yaml at runtime:
              - Add single steps to a specific position
              - Compile a workflow to add multiple steps
              - Choose insertion point (after current, end of phase, specific position)

              This is required for the operator and suggested-steps features.

              ## API Design

              ### Single Step Injection

              ```typescript
              interface StepInjection {
                step: {
                  id: string;
                  prompt: string;
                  model?: string;
                };
                position: InsertPosition;
              }

              type InsertPosition =
                | { type: 'after-current' }                    // After currently executing step
                | { type: 'after-step'; stepId: string }      // After specific step
                | { type: 'end-of-phase'; phaseId: string }   // At end of specific phase
                | { type: 'end-of-workflow' }                 // At very end
                | { type: 'before-step'; stepId: string };    // Before specific step
              ```

              ### Workflow-Based Injection

              ```typescript
              interface WorkflowInjection {
                workflow: string;           // Workflow name to compile
                context?: {                 // Context for the workflow
                  step?: StepDefinition;    // If workflow uses for-each: step
                  variables?: Record<string, any>;
                };
                position: InsertPosition;
                idPrefix: string;           // Prefix for generated phase IDs
              }
              ```

              ## Implementation

              ### 1. Progress File Manipulation

              Create `progress-injector.ts`:

              ```typescript
              export class ProgressInjector {
                constructor(private progressPath: string) {}

                // Inject single step
                async injectStep(injection: StepInjection): Promise<void> {
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);

                  // Create phase entry
                  const phase = {
                    id: injection.step.id,
                    prompt: injection.step.prompt,
                    status: 'pending',
                    model: injection.step.model,
                    injected: true,  // Mark as dynamically injected
                    'injected-at': new Date().toISOString(),
                  };

                  // Insert at position
                  progress.phases.splice(insertIndex, 0, phase);

                  // Recalculate stats
                  this.updateStats(progress);

                  await this.saveProgress(progress);
                }

                // Inject compiled workflow
                async injectWorkflow(injection: WorkflowInjection): Promise<void> {
                  // Load and compile workflow
                  const compiledPhases = await compileWorkflow(
                    injection.workflow,
                    injection.context
                  );

                  // Prefix IDs
                  const prefixedPhases = compiledPhases.map(phase => ({
                    ...phase,
                    id: `${injection.idPrefix}-${phase.id}`,
                    injected: true,
                    'injected-at': new Date().toISOString(),
                  }));

                  // Insert all phases at position
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);
                  progress.phases.splice(insertIndex, 0, ...prefixedPhases);

                  this.updateStats(progress);
                  await this.saveProgress(progress);
                }

                private resolvePosition(progress: Progress, pos: InsertPosition): number {
                  switch (pos.type) {
                    case 'after-current':
                      return this.findCurrentIndex(progress) + 1;
                    case 'after-step':
                      return this.findStepIndex(progress, pos.stepId) + 1;
                    case 'before-step':
                      return this.findStepIndex(progress, pos.stepId);
                    case 'end-of-phase':
                      return this.findPhaseEndIndex(progress, pos.phaseId);
                    case 'end-of-workflow':
                      return progress.phases.length;
                  }
                }
              }
              ```

              ### 2. Integration with Loop

              Modify `loop.ts` to:
              - Detect injected steps (phases with `injected: true`)
              - Handle them like regular phases
              - Log injection events to activity

              ### 3. Dashboard Display

              Show injected steps distinctly:
              - Different icon/badge for injected steps
              - Show injection timestamp
              - Indicate source (operator, suggested-step, manual)

              ### 4. CLI Command (Optional)

              Add command for manual injection:
              ```bash
              m42-sprint inject-step <sprint-path> \
                --prompt "Fix the bug in auth.ts" \
                --position after-current \
                --workflow bugfix-workflow
              ```

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/progress-injector.ts - NEW: injection logic
              - plugins/m42-sprint/runtime/src/loop.ts - integrate injector
              - plugins/m42-sprint/runtime/src/cli.ts - add inject-step command

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - export compile function for runtime use

              **Dashboard:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - show injected badge
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include injection info

              ## Verification

              1. Inject a step manually via API:
                 ```typescript
                 const injector = new ProgressInjector(progressPath);
                 await injector.injectStep({
                   step: { id: 'hotfix-1', prompt: 'Fix critical bug' },
                   position: { type: 'after-current' }
                 });
                 ```

              2. Verify PROGRESS.yaml updated correctly
              3. Verify loop executes injected step
              4. Verify dashboard shows injected badge

              5. Test workflow injection:
                 ```typescript
                 await injector.injectWorkflow({
                   workflow: 'bugfix-workflow',
                   context: { variables: { issue: 'Auth token expiry' } },
                   position: { type: 'end-of-phase', phaseId: 'development' },
                   idPrefix: 'hotfix'
                 });
                 ```


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/step-6-gherkin.md (scenarios to satisfy)
              3. context/step-6-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(step-6): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: '2026-01-21T00:19:21.793Z'
            completed-at: '2026-01-21T00:21:39.062Z'
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              Implement dynamic step injection into running sprints.

              ## Overview
              Allow adding steps to PROGRESS.yaml at runtime:
              - Add single steps to a specific position
              - Compile a workflow to add multiple steps
              - Choose insertion point (after current, end of phase, specific position)

              This is required for the operator and suggested-steps features.

              ## API Design

              ### Single Step Injection

              ```typescript
              interface StepInjection {
                step: {
                  id: string;
                  prompt: string;
                  model?: string;
                };
                position: InsertPosition;
              }

              type InsertPosition =
                | { type: 'after-current' }                    // After currently executing step
                | { type: 'after-step'; stepId: string }      // After specific step
                | { type: 'end-of-phase'; phaseId: string }   // At end of specific phase
                | { type: 'end-of-workflow' }                 // At very end
                | { type: 'before-step'; stepId: string };    // Before specific step
              ```

              ### Workflow-Based Injection

              ```typescript
              interface WorkflowInjection {
                workflow: string;           // Workflow name to compile
                context?: {                 // Context for the workflow
                  step?: StepDefinition;    // If workflow uses for-each: step
                  variables?: Record<string, any>;
                };
                position: InsertPosition;
                idPrefix: string;           // Prefix for generated phase IDs
              }
              ```

              ## Implementation

              ### 1. Progress File Manipulation

              Create `progress-injector.ts`:

              ```typescript
              export class ProgressInjector {
                constructor(private progressPath: string) {}

                // Inject single step
                async injectStep(injection: StepInjection): Promise<void> {
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);

                  // Create phase entry
                  const phase = {
                    id: injection.step.id,
                    prompt: injection.step.prompt,
                    status: 'pending',
                    model: injection.step.model,
                    injected: true,  // Mark as dynamically injected
                    'injected-at': new Date().toISOString(),
                  };

                  // Insert at position
                  progress.phases.splice(insertIndex, 0, phase);

                  // Recalculate stats
                  this.updateStats(progress);

                  await this.saveProgress(progress);
                }

                // Inject compiled workflow
                async injectWorkflow(injection: WorkflowInjection): Promise<void> {
                  // Load and compile workflow
                  const compiledPhases = await compileWorkflow(
                    injection.workflow,
                    injection.context
                  );

                  // Prefix IDs
                  const prefixedPhases = compiledPhases.map(phase => ({
                    ...phase,
                    id: `${injection.idPrefix}-${phase.id}`,
                    injected: true,
                    'injected-at': new Date().toISOString(),
                  }));

                  // Insert all phases at position
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);
                  progress.phases.splice(insertIndex, 0, ...prefixedPhases);

                  this.updateStats(progress);
                  await this.saveProgress(progress);
                }

                private resolvePosition(progress: Progress, pos: InsertPosition): number {
                  switch (pos.type) {
                    case 'after-current':
                      return this.findCurrentIndex(progress) + 1;
                    case 'after-step':
                      return this.findStepIndex(progress, pos.stepId) + 1;
                    case 'before-step':
                      return this.findStepIndex(progress, pos.stepId);
                    case 'end-of-phase':
                      return this.findPhaseEndIndex(progress, pos.phaseId);
                    case 'end-of-workflow':
                      return progress.phases.length;
                  }
                }
              }
              ```

              ### 2. Integration with Loop

              Modify `loop.ts` to:
              - Detect injected steps (phases with `injected: true`)
              - Handle them like regular phases
              - Log injection events to activity

              ### 3. Dashboard Display

              Show injected steps distinctly:
              - Different icon/badge for injected steps
              - Show injection timestamp
              - Indicate source (operator, suggested-step, manual)

              ### 4. CLI Command (Optional)

              Add command for manual injection:
              ```bash
              m42-sprint inject-step <sprint-path> \
                --prompt "Fix the bug in auth.ts" \
                --position after-current \
                --workflow bugfix-workflow
              ```

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/progress-injector.ts - NEW: injection logic
              - plugins/m42-sprint/runtime/src/loop.ts - integrate injector
              - plugins/m42-sprint/runtime/src/cli.ts - add inject-step command

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - export compile function for runtime use

              **Dashboard:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - show injected badge
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include injection info

              ## Verification

              1. Inject a step manually via API:
                 ```typescript
                 const injector = new ProgressInjector(progressPath);
                 await injector.injectStep({
                   step: { id: 'hotfix-1', prompt: 'Fix critical bug' },
                   position: { type: 'after-current' }
                 });
                 ```

              2. Verify PROGRESS.yaml updated correctly
              3. Verify loop executes injected step
              4. Verify dashboard shows injected badge

              5. Test workflow injection:
                 ```typescript
                 await injector.injectWorkflow({
                   workflow: 'bugfix-workflow',
                   context: { variables: { issue: 'Auth token expiry' } },
                   position: { type: 'end-of-phase', phaseId: 'development' },
                   idPrefix: 'hotfix'
                 });
                 ```


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/step-6-context.md (target patterns)
              Read: artifacts/step-6-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(step-6): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: '2026-01-21T00:21:41.119Z'
            completed-at: '2026-01-21T00:24:04.626Z'
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-6-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/step-6-qa-report.md

              ```markdown
              # QA Report: step-6

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/step-6-qa-report.md
              git commit -m "qa(step-6): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for step-6.\n\nRead: artifacts/step-6-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/step-6-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: '2026-01-21T00:24:06.692Z'
            completed-at: '2026-01-21T00:26:04.949Z'
          - id: verify
            status: in-progress
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Implement dynamic step injection into running sprints.

              ## Overview
              Allow adding steps to PROGRESS.yaml at runtime:
              - Add single steps to a specific position
              - Compile a workflow to add multiple steps
              - Choose insertion point (after current, end of phase, specific position)

              This is required for the operator and suggested-steps features.

              ## API Design

              ### Single Step Injection

              ```typescript
              interface StepInjection {
                step: {
                  id: string;
                  prompt: string;
                  model?: string;
                };
                position: InsertPosition;
              }

              type InsertPosition =
                | { type: 'after-current' }                    // After currently executing step
                | { type: 'after-step'; stepId: string }      // After specific step
                | { type: 'end-of-phase'; phaseId: string }   // At end of specific phase
                | { type: 'end-of-workflow' }                 // At very end
                | { type: 'before-step'; stepId: string };    // Before specific step
              ```

              ### Workflow-Based Injection

              ```typescript
              interface WorkflowInjection {
                workflow: string;           // Workflow name to compile
                context?: {                 // Context for the workflow
                  step?: StepDefinition;    // If workflow uses for-each: step
                  variables?: Record<string, any>;
                };
                position: InsertPosition;
                idPrefix: string;           // Prefix for generated phase IDs
              }
              ```

              ## Implementation

              ### 1. Progress File Manipulation

              Create `progress-injector.ts`:

              ```typescript
              export class ProgressInjector {
                constructor(private progressPath: string) {}

                // Inject single step
                async injectStep(injection: StepInjection): Promise<void> {
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);

                  // Create phase entry
                  const phase = {
                    id: injection.step.id,
                    prompt: injection.step.prompt,
                    status: 'pending',
                    model: injection.step.model,
                    injected: true,  // Mark as dynamically injected
                    'injected-at': new Date().toISOString(),
                  };

                  // Insert at position
                  progress.phases.splice(insertIndex, 0, phase);

                  // Recalculate stats
                  this.updateStats(progress);

                  await this.saveProgress(progress);
                }

                // Inject compiled workflow
                async injectWorkflow(injection: WorkflowInjection): Promise<void> {
                  // Load and compile workflow
                  const compiledPhases = await compileWorkflow(
                    injection.workflow,
                    injection.context
                  );

                  // Prefix IDs
                  const prefixedPhases = compiledPhases.map(phase => ({
                    ...phase,
                    id: `${injection.idPrefix}-${phase.id}`,
                    injected: true,
                    'injected-at': new Date().toISOString(),
                  }));

                  // Insert all phases at position
                  const progress = await this.loadProgress();
                  const insertIndex = this.resolvePosition(progress, injection.position);
                  progress.phases.splice(insertIndex, 0, ...prefixedPhases);

                  this.updateStats(progress);
                  await this.saveProgress(progress);
                }

                private resolvePosition(progress: Progress, pos: InsertPosition): number {
                  switch (pos.type) {
                    case 'after-current':
                      return this.findCurrentIndex(progress) + 1;
                    case 'after-step':
                      return this.findStepIndex(progress, pos.stepId) + 1;
                    case 'before-step':
                      return this.findStepIndex(progress, pos.stepId);
                    case 'end-of-phase':
                      return this.findPhaseEndIndex(progress, pos.phaseId);
                    case 'end-of-workflow':
                      return progress.phases.length;
                  }
                }
              }
              ```

              ### 2. Integration with Loop

              Modify `loop.ts` to:
              - Detect injected steps (phases with `injected: true`)
              - Handle them like regular phases
              - Log injection events to activity

              ### 3. Dashboard Display

              Show injected steps distinctly:
              - Different icon/badge for injected steps
              - Show injection timestamp
              - Indicate source (operator, suggested-step, manual)

              ### 4. CLI Command (Optional)

              Add command for manual injection:
              ```bash
              m42-sprint inject-step <sprint-path> \
                --prompt "Fix the bug in auth.ts" \
                --position after-current \
                --workflow bugfix-workflow
              ```

              ## Files to Modify

              **Runtime:**
              - plugins/m42-sprint/runtime/src/progress-injector.ts - NEW: injection logic
              - plugins/m42-sprint/runtime/src/loop.ts - integrate injector
              - plugins/m42-sprint/runtime/src/cli.ts - add inject-step command

              **Compiler:**
              - plugins/m42-sprint/compiler/src/compile.ts - export compile function for runtime use

              **Dashboard:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - show injected badge
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include injection info

              ## Verification

              1. Inject a step manually via API:
                 ```typescript
                 const injector = new ProgressInjector(progressPath);
                 await injector.injectStep({
                   step: { id: 'hotfix-1', prompt: 'Fix critical bug' },
                   position: { type: 'after-current' }
                 });
                 ```

              2. Verify PROGRESS.yaml updated correctly
              3. Verify loop executes injected step
              4. Verify dashboard shows injected badge

              5. Test workflow injection:
                 ```typescript
                 await injector.injectWorkflow({
                   workflow: 'bugfix-workflow',
                   context: { variables: { issue: 'Auth token expiry' } },
                   position: { type: 'end-of-phase', phaseId: 'development' },
                   idPrefix: 'hotfix'
                 });
                 ```


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-6-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(step-6): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: '2026-01-21T00:26:07.011Z'
        started-at: '2026-01-21T00:11:55.461Z'
      - id: step-7
        prompt: |
          Design and implement the Operator Queue View in the dashboard.

          ## IMPORTANT: UX/UI Planning First

          Before implementing, use a subagent (Explore/Plan) to:
          1. Research existing dashboard patterns and components
          2. Design the UX flow for operator interactions
          3. Create wireframes/mockups (can be ASCII or markdown)
          4. Get alignment on the design before coding

          ## Overview

          A dedicated view per sprint showing:
          - **Pending requests**: Waiting for operator decision
          - **Decided requests**: Approved, rejected, or deferred with reasoning

          This is THE central place to see what the operator is doing and why.

          ## UX Requirements

          ### Navigation
          - Accessible from sprint detail page (tab or sidebar link)
          - Badge showing pending count: "Operator (3)"
          - Quick access from notification when new request arrives

          ### Pending Requests Section

          ```
          ┌─────────────────────────────────────────────────────────────────┐
          │ 🔔 Pending Requests (3)                          [Process All] │
          ├─────────────────────────────────────────────────────────────────┤
          │ ┌─────────────────────────────────────────────────────────────┐ │
          │ │ 🔴 CRITICAL  Fix SQL injection in user input               │ │
          │ │ Discovered in: development-step-2 • 2 min ago              │ │
          │ │ Files: src/api/users.ts                                    │ │
          │ │ ┌─────────────────────────────────────────────────────────┐ │ │
          │ │ │ User input is passed directly to query without...       │ │ │
          │ │ └─────────────────────────────────────────────────────────┘ │ │
          │ │ Suggested: bugfix-workflow                                  │ │
          │ │                                    [Approve] [Reject] [Defer]│ │
          │ └─────────────────────────────────────────────────────────────┘ │
          │                                                                 │
          │ ┌─────────────────────────────────────────────────────────────┐ │
          │ │ 🟡 HIGH  Add rate limiting to API endpoints                 │ │
          │ │ Discovered in: development-step-3 • 5 min ago              │ │
          │ │ ...                                                         │ │
          │ └─────────────────────────────────────────────────────────────┘ │
          └─────────────────────────────────────────────────────────────────┘
          ```

          ### Decided Requests Section (History)

          ```
          ┌─────────────────────────────────────────────────────────────────┐
          │ 📋 Decision History                    [Filter: All ▼] [Search]│
          ├─────────────────────────────────────────────────────────────────┤
          │ ┌─────────────────────────────────────────────────────────────┐ │
          │ │ ✅ APPROVED  Fix null pointer in config parser             │ │
          │ │ Decided: 10 min ago • Injected after: development-step-2   │ │
          │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
          │ │ │ This is a blocking bug that will cause test failures.   │ │ │
          │ │ │ Injecting immediately to unblock QA phase. Using        │ │ │
          │ │ │ bugfix-workflow for proper test coverage.               │ │ │
          │ │ └─────────────────────────────────────────────────────────┘ │ │
          │ └─────────────────────────────────────────────────────────────┘ │
          │                                                                 │
          │ ┌─────────────────────────────────────────────────────────────┐ │
          │ │ ❌ REJECTED  Refactor utils to use lodash                  │ │
          │ │ Decided: 15 min ago                                        │ │
          │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
          │ │ │ Invalid request - lodash adds unnecessary dependency.   │ │ │
          │ │ │ Current implementation is sufficient.                   │ │ │
          │ │ └─────────────────────────────────────────────────────────┘ │ │
          │ └─────────────────────────────────────────────────────────────┘ │
          │                                                                 │
          │ ┌─────────────────────────────────────────────────────────────┐ │
          │ │ ⏸️ DEFERRED  Add comprehensive logging                      │ │
          │ │ Decided: 20 min ago • Deferred until: end-of-sprint        │ │
          │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
          │ │ │ Good idea but not urgent. Will revisit after core       │ │ │
          │ │ │ features are complete.                                  │ │ │
          │ │ └─────────────────────────────────────────────────────────┘ │ │
          │ └─────────────────────────────────────────────────────────────┘ │
          └─────────────────────────────────────────────────────────────────┘
          ```

          ### Backlog Section (For Human Review)

          Items sent to backlog are NOT auto-implemented. They're tracked for human review.

          ```
          ┌─────────────────────────────────────────────────────────────────┐
          │ 📝 Backlog (For Human Review)                    [Export CSV]  │
          ├─────────────────────────────────────────────────────────────────┤
          │ Items in backlog will NOT be auto-implemented. Review and      │
          │ convert to GitHub issues or add to future sprints manually.    │
          ├─────────────────────────────────────────────────────────────────┤
          │ ┌─────────────────────────────────────────────────────────────┐ │
          │ │ 📌 BACKLOG  Upgrade to OAuth2 authentication               │ │
          │ │ Category: tech-debt • Suggested Priority: medium           │ │
          │ │ Added: 25 min ago                                          │ │
          │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
          │ │ │ Valid improvement but significant scope. Current basic  │ │ │
          │ │ │ auth works for MVP. Recommend architectural review      │ │ │
          │ │ │ before implementing. Could be a dedicated sprint.       │ │ │
          │ │ └─────────────────────────────────────────────────────────┘ │ │
          │ │ Status: pending-review    [Create Issue] [Acknowledge] [Delete]│
          │ └─────────────────────────────────────────────────────────────┘ │
          │                                                                 │
          │ ┌─────────────────────────────────────────────────────────────┐ │
          │ │ 📌 BACKLOG  Add API versioning                             │ │
          │ │ Category: feature • Suggested Priority: low                │ │
          │ │ Added: 30 min ago                                          │ │
          │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
          │ │ │ Good practice but not needed yet - no external API      │ │ │
          │ │ │ consumers. Track for when we open API publicly.         │ │ │
          │ │ └─────────────────────────────────────────────────────────┘ │ │
          │ │ Status: acknowledged      [Create Issue] [Delete]           │ │
          │ └─────────────────────────────────────────────────────────────┘ │
          └─────────────────────────────────────────────────────────────────┘
          ```

          ### Backlog Actions

          - **Create Issue**: Convert to GitHub issue (uses gh CLI)
          - **Acknowledge**: Mark as reviewed by human
          - **Delete**: Remove from backlog
          - **Export CSV**: Export all backlog items for external tracking

          ### Manual Actions (Human Override)

          Allow human to:
          - Manually approve/reject pending requests (bypassing operator)
          - Re-process a rejected request
          - Change deferred timing
          - Add notes to decisions

          ## Technical Requirements

          ### 1. Data Source

          Read from operator queue in PROGRESS.yaml or dedicated file:
          ```yaml
          operator-queue:
            - id: req_abc123
              status: pending | approved | rejected | deferred
              ...
          ```

          ### 2. Real-time Updates

          - SSE events for queue changes
          - New event types: `operator-request`, `operator-decision`
          - Update UI without page refresh

          ### 3. API Endpoints

          ```
          GET  /api/sprint/:id/operator-queue         # List all requests
          GET  /api/sprint/:id/operator-queue/pending # Pending only
          POST /api/sprint/:id/operator-queue/:reqId/decide  # Manual decision
          POST /api/sprint/:id/operator/process       # Trigger operator run
          ```

          ### 4. Components

          Create modular components:
          - `OperatorRequestCard` - Single request display
          - `OperatorReasoningBlock` - Collapsible reasoning
          - `OperatorQueueList` - List with filtering
          - `OperatorStats` - Summary stats (pending, approved, rejected)

          ## Files to Modify

          **Status Server:**
          - plugins/m42-sprint/compiler/src/status-server/page.ts - Add queue view
          - plugins/m42-sprint/compiler/src/status-server/server.ts - Add API endpoints
          - plugins/m42-sprint/compiler/src/status-server/transforms.ts - Transform queue data

          **New Files:**
          - plugins/m42-sprint/compiler/src/status-server/operator-queue-page.ts - Dedicated page

          ## Implementation Approach

          1. **Phase A: Research & Design** (use Explore subagent)
             - Study existing dashboard code structure
             - Identify reusable components and patterns
             - Create detailed wireframes
             - Document component hierarchy

          2. **Phase B: Backend**
             - Add queue storage to PROGRESS.yaml schema
             - Implement API endpoints
             - Add SSE event types

          3. **Phase C: Frontend**
             - Implement components
             - Add to navigation
             - Wire up real-time updates

          4. **Phase D: Polish**
             - Animations for new requests
             - Empty states
             - Error handling
             - Mobile responsiveness

          ## Verification

          1. Navigate to operator queue view
          2. See pending requests with full details
          3. See decision history with reasoning
          4. Manually approve a request, verify injection
          5. Verify real-time updates when new requests arrive
        status: pending
        phases:
          - id: context
            status: pending
            prompt: |
              Prepare context for TDD development.

              ## Step 0: Ensure Working in Worktree (if applicable)
              ```bash
              # If trees directory exists, switch to worktree
              if [ -d "trees/2026-01-20_dashboard-improvements" ]; then
                cd trees/2026-01-20_dashboard-improvements
              fi
              pwd
              git branch --show-current
              ```

              ## Step 1: Read Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Step 2: Understand the Step
              Design and implement the Operator Queue View in the dashboard.

              ## IMPORTANT: UX/UI Planning First

              Before implementing, use a subagent (Explore/Plan) to:
              1. Research existing dashboard patterns and components
              2. Design the UX flow for operator interactions
              3. Create wireframes/mockups (can be ASCII or markdown)
              4. Get alignment on the design before coding

              ## Overview

              A dedicated view per sprint showing:
              - **Pending requests**: Waiting for operator decision
              - **Decided requests**: Approved, rejected, or deferred with reasoning

              This is THE central place to see what the operator is doing and why.

              ## UX Requirements

              ### Navigation
              - Accessible from sprint detail page (tab or sidebar link)
              - Badge showing pending count: "Operator (3)"
              - Quick access from notification when new request arrives

              ### Pending Requests Section

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 🔔 Pending Requests (3)                          [Process All] │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🔴 CRITICAL  Fix SQL injection in user input               │ │
              │ │ Discovered in: development-step-2 • 2 min ago              │ │
              │ │ Files: src/api/users.ts                                    │ │
              │ │ ┌─────────────────────────────────────────────────────────┐ │ │
              │ │ │ User input is passed directly to query without...       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Suggested: bugfix-workflow                                  │ │
              │ │                                    [Approve] [Reject] [Defer]│ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🟡 HIGH  Add rate limiting to API endpoints                 │ │
              │ │ Discovered in: development-step-3 • 5 min ago              │ │
              │ │ ...                                                         │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Decided Requests Section (History)

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📋 Decision History                    [Filter: All ▼] [Search]│
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ✅ APPROVED  Fix null pointer in config parser             │ │
              │ │ Decided: 10 min ago • Injected after: development-step-2   │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ This is a blocking bug that will cause test failures.   │ │ │
              │ │ │ Injecting immediately to unblock QA phase. Using        │ │ │
              │ │ │ bugfix-workflow for proper test coverage.               │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ❌ REJECTED  Refactor utils to use lodash                  │ │
              │ │ Decided: 15 min ago                                        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Invalid request - lodash adds unnecessary dependency.   │ │ │
              │ │ │ Current implementation is sufficient.                   │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ⏸️ DEFERRED  Add comprehensive logging                      │ │
              │ │ Decided: 20 min ago • Deferred until: end-of-sprint        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Good idea but not urgent. Will revisit after core       │ │ │
              │ │ │ features are complete.                                  │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Section (For Human Review)

              Items sent to backlog are NOT auto-implemented. They're tracked for human review.

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📝 Backlog (For Human Review)                    [Export CSV]  │
              ├─────────────────────────────────────────────────────────────────┤
              │ Items in backlog will NOT be auto-implemented. Review and      │
              │ convert to GitHub issues or add to future sprints manually.    │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Upgrade to OAuth2 authentication               │ │
              │ │ Category: tech-debt • Suggested Priority: medium           │ │
              │ │ Added: 25 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Valid improvement but significant scope. Current basic  │ │ │
              │ │ │ auth works for MVP. Recommend architectural review      │ │ │
              │ │ │ before implementing. Could be a dedicated sprint.       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: pending-review    [Create Issue] [Acknowledge] [Delete]│
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Add API versioning                             │ │
              │ │ Category: feature • Suggested Priority: low                │ │
              │ │ Added: 30 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Good practice but not needed yet - no external API      │ │ │
              │ │ │ consumers. Track for when we open API publicly.         │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: acknowledged      [Create Issue] [Delete]           │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Actions

              - **Create Issue**: Convert to GitHub issue (uses gh CLI)
              - **Acknowledge**: Mark as reviewed by human
              - **Delete**: Remove from backlog
              - **Export CSV**: Export all backlog items for external tracking

              ### Manual Actions (Human Override)

              Allow human to:
              - Manually approve/reject pending requests (bypassing operator)
              - Re-process a rejected request
              - Change deferred timing
              - Add notes to decisions

              ## Technical Requirements

              ### 1. Data Source

              Read from operator queue in PROGRESS.yaml or dedicated file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  status: pending | approved | rejected | deferred
                  ...
              ```

              ### 2. Real-time Updates

              - SSE events for queue changes
              - New event types: `operator-request`, `operator-decision`
              - Update UI without page refresh

              ### 3. API Endpoints

              ```
              GET  /api/sprint/:id/operator-queue         # List all requests
              GET  /api/sprint/:id/operator-queue/pending # Pending only
              POST /api/sprint/:id/operator-queue/:reqId/decide  # Manual decision
              POST /api/sprint/:id/operator/process       # Trigger operator run
              ```

              ### 4. Components

              Create modular components:
              - `OperatorRequestCard` - Single request display
              - `OperatorReasoningBlock` - Collapsible reasoning
              - `OperatorQueueList` - List with filtering
              - `OperatorStats` - Summary stats (pending, approved, rejected)

              ## Files to Modify

              **Status Server:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - Add queue view
              - plugins/m42-sprint/compiler/src/status-server/server.ts - Add API endpoints
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - Transform queue data

              **New Files:**
              - plugins/m42-sprint/compiler/src/status-server/operator-queue-page.ts - Dedicated page

              ## Implementation Approach

              1. **Phase A: Research & Design** (use Explore subagent)
                 - Study existing dashboard code structure
                 - Identify reusable components and patterns
                 - Create detailed wireframes
                 - Document component hierarchy

              2. **Phase B: Backend**
                 - Add queue storage to PROGRESS.yaml schema
                 - Implement API endpoints
                 - Add SSE event types

              3. **Phase C: Frontend**
                 - Implement components
                 - Add to navigation
                 - Wire up real-time updates

              4. **Phase D: Polish**
                 - Animations for new requests
                 - Empty states
                 - Error handling
                 - Mobile responsiveness

              ## Verification

              1. Navigate to operator queue view
              2. See pending requests with full details
              3. See decision history with reasoning
              4. Manually approve a request, verify injection
              5. Verify real-time updates when new requests arrive


              ## Output
              Confirm understanding of:
              - Test patterns and locations
              - Build/test commands
              - The step requirements
          - id: red
            status: pending
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              Design and implement the Operator Queue View in the dashboard.

              ## IMPORTANT: UX/UI Planning First

              Before implementing, use a subagent (Explore/Plan) to:
              1. Research existing dashboard patterns and components
              2. Design the UX flow for operator interactions
              3. Create wireframes/mockups (can be ASCII or markdown)
              4. Get alignment on the design before coding

              ## Overview

              A dedicated view per sprint showing:
              - **Pending requests**: Waiting for operator decision
              - **Decided requests**: Approved, rejected, or deferred with reasoning

              This is THE central place to see what the operator is doing and why.

              ## UX Requirements

              ### Navigation
              - Accessible from sprint detail page (tab or sidebar link)
              - Badge showing pending count: "Operator (3)"
              - Quick access from notification when new request arrives

              ### Pending Requests Section

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 🔔 Pending Requests (3)                          [Process All] │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🔴 CRITICAL  Fix SQL injection in user input               │ │
              │ │ Discovered in: development-step-2 • 2 min ago              │ │
              │ │ Files: src/api/users.ts                                    │ │
              │ │ ┌─────────────────────────────────────────────────────────┐ │ │
              │ │ │ User input is passed directly to query without...       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Suggested: bugfix-workflow                                  │ │
              │ │                                    [Approve] [Reject] [Defer]│ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🟡 HIGH  Add rate limiting to API endpoints                 │ │
              │ │ Discovered in: development-step-3 • 5 min ago              │ │
              │ │ ...                                                         │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Decided Requests Section (History)

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📋 Decision History                    [Filter: All ▼] [Search]│
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ✅ APPROVED  Fix null pointer in config parser             │ │
              │ │ Decided: 10 min ago • Injected after: development-step-2   │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ This is a blocking bug that will cause test failures.   │ │ │
              │ │ │ Injecting immediately to unblock QA phase. Using        │ │ │
              │ │ │ bugfix-workflow for proper test coverage.               │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ❌ REJECTED  Refactor utils to use lodash                  │ │
              │ │ Decided: 15 min ago                                        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Invalid request - lodash adds unnecessary dependency.   │ │ │
              │ │ │ Current implementation is sufficient.                   │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ⏸️ DEFERRED  Add comprehensive logging                      │ │
              │ │ Decided: 20 min ago • Deferred until: end-of-sprint        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Good idea but not urgent. Will revisit after core       │ │ │
              │ │ │ features are complete.                                  │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Section (For Human Review)

              Items sent to backlog are NOT auto-implemented. They're tracked for human review.

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📝 Backlog (For Human Review)                    [Export CSV]  │
              ├─────────────────────────────────────────────────────────────────┤
              │ Items in backlog will NOT be auto-implemented. Review and      │
              │ convert to GitHub issues or add to future sprints manually.    │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Upgrade to OAuth2 authentication               │ │
              │ │ Category: tech-debt • Suggested Priority: medium           │ │
              │ │ Added: 25 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Valid improvement but significant scope. Current basic  │ │ │
              │ │ │ auth works for MVP. Recommend architectural review      │ │ │
              │ │ │ before implementing. Could be a dedicated sprint.       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: pending-review    [Create Issue] [Acknowledge] [Delete]│
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Add API versioning                             │ │
              │ │ Category: feature • Suggested Priority: low                │ │
              │ │ Added: 30 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Good practice but not needed yet - no external API      │ │ │
              │ │ │ consumers. Track for when we open API publicly.         │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: acknowledged      [Create Issue] [Delete]           │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Actions

              - **Create Issue**: Convert to GitHub issue (uses gh CLI)
              - **Acknowledge**: Mark as reviewed by human
              - **Delete**: Remove from backlog
              - **Export CSV**: Export all backlog items for external tracking

              ### Manual Actions (Human Override)

              Allow human to:
              - Manually approve/reject pending requests (bypassing operator)
              - Re-process a rejected request
              - Change deferred timing
              - Add notes to decisions

              ## Technical Requirements

              ### 1. Data Source

              Read from operator queue in PROGRESS.yaml or dedicated file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  status: pending | approved | rejected | deferred
                  ...
              ```

              ### 2. Real-time Updates

              - SSE events for queue changes
              - New event types: `operator-request`, `operator-decision`
              - Update UI without page refresh

              ### 3. API Endpoints

              ```
              GET  /api/sprint/:id/operator-queue         # List all requests
              GET  /api/sprint/:id/operator-queue/pending # Pending only
              POST /api/sprint/:id/operator-queue/:reqId/decide  # Manual decision
              POST /api/sprint/:id/operator/process       # Trigger operator run
              ```

              ### 4. Components

              Create modular components:
              - `OperatorRequestCard` - Single request display
              - `OperatorReasoningBlock` - Collapsible reasoning
              - `OperatorQueueList` - List with filtering
              - `OperatorStats` - Summary stats (pending, approved, rejected)

              ## Files to Modify

              **Status Server:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - Add queue view
              - plugins/m42-sprint/compiler/src/status-server/server.ts - Add API endpoints
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - Transform queue data

              **New Files:**
              - plugins/m42-sprint/compiler/src/status-server/operator-queue-page.ts - Dedicated page

              ## Implementation Approach

              1. **Phase A: Research & Design** (use Explore subagent)
                 - Study existing dashboard code structure
                 - Identify reusable components and patterns
                 - Create detailed wireframes
                 - Document component hierarchy

              2. **Phase B: Backend**
                 - Add queue storage to PROGRESS.yaml schema
                 - Implement API endpoints
                 - Add SSE event types

              3. **Phase C: Frontend**
                 - Implement components
                 - Add to navigation
                 - Wire up real-time updates

              4. **Phase D: Polish**
                 - Animations for new requests
                 - Empty states
                 - Error handling
                 - Mobile responsiveness

              ## Verification

              1. Navigate to operator queue view
              2. See pending requests with full details
              3. See decision history with reasoning
              4. Manually approve a request, verify injection
              5. Verify real-time updates when new requests arrive


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/step-7-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-7

              ## Step Task
              Design and implement the Operator Queue View in the dashboard.

              ## IMPORTANT: UX/UI Planning First

              Before implementing, use a subagent (Explore/Plan) to:
              1. Research existing dashboard patterns and components
              2. Design the UX flow for operator interactions
              3. Create wireframes/mockups (can be ASCII or markdown)
              4. Get alignment on the design before coding

              ## Overview

              A dedicated view per sprint showing:
              - **Pending requests**: Waiting for operator decision
              - **Decided requests**: Approved, rejected, or deferred with reasoning

              This is THE central place to see what the operator is doing and why.

              ## UX Requirements

              ### Navigation
              - Accessible from sprint detail page (tab or sidebar link)
              - Badge showing pending count: "Operator (3)"
              - Quick access from notification when new request arrives

              ### Pending Requests Section

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 🔔 Pending Requests (3)                          [Process All] │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🔴 CRITICAL  Fix SQL injection in user input               │ │
              │ │ Discovered in: development-step-2 • 2 min ago              │ │
              │ │ Files: src/api/users.ts                                    │ │
              │ │ ┌─────────────────────────────────────────────────────────┐ │ │
              │ │ │ User input is passed directly to query without...       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Suggested: bugfix-workflow                                  │ │
              │ │                                    [Approve] [Reject] [Defer]│ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🟡 HIGH  Add rate limiting to API endpoints                 │ │
              │ │ Discovered in: development-step-3 • 5 min ago              │ │
              │ │ ...                                                         │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Decided Requests Section (History)

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📋 Decision History                    [Filter: All ▼] [Search]│
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ✅ APPROVED  Fix null pointer in config parser             │ │
              │ │ Decided: 10 min ago • Injected after: development-step-2   │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ This is a blocking bug that will cause test failures.   │ │ │
              │ │ │ Injecting immediately to unblock QA phase. Using        │ │ │
              │ │ │ bugfix-workflow for proper test coverage.               │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ❌ REJECTED  Refactor utils to use lodash                  │ │
              │ │ Decided: 15 min ago                                        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Invalid request - lodash adds unnecessary dependency.   │ │ │
              │ │ │ Current implementation is sufficient.                   │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ⏸️ DEFERRED  Add comprehensive logging                      │ │
              │ │ Decided: 20 min ago • Deferred until: end-of-sprint        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Good idea but not urgent. Will revisit after core       │ │ │
              │ │ │ features are complete.                                  │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Section (For Human Review)

              Items sent to backlog are NOT auto-implemented. They're tracked for human review.

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📝 Backlog (For Human Review)                    [Export CSV]  │
              ├─────────────────────────────────────────────────────────────────┤
              │ Items in backlog will NOT be auto-implemented. Review and      │
              │ convert to GitHub issues or add to future sprints manually.    │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Upgrade to OAuth2 authentication               │ │
              │ │ Category: tech-debt • Suggested Priority: medium           │ │
              │ │ Added: 25 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Valid improvement but significant scope. Current basic  │ │ │
              │ │ │ auth works for MVP. Recommend architectural review      │ │ │
              │ │ │ before implementing. Could be a dedicated sprint.       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: pending-review    [Create Issue] [Acknowledge] [Delete]│
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Add API versioning                             │ │
              │ │ Category: feature • Suggested Priority: low                │ │
              │ │ Added: 30 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Good practice but not needed yet - no external API      │ │ │
              │ │ │ consumers. Track for when we open API publicly.         │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: acknowledged      [Create Issue] [Delete]           │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Actions

              - **Create Issue**: Convert to GitHub issue (uses gh CLI)
              - **Acknowledge**: Mark as reviewed by human
              - **Delete**: Remove from backlog
              - **Export CSV**: Export all backlog items for external tracking

              ### Manual Actions (Human Override)

              Allow human to:
              - Manually approve/reject pending requests (bypassing operator)
              - Re-process a rejected request
              - Change deferred timing
              - Add notes to decisions

              ## Technical Requirements

              ### 1. Data Source

              Read from operator queue in PROGRESS.yaml or dedicated file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  status: pending | approved | rejected | deferred
                  ...
              ```

              ### 2. Real-time Updates

              - SSE events for queue changes
              - New event types: `operator-request`, `operator-decision`
              - Update UI without page refresh

              ### 3. API Endpoints

              ```
              GET  /api/sprint/:id/operator-queue         # List all requests
              GET  /api/sprint/:id/operator-queue/pending # Pending only
              POST /api/sprint/:id/operator-queue/:reqId/decide  # Manual decision
              POST /api/sprint/:id/operator/process       # Trigger operator run
              ```

              ### 4. Components

              Create modular components:
              - `OperatorRequestCard` - Single request display
              - `OperatorReasoningBlock` - Collapsible reasoning
              - `OperatorQueueList` - List with filtering
              - `OperatorStats` - Summary stats (pending, approved, rejected)

              ## Files to Modify

              **Status Server:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - Add queue view
              - plugins/m42-sprint/compiler/src/status-server/server.ts - Add API endpoints
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - Transform queue data

              **New Files:**
              - plugins/m42-sprint/compiler/src/status-server/operator-queue-page.ts - Dedicated page

              ## Implementation Approach

              1. **Phase A: Research & Design** (use Explore subagent)
                 - Study existing dashboard code structure
                 - Identify reusable components and patterns
                 - Create detailed wireframes
                 - Document component hierarchy

              2. **Phase B: Backend**
                 - Add queue storage to PROGRESS.yaml schema
                 - Implement API endpoints
                 - Add SSE event types

              3. **Phase C: Frontend**
                 - Implement components
                 - Add to navigation
                 - Wire up real-time updates

              4. **Phase D: Polish**
                 - Animations for new requests
                 - Empty states
                 - Error handling
                 - Mobile responsiveness

              ## Verification

              1. Navigate to operator queue view
              2. See pending requests with full details
              3. See decision history with reasoning
              4. Manually approve a request, verify injection
              5. Verify real-time updates when new requests arrive


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/step-7-gherkin.md
              git commit -m "test(step-7): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
          - id: green-context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Design and implement the Operator Queue View in the dashboard.

              ## IMPORTANT: UX/UI Planning First

              Before implementing, use a subagent (Explore/Plan) to:
              1. Research existing dashboard patterns and components
              2. Design the UX flow for operator interactions
              3. Create wireframes/mockups (can be ASCII or markdown)
              4. Get alignment on the design before coding

              ## Overview

              A dedicated view per sprint showing:
              - **Pending requests**: Waiting for operator decision
              - **Decided requests**: Approved, rejected, or deferred with reasoning

              This is THE central place to see what the operator is doing and why.

              ## UX Requirements

              ### Navigation
              - Accessible from sprint detail page (tab or sidebar link)
              - Badge showing pending count: "Operator (3)"
              - Quick access from notification when new request arrives

              ### Pending Requests Section

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 🔔 Pending Requests (3)                          [Process All] │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🔴 CRITICAL  Fix SQL injection in user input               │ │
              │ │ Discovered in: development-step-2 • 2 min ago              │ │
              │ │ Files: src/api/users.ts                                    │ │
              │ │ ┌─────────────────────────────────────────────────────────┐ │ │
              │ │ │ User input is passed directly to query without...       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Suggested: bugfix-workflow                                  │ │
              │ │                                    [Approve] [Reject] [Defer]│ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🟡 HIGH  Add rate limiting to API endpoints                 │ │
              │ │ Discovered in: development-step-3 • 5 min ago              │ │
              │ │ ...                                                         │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Decided Requests Section (History)

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📋 Decision History                    [Filter: All ▼] [Search]│
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ✅ APPROVED  Fix null pointer in config parser             │ │
              │ │ Decided: 10 min ago • Injected after: development-step-2   │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ This is a blocking bug that will cause test failures.   │ │ │
              │ │ │ Injecting immediately to unblock QA phase. Using        │ │ │
              │ │ │ bugfix-workflow for proper test coverage.               │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ❌ REJECTED  Refactor utils to use lodash                  │ │
              │ │ Decided: 15 min ago                                        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Invalid request - lodash adds unnecessary dependency.   │ │ │
              │ │ │ Current implementation is sufficient.                   │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ⏸️ DEFERRED  Add comprehensive logging                      │ │
              │ │ Decided: 20 min ago • Deferred until: end-of-sprint        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Good idea but not urgent. Will revisit after core       │ │ │
              │ │ │ features are complete.                                  │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Section (For Human Review)

              Items sent to backlog are NOT auto-implemented. They're tracked for human review.

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📝 Backlog (For Human Review)                    [Export CSV]  │
              ├─────────────────────────────────────────────────────────────────┤
              │ Items in backlog will NOT be auto-implemented. Review and      │
              │ convert to GitHub issues or add to future sprints manually.    │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Upgrade to OAuth2 authentication               │ │
              │ │ Category: tech-debt • Suggested Priority: medium           │ │
              │ │ Added: 25 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Valid improvement but significant scope. Current basic  │ │ │
              │ │ │ auth works for MVP. Recommend architectural review      │ │ │
              │ │ │ before implementing. Could be a dedicated sprint.       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: pending-review    [Create Issue] [Acknowledge] [Delete]│
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Add API versioning                             │ │
              │ │ Category: feature • Suggested Priority: low                │ │
              │ │ Added: 30 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Good practice but not needed yet - no external API      │ │ │
              │ │ │ consumers. Track for when we open API publicly.         │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: acknowledged      [Create Issue] [Delete]           │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Actions

              - **Create Issue**: Convert to GitHub issue (uses gh CLI)
              - **Acknowledge**: Mark as reviewed by human
              - **Delete**: Remove from backlog
              - **Export CSV**: Export all backlog items for external tracking

              ### Manual Actions (Human Override)

              Allow human to:
              - Manually approve/reject pending requests (bypassing operator)
              - Re-process a rejected request
              - Change deferred timing
              - Add notes to decisions

              ## Technical Requirements

              ### 1. Data Source

              Read from operator queue in PROGRESS.yaml or dedicated file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  status: pending | approved | rejected | deferred
                  ...
              ```

              ### 2. Real-time Updates

              - SSE events for queue changes
              - New event types: `operator-request`, `operator-decision`
              - Update UI without page refresh

              ### 3. API Endpoints

              ```
              GET  /api/sprint/:id/operator-queue         # List all requests
              GET  /api/sprint/:id/operator-queue/pending # Pending only
              POST /api/sprint/:id/operator-queue/:reqId/decide  # Manual decision
              POST /api/sprint/:id/operator/process       # Trigger operator run
              ```

              ### 4. Components

              Create modular components:
              - `OperatorRequestCard` - Single request display
              - `OperatorReasoningBlock` - Collapsible reasoning
              - `OperatorQueueList` - List with filtering
              - `OperatorStats` - Summary stats (pending, approved, rejected)

              ## Files to Modify

              **Status Server:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - Add queue view
              - plugins/m42-sprint/compiler/src/status-server/server.ts - Add API endpoints
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - Transform queue data

              **New Files:**
              - plugins/m42-sprint/compiler/src/status-server/operator-queue-page.ts - Dedicated page

              ## Implementation Approach

              1. **Phase A: Research & Design** (use Explore subagent)
                 - Study existing dashboard code structure
                 - Identify reusable components and patterns
                 - Create detailed wireframes
                 - Document component hierarchy

              2. **Phase B: Backend**
                 - Add queue storage to PROGRESS.yaml schema
                 - Implement API endpoints
                 - Add SSE event types

              3. **Phase C: Frontend**
                 - Implement components
                 - Add to navigation
                 - Wire up real-time updates

              4. **Phase D: Polish**
                 - Animations for new requests
                 - Empty states
                 - Error handling
                 - Mobile responsiveness

              ## Verification

              1. Navigate to operator queue view
              2. See pending requests with full details
              3. See decision history with reasoning
              4. Manually approve a request, verify injection
              5. Verify real-time updates when new requests arrive


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/step-7-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/step-7-context.md

              ```markdown
              # Step Context: step-7

              ## Task
              Design and implement the Operator Queue View in the dashboard.

              ## IMPORTANT: UX/UI Planning First

              Before implementing, use a subagent (Explore/Plan) to:
              1. Research existing dashboard patterns and components
              2. Design the UX flow for operator interactions
              3. Create wireframes/mockups (can be ASCII or markdown)
              4. Get alignment on the design before coding

              ## Overview

              A dedicated view per sprint showing:
              - **Pending requests**: Waiting for operator decision
              - **Decided requests**: Approved, rejected, or deferred with reasoning

              This is THE central place to see what the operator is doing and why.

              ## UX Requirements

              ### Navigation
              - Accessible from sprint detail page (tab or sidebar link)
              - Badge showing pending count: "Operator (3)"
              - Quick access from notification when new request arrives

              ### Pending Requests Section

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 🔔 Pending Requests (3)                          [Process All] │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🔴 CRITICAL  Fix SQL injection in user input               │ │
              │ │ Discovered in: development-step-2 • 2 min ago              │ │
              │ │ Files: src/api/users.ts                                    │ │
              │ │ ┌─────────────────────────────────────────────────────────┐ │ │
              │ │ │ User input is passed directly to query without...       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Suggested: bugfix-workflow                                  │ │
              │ │                                    [Approve] [Reject] [Defer]│ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🟡 HIGH  Add rate limiting to API endpoints                 │ │
              │ │ Discovered in: development-step-3 • 5 min ago              │ │
              │ │ ...                                                         │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Decided Requests Section (History)

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📋 Decision History                    [Filter: All ▼] [Search]│
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ✅ APPROVED  Fix null pointer in config parser             │ │
              │ │ Decided: 10 min ago • Injected after: development-step-2   │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ This is a blocking bug that will cause test failures.   │ │ │
              │ │ │ Injecting immediately to unblock QA phase. Using        │ │ │
              │ │ │ bugfix-workflow for proper test coverage.               │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ❌ REJECTED  Refactor utils to use lodash                  │ │
              │ │ Decided: 15 min ago                                        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Invalid request - lodash adds unnecessary dependency.   │ │ │
              │ │ │ Current implementation is sufficient.                   │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ⏸️ DEFERRED  Add comprehensive logging                      │ │
              │ │ Decided: 20 min ago • Deferred until: end-of-sprint        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Good idea but not urgent. Will revisit after core       │ │ │
              │ │ │ features are complete.                                  │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Section (For Human Review)

              Items sent to backlog are NOT auto-implemented. They're tracked for human review.

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📝 Backlog (For Human Review)                    [Export CSV]  │
              ├─────────────────────────────────────────────────────────────────┤
              │ Items in backlog will NOT be auto-implemented. Review and      │
              │ convert to GitHub issues or add to future sprints manually.    │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Upgrade to OAuth2 authentication               │ │
              │ │ Category: tech-debt • Suggested Priority: medium           │ │
              │ │ Added: 25 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Valid improvement but significant scope. Current basic  │ │ │
              │ │ │ auth works for MVP. Recommend architectural review      │ │ │
              │ │ │ before implementing. Could be a dedicated sprint.       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: pending-review    [Create Issue] [Acknowledge] [Delete]│
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Add API versioning                             │ │
              │ │ Category: feature • Suggested Priority: low                │ │
              │ │ Added: 30 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Good practice but not needed yet - no external API      │ │ │
              │ │ │ consumers. Track for when we open API publicly.         │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: acknowledged      [Create Issue] [Delete]           │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Actions

              - **Create Issue**: Convert to GitHub issue (uses gh CLI)
              - **Acknowledge**: Mark as reviewed by human
              - **Delete**: Remove from backlog
              - **Export CSV**: Export all backlog items for external tracking

              ### Manual Actions (Human Override)

              Allow human to:
              - Manually approve/reject pending requests (bypassing operator)
              - Re-process a rejected request
              - Change deferred timing
              - Add notes to decisions

              ## Technical Requirements

              ### 1. Data Source

              Read from operator queue in PROGRESS.yaml or dedicated file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  status: pending | approved | rejected | deferred
                  ...
              ```

              ### 2. Real-time Updates

              - SSE events for queue changes
              - New event types: `operator-request`, `operator-decision`
              - Update UI without page refresh

              ### 3. API Endpoints

              ```
              GET  /api/sprint/:id/operator-queue         # List all requests
              GET  /api/sprint/:id/operator-queue/pending # Pending only
              POST /api/sprint/:id/operator-queue/:reqId/decide  # Manual decision
              POST /api/sprint/:id/operator/process       # Trigger operator run
              ```

              ### 4. Components

              Create modular components:
              - `OperatorRequestCard` - Single request display
              - `OperatorReasoningBlock` - Collapsible reasoning
              - `OperatorQueueList` - List with filtering
              - `OperatorStats` - Summary stats (pending, approved, rejected)

              ## Files to Modify

              **Status Server:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - Add queue view
              - plugins/m42-sprint/compiler/src/status-server/server.ts - Add API endpoints
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - Transform queue data

              **New Files:**
              - plugins/m42-sprint/compiler/src/status-server/operator-queue-page.ts - Dedicated page

              ## Implementation Approach

              1. **Phase A: Research & Design** (use Explore subagent)
                 - Study existing dashboard code structure
                 - Identify reusable components and patterns
                 - Create detailed wireframes
                 - Document component hierarchy

              2. **Phase B: Backend**
                 - Add queue storage to PROGRESS.yaml schema
                 - Implement API endpoints
                 - Add SSE event types

              3. **Phase C: Frontend**
                 - Implement components
                 - Add to navigation
                 - Wire up real-time updates

              4. **Phase D: Polish**
                 - Animations for new requests
                 - Empty states
                 - Error handling
                 - Mobile responsiveness

              ## Verification

              1. Navigate to operator queue view
              2. See pending requests with full details
              3. See decision history with reasoning
              4. Manually approve a request, verify injection
              5. Verify real-time updates when new requests arrive


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/step-7-context.md
              git commit -m "context(step-7): gather implementation context"
              ```
          - id: green
            status: pending
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              Design and implement the Operator Queue View in the dashboard.

              ## IMPORTANT: UX/UI Planning First

              Before implementing, use a subagent (Explore/Plan) to:
              1. Research existing dashboard patterns and components
              2. Design the UX flow for operator interactions
              3. Create wireframes/mockups (can be ASCII or markdown)
              4. Get alignment on the design before coding

              ## Overview

              A dedicated view per sprint showing:
              - **Pending requests**: Waiting for operator decision
              - **Decided requests**: Approved, rejected, or deferred with reasoning

              This is THE central place to see what the operator is doing and why.

              ## UX Requirements

              ### Navigation
              - Accessible from sprint detail page (tab or sidebar link)
              - Badge showing pending count: "Operator (3)"
              - Quick access from notification when new request arrives

              ### Pending Requests Section

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 🔔 Pending Requests (3)                          [Process All] │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🔴 CRITICAL  Fix SQL injection in user input               │ │
              │ │ Discovered in: development-step-2 • 2 min ago              │ │
              │ │ Files: src/api/users.ts                                    │ │
              │ │ ┌─────────────────────────────────────────────────────────┐ │ │
              │ │ │ User input is passed directly to query without...       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Suggested: bugfix-workflow                                  │ │
              │ │                                    [Approve] [Reject] [Defer]│ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🟡 HIGH  Add rate limiting to API endpoints                 │ │
              │ │ Discovered in: development-step-3 • 5 min ago              │ │
              │ │ ...                                                         │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Decided Requests Section (History)

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📋 Decision History                    [Filter: All ▼] [Search]│
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ✅ APPROVED  Fix null pointer in config parser             │ │
              │ │ Decided: 10 min ago • Injected after: development-step-2   │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ This is a blocking bug that will cause test failures.   │ │ │
              │ │ │ Injecting immediately to unblock QA phase. Using        │ │ │
              │ │ │ bugfix-workflow for proper test coverage.               │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ❌ REJECTED  Refactor utils to use lodash                  │ │
              │ │ Decided: 15 min ago                                        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Invalid request - lodash adds unnecessary dependency.   │ │ │
              │ │ │ Current implementation is sufficient.                   │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ⏸️ DEFERRED  Add comprehensive logging                      │ │
              │ │ Decided: 20 min ago • Deferred until: end-of-sprint        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Good idea but not urgent. Will revisit after core       │ │ │
              │ │ │ features are complete.                                  │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Section (For Human Review)

              Items sent to backlog are NOT auto-implemented. They're tracked for human review.

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📝 Backlog (For Human Review)                    [Export CSV]  │
              ├─────────────────────────────────────────────────────────────────┤
              │ Items in backlog will NOT be auto-implemented. Review and      │
              │ convert to GitHub issues or add to future sprints manually.    │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Upgrade to OAuth2 authentication               │ │
              │ │ Category: tech-debt • Suggested Priority: medium           │ │
              │ │ Added: 25 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Valid improvement but significant scope. Current basic  │ │ │
              │ │ │ auth works for MVP. Recommend architectural review      │ │ │
              │ │ │ before implementing. Could be a dedicated sprint.       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: pending-review    [Create Issue] [Acknowledge] [Delete]│
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Add API versioning                             │ │
              │ │ Category: feature • Suggested Priority: low                │ │
              │ │ Added: 30 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Good practice but not needed yet - no external API      │ │ │
              │ │ │ consumers. Track for when we open API publicly.         │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: acknowledged      [Create Issue] [Delete]           │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Actions

              - **Create Issue**: Convert to GitHub issue (uses gh CLI)
              - **Acknowledge**: Mark as reviewed by human
              - **Delete**: Remove from backlog
              - **Export CSV**: Export all backlog items for external tracking

              ### Manual Actions (Human Override)

              Allow human to:
              - Manually approve/reject pending requests (bypassing operator)
              - Re-process a rejected request
              - Change deferred timing
              - Add notes to decisions

              ## Technical Requirements

              ### 1. Data Source

              Read from operator queue in PROGRESS.yaml or dedicated file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  status: pending | approved | rejected | deferred
                  ...
              ```

              ### 2. Real-time Updates

              - SSE events for queue changes
              - New event types: `operator-request`, `operator-decision`
              - Update UI without page refresh

              ### 3. API Endpoints

              ```
              GET  /api/sprint/:id/operator-queue         # List all requests
              GET  /api/sprint/:id/operator-queue/pending # Pending only
              POST /api/sprint/:id/operator-queue/:reqId/decide  # Manual decision
              POST /api/sprint/:id/operator/process       # Trigger operator run
              ```

              ### 4. Components

              Create modular components:
              - `OperatorRequestCard` - Single request display
              - `OperatorReasoningBlock` - Collapsible reasoning
              - `OperatorQueueList` - List with filtering
              - `OperatorStats` - Summary stats (pending, approved, rejected)

              ## Files to Modify

              **Status Server:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - Add queue view
              - plugins/m42-sprint/compiler/src/status-server/server.ts - Add API endpoints
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - Transform queue data

              **New Files:**
              - plugins/m42-sprint/compiler/src/status-server/operator-queue-page.ts - Dedicated page

              ## Implementation Approach

              1. **Phase A: Research & Design** (use Explore subagent)
                 - Study existing dashboard code structure
                 - Identify reusable components and patterns
                 - Create detailed wireframes
                 - Document component hierarchy

              2. **Phase B: Backend**
                 - Add queue storage to PROGRESS.yaml schema
                 - Implement API endpoints
                 - Add SSE event types

              3. **Phase C: Frontend**
                 - Implement components
                 - Add to navigation
                 - Wire up real-time updates

              4. **Phase D: Polish**
                 - Animations for new requests
                 - Empty states
                 - Error handling
                 - Mobile responsiveness

              ## Verification

              1. Navigate to operator queue view
              2. See pending requests with full details
              3. See decision history with reasoning
              4. Manually approve a request, verify injection
              5. Verify real-time updates when new requests arrive


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/step-7-gherkin.md (scenarios to satisfy)
              3. context/step-7-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(step-7): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
          - id: refactor
            status: pending
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              Design and implement the Operator Queue View in the dashboard.

              ## IMPORTANT: UX/UI Planning First

              Before implementing, use a subagent (Explore/Plan) to:
              1. Research existing dashboard patterns and components
              2. Design the UX flow for operator interactions
              3. Create wireframes/mockups (can be ASCII or markdown)
              4. Get alignment on the design before coding

              ## Overview

              A dedicated view per sprint showing:
              - **Pending requests**: Waiting for operator decision
              - **Decided requests**: Approved, rejected, or deferred with reasoning

              This is THE central place to see what the operator is doing and why.

              ## UX Requirements

              ### Navigation
              - Accessible from sprint detail page (tab or sidebar link)
              - Badge showing pending count: "Operator (3)"
              - Quick access from notification when new request arrives

              ### Pending Requests Section

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 🔔 Pending Requests (3)                          [Process All] │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🔴 CRITICAL  Fix SQL injection in user input               │ │
              │ │ Discovered in: development-step-2 • 2 min ago              │ │
              │ │ Files: src/api/users.ts                                    │ │
              │ │ ┌─────────────────────────────────────────────────────────┐ │ │
              │ │ │ User input is passed directly to query without...       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Suggested: bugfix-workflow                                  │ │
              │ │                                    [Approve] [Reject] [Defer]│ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🟡 HIGH  Add rate limiting to API endpoints                 │ │
              │ │ Discovered in: development-step-3 • 5 min ago              │ │
              │ │ ...                                                         │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Decided Requests Section (History)

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📋 Decision History                    [Filter: All ▼] [Search]│
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ✅ APPROVED  Fix null pointer in config parser             │ │
              │ │ Decided: 10 min ago • Injected after: development-step-2   │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ This is a blocking bug that will cause test failures.   │ │ │
              │ │ │ Injecting immediately to unblock QA phase. Using        │ │ │
              │ │ │ bugfix-workflow for proper test coverage.               │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ❌ REJECTED  Refactor utils to use lodash                  │ │
              │ │ Decided: 15 min ago                                        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Invalid request - lodash adds unnecessary dependency.   │ │ │
              │ │ │ Current implementation is sufficient.                   │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ⏸️ DEFERRED  Add comprehensive logging                      │ │
              │ │ Decided: 20 min ago • Deferred until: end-of-sprint        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Good idea but not urgent. Will revisit after core       │ │ │
              │ │ │ features are complete.                                  │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Section (For Human Review)

              Items sent to backlog are NOT auto-implemented. They're tracked for human review.

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📝 Backlog (For Human Review)                    [Export CSV]  │
              ├─────────────────────────────────────────────────────────────────┤
              │ Items in backlog will NOT be auto-implemented. Review and      │
              │ convert to GitHub issues or add to future sprints manually.    │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Upgrade to OAuth2 authentication               │ │
              │ │ Category: tech-debt • Suggested Priority: medium           │ │
              │ │ Added: 25 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Valid improvement but significant scope. Current basic  │ │ │
              │ │ │ auth works for MVP. Recommend architectural review      │ │ │
              │ │ │ before implementing. Could be a dedicated sprint.       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: pending-review    [Create Issue] [Acknowledge] [Delete]│
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Add API versioning                             │ │
              │ │ Category: feature • Suggested Priority: low                │ │
              │ │ Added: 30 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Good practice but not needed yet - no external API      │ │ │
              │ │ │ consumers. Track for when we open API publicly.         │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: acknowledged      [Create Issue] [Delete]           │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Actions

              - **Create Issue**: Convert to GitHub issue (uses gh CLI)
              - **Acknowledge**: Mark as reviewed by human
              - **Delete**: Remove from backlog
              - **Export CSV**: Export all backlog items for external tracking

              ### Manual Actions (Human Override)

              Allow human to:
              - Manually approve/reject pending requests (bypassing operator)
              - Re-process a rejected request
              - Change deferred timing
              - Add notes to decisions

              ## Technical Requirements

              ### 1. Data Source

              Read from operator queue in PROGRESS.yaml or dedicated file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  status: pending | approved | rejected | deferred
                  ...
              ```

              ### 2. Real-time Updates

              - SSE events for queue changes
              - New event types: `operator-request`, `operator-decision`
              - Update UI without page refresh

              ### 3. API Endpoints

              ```
              GET  /api/sprint/:id/operator-queue         # List all requests
              GET  /api/sprint/:id/operator-queue/pending # Pending only
              POST /api/sprint/:id/operator-queue/:reqId/decide  # Manual decision
              POST /api/sprint/:id/operator/process       # Trigger operator run
              ```

              ### 4. Components

              Create modular components:
              - `OperatorRequestCard` - Single request display
              - `OperatorReasoningBlock` - Collapsible reasoning
              - `OperatorQueueList` - List with filtering
              - `OperatorStats` - Summary stats (pending, approved, rejected)

              ## Files to Modify

              **Status Server:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - Add queue view
              - plugins/m42-sprint/compiler/src/status-server/server.ts - Add API endpoints
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - Transform queue data

              **New Files:**
              - plugins/m42-sprint/compiler/src/status-server/operator-queue-page.ts - Dedicated page

              ## Implementation Approach

              1. **Phase A: Research & Design** (use Explore subagent)
                 - Study existing dashboard code structure
                 - Identify reusable components and patterns
                 - Create detailed wireframes
                 - Document component hierarchy

              2. **Phase B: Backend**
                 - Add queue storage to PROGRESS.yaml schema
                 - Implement API endpoints
                 - Add SSE event types

              3. **Phase C: Frontend**
                 - Implement components
                 - Add to navigation
                 - Wire up real-time updates

              4. **Phase D: Polish**
                 - Animations for new requests
                 - Empty states
                 - Error handling
                 - Mobile responsiveness

              ## Verification

              1. Navigate to operator queue view
              2. See pending requests with full details
              3. See decision history with reasoning
              4. Manually approve a request, verify injection
              5. Verify real-time updates when new requests arrive


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/step-7-context.md (target patterns)
              Read: artifacts/step-7-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(step-7): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-7-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/step-7-qa-report.md

              ```markdown
              # QA Report: step-7

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/step-7-qa-report.md
              git commit -m "qa(step-7): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for step-7.\n\nRead: artifacts/step-7-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/step-7-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Design and implement the Operator Queue View in the dashboard.

              ## IMPORTANT: UX/UI Planning First

              Before implementing, use a subagent (Explore/Plan) to:
              1. Research existing dashboard patterns and components
              2. Design the UX flow for operator interactions
              3. Create wireframes/mockups (can be ASCII or markdown)
              4. Get alignment on the design before coding

              ## Overview

              A dedicated view per sprint showing:
              - **Pending requests**: Waiting for operator decision
              - **Decided requests**: Approved, rejected, or deferred with reasoning

              This is THE central place to see what the operator is doing and why.

              ## UX Requirements

              ### Navigation
              - Accessible from sprint detail page (tab or sidebar link)
              - Badge showing pending count: "Operator (3)"
              - Quick access from notification when new request arrives

              ### Pending Requests Section

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 🔔 Pending Requests (3)                          [Process All] │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🔴 CRITICAL  Fix SQL injection in user input               │ │
              │ │ Discovered in: development-step-2 • 2 min ago              │ │
              │ │ Files: src/api/users.ts                                    │ │
              │ │ ┌─────────────────────────────────────────────────────────┐ │ │
              │ │ │ User input is passed directly to query without...       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Suggested: bugfix-workflow                                  │ │
              │ │                                    [Approve] [Reject] [Defer]│ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 🟡 HIGH  Add rate limiting to API endpoints                 │ │
              │ │ Discovered in: development-step-3 • 5 min ago              │ │
              │ │ ...                                                         │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Decided Requests Section (History)

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📋 Decision History                    [Filter: All ▼] [Search]│
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ✅ APPROVED  Fix null pointer in config parser             │ │
              │ │ Decided: 10 min ago • Injected after: development-step-2   │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ This is a blocking bug that will cause test failures.   │ │ │
              │ │ │ Injecting immediately to unblock QA phase. Using        │ │ │
              │ │ │ bugfix-workflow for proper test coverage.               │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ❌ REJECTED  Refactor utils to use lodash                  │ │
              │ │ Decided: 15 min ago                                        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Invalid request - lodash adds unnecessary dependency.   │ │ │
              │ │ │ Current implementation is sufficient.                   │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ ⏸️ DEFERRED  Add comprehensive logging                      │ │
              │ │ Decided: 20 min ago • Deferred until: end-of-sprint        │ │
              │ │ ┌─ Operator Reasoning ─────────────────────────────────────┐ │ │
              │ │ │ Good idea but not urgent. Will revisit after core       │ │ │
              │ │ │ features are complete.                                  │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Section (For Human Review)

              Items sent to backlog are NOT auto-implemented. They're tracked for human review.

              ```
              ┌─────────────────────────────────────────────────────────────────┐
              │ 📝 Backlog (For Human Review)                    [Export CSV]  │
              ├─────────────────────────────────────────────────────────────────┤
              │ Items in backlog will NOT be auto-implemented. Review and      │
              │ convert to GitHub issues or add to future sprints manually.    │
              ├─────────────────────────────────────────────────────────────────┤
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Upgrade to OAuth2 authentication               │ │
              │ │ Category: tech-debt • Suggested Priority: medium           │ │
              │ │ Added: 25 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Valid improvement but significant scope. Current basic  │ │ │
              │ │ │ auth works for MVP. Recommend architectural review      │ │ │
              │ │ │ before implementing. Could be a dedicated sprint.       │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: pending-review    [Create Issue] [Acknowledge] [Delete]│
              │ └─────────────────────────────────────────────────────────────┘ │
              │                                                                 │
              │ ┌─────────────────────────────────────────────────────────────┐ │
              │ │ 📌 BACKLOG  Add API versioning                             │ │
              │ │ Category: feature • Suggested Priority: low                │ │
              │ │ Added: 30 min ago                                          │ │
              │ │ ┌─ Operator Notes ─────────────────────────────────────────┐ │ │
              │ │ │ Good practice but not needed yet - no external API      │ │ │
              │ │ │ consumers. Track for when we open API publicly.         │ │ │
              │ │ └─────────────────────────────────────────────────────────┘ │ │
              │ │ Status: acknowledged      [Create Issue] [Delete]           │ │
              │ └─────────────────────────────────────────────────────────────┘ │
              └─────────────────────────────────────────────────────────────────┘
              ```

              ### Backlog Actions

              - **Create Issue**: Convert to GitHub issue (uses gh CLI)
              - **Acknowledge**: Mark as reviewed by human
              - **Delete**: Remove from backlog
              - **Export CSV**: Export all backlog items for external tracking

              ### Manual Actions (Human Override)

              Allow human to:
              - Manually approve/reject pending requests (bypassing operator)
              - Re-process a rejected request
              - Change deferred timing
              - Add notes to decisions

              ## Technical Requirements

              ### 1. Data Source

              Read from operator queue in PROGRESS.yaml or dedicated file:
              ```yaml
              operator-queue:
                - id: req_abc123
                  status: pending | approved | rejected | deferred
                  ...
              ```

              ### 2. Real-time Updates

              - SSE events for queue changes
              - New event types: `operator-request`, `operator-decision`
              - Update UI without page refresh

              ### 3. API Endpoints

              ```
              GET  /api/sprint/:id/operator-queue         # List all requests
              GET  /api/sprint/:id/operator-queue/pending # Pending only
              POST /api/sprint/:id/operator-queue/:reqId/decide  # Manual decision
              POST /api/sprint/:id/operator/process       # Trigger operator run
              ```

              ### 4. Components

              Create modular components:
              - `OperatorRequestCard` - Single request display
              - `OperatorReasoningBlock` - Collapsible reasoning
              - `OperatorQueueList` - List with filtering
              - `OperatorStats` - Summary stats (pending, approved, rejected)

              ## Files to Modify

              **Status Server:**
              - plugins/m42-sprint/compiler/src/status-server/page.ts - Add queue view
              - plugins/m42-sprint/compiler/src/status-server/server.ts - Add API endpoints
              - plugins/m42-sprint/compiler/src/status-server/transforms.ts - Transform queue data

              **New Files:**
              - plugins/m42-sprint/compiler/src/status-server/operator-queue-page.ts - Dedicated page

              ## Implementation Approach

              1. **Phase A: Research & Design** (use Explore subagent)
                 - Study existing dashboard code structure
                 - Identify reusable components and patterns
                 - Create detailed wireframes
                 - Document component hierarchy

              2. **Phase B: Backend**
                 - Add queue storage to PROGRESS.yaml schema
                 - Implement API endpoints
                 - Add SSE event types

              3. **Phase C: Frontend**
                 - Implement components
                 - Add to navigation
                 - Wire up real-time updates

              4. **Phase D: Polish**
                 - Animations for new requests
                 - Empty states
                 - Error handling
                 - Mobile responsiveness

              ## Verification

              1. Navigate to operator queue view
              2. See pending requests with full details
              3. See decision history with reasoning
              4. Manually approve a request, verify injection
              5. Verify real-time updates when new requests arrive


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-7-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(step-7): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
      - id: step-8
        prompt: |
          Run complete end-to-end verification of all dashboard improvements.

          Test all features:
          1. Live Activity: Start sprint, verify chat-style display with assistant messages
          2. Elapsed time: Verify steps show timing in sidebar
          3. Sprint timer: Verify prominent HH:MM:SS display in header
          4. Step count: Verify "Step X of Y" indicator
          5. Sprint switching: Use dropdown to switch sprints
          6. Stale detection: Kill a sprint and verify stale indicator
          7. Model selection: Verify model override works at step/phase/sprint/workflow levels
          8. Workflow reference: Verify single-phase workflow references expand correctly
          9. Operator requests: Verify agents can submit requests, operator processes them
          10. Dynamic injection: Verify steps can be injected at various positions
          11. Operator queue view: Verify pending/decided requests display with reasoning

          Build and test:
          - Run npm run build in plugins/m42-sprint/compiler
          - Run npm run build in plugins/m42-sprint/runtime
          - Reinstall plugin and verify all features work
        status: pending
        phases:
          - id: context
            status: pending
            prompt: |
              Prepare context for TDD development.

              ## Step 0: Ensure Working in Worktree (if applicable)
              ```bash
              # If trees directory exists, switch to worktree
              if [ -d "trees/2026-01-20_dashboard-improvements" ]; then
                cd trees/2026-01-20_dashboard-improvements
              fi
              pwd
              git branch --show-current
              ```

              ## Step 1: Read Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Step 2: Understand the Step
              Run complete end-to-end verification of all dashboard improvements.

              Test all features:
              1. Live Activity: Start sprint, verify chat-style display with assistant messages
              2. Elapsed time: Verify steps show timing in sidebar
              3. Sprint timer: Verify prominent HH:MM:SS display in header
              4. Step count: Verify "Step X of Y" indicator
              5. Sprint switching: Use dropdown to switch sprints
              6. Stale detection: Kill a sprint and verify stale indicator
              7. Model selection: Verify model override works at step/phase/sprint/workflow levels
              8. Workflow reference: Verify single-phase workflow references expand correctly
              9. Operator requests: Verify agents can submit requests, operator processes them
              10. Dynamic injection: Verify steps can be injected at various positions
              11. Operator queue view: Verify pending/decided requests display with reasoning

              Build and test:
              - Run npm run build in plugins/m42-sprint/compiler
              - Run npm run build in plugins/m42-sprint/runtime
              - Reinstall plugin and verify all features work


              ## Output
              Confirm understanding of:
              - Test patterns and locations
              - Build/test commands
              - The step requirements
          - id: red
            status: pending
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              Run complete end-to-end verification of all dashboard improvements.

              Test all features:
              1. Live Activity: Start sprint, verify chat-style display with assistant messages
              2. Elapsed time: Verify steps show timing in sidebar
              3. Sprint timer: Verify prominent HH:MM:SS display in header
              4. Step count: Verify "Step X of Y" indicator
              5. Sprint switching: Use dropdown to switch sprints
              6. Stale detection: Kill a sprint and verify stale indicator
              7. Model selection: Verify model override works at step/phase/sprint/workflow levels
              8. Workflow reference: Verify single-phase workflow references expand correctly
              9. Operator requests: Verify agents can submit requests, operator processes them
              10. Dynamic injection: Verify steps can be injected at various positions
              11. Operator queue view: Verify pending/decided requests display with reasoning

              Build and test:
              - Run npm run build in plugins/m42-sprint/compiler
              - Run npm run build in plugins/m42-sprint/runtime
              - Reinstall plugin and verify all features work


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/step-8-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-8

              ## Step Task
              Run complete end-to-end verification of all dashboard improvements.

              Test all features:
              1. Live Activity: Start sprint, verify chat-style display with assistant messages
              2. Elapsed time: Verify steps show timing in sidebar
              3. Sprint timer: Verify prominent HH:MM:SS display in header
              4. Step count: Verify "Step X of Y" indicator
              5. Sprint switching: Use dropdown to switch sprints
              6. Stale detection: Kill a sprint and verify stale indicator
              7. Model selection: Verify model override works at step/phase/sprint/workflow levels
              8. Workflow reference: Verify single-phase workflow references expand correctly
              9. Operator requests: Verify agents can submit requests, operator processes them
              10. Dynamic injection: Verify steps can be injected at various positions
              11. Operator queue view: Verify pending/decided requests display with reasoning

              Build and test:
              - Run npm run build in plugins/m42-sprint/compiler
              - Run npm run build in plugins/m42-sprint/runtime
              - Reinstall plugin and verify all features work


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/step-8-gherkin.md
              git commit -m "test(step-8): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
          - id: green-context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Run complete end-to-end verification of all dashboard improvements.

              Test all features:
              1. Live Activity: Start sprint, verify chat-style display with assistant messages
              2. Elapsed time: Verify steps show timing in sidebar
              3. Sprint timer: Verify prominent HH:MM:SS display in header
              4. Step count: Verify "Step X of Y" indicator
              5. Sprint switching: Use dropdown to switch sprints
              6. Stale detection: Kill a sprint and verify stale indicator
              7. Model selection: Verify model override works at step/phase/sprint/workflow levels
              8. Workflow reference: Verify single-phase workflow references expand correctly
              9. Operator requests: Verify agents can submit requests, operator processes them
              10. Dynamic injection: Verify steps can be injected at various positions
              11. Operator queue view: Verify pending/decided requests display with reasoning

              Build and test:
              - Run npm run build in plugins/m42-sprint/compiler
              - Run npm run build in plugins/m42-sprint/runtime
              - Reinstall plugin and verify all features work


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/step-8-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/step-8-context.md

              ```markdown
              # Step Context: step-8

              ## Task
              Run complete end-to-end verification of all dashboard improvements.

              Test all features:
              1. Live Activity: Start sprint, verify chat-style display with assistant messages
              2. Elapsed time: Verify steps show timing in sidebar
              3. Sprint timer: Verify prominent HH:MM:SS display in header
              4. Step count: Verify "Step X of Y" indicator
              5. Sprint switching: Use dropdown to switch sprints
              6. Stale detection: Kill a sprint and verify stale indicator
              7. Model selection: Verify model override works at step/phase/sprint/workflow levels
              8. Workflow reference: Verify single-phase workflow references expand correctly
              9. Operator requests: Verify agents can submit requests, operator processes them
              10. Dynamic injection: Verify steps can be injected at various positions
              11. Operator queue view: Verify pending/decided requests display with reasoning

              Build and test:
              - Run npm run build in plugins/m42-sprint/compiler
              - Run npm run build in plugins/m42-sprint/runtime
              - Reinstall plugin and verify all features work


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/step-8-context.md
              git commit -m "context(step-8): gather implementation context"
              ```
          - id: green
            status: pending
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              Run complete end-to-end verification of all dashboard improvements.

              Test all features:
              1. Live Activity: Start sprint, verify chat-style display with assistant messages
              2. Elapsed time: Verify steps show timing in sidebar
              3. Sprint timer: Verify prominent HH:MM:SS display in header
              4. Step count: Verify "Step X of Y" indicator
              5. Sprint switching: Use dropdown to switch sprints
              6. Stale detection: Kill a sprint and verify stale indicator
              7. Model selection: Verify model override works at step/phase/sprint/workflow levels
              8. Workflow reference: Verify single-phase workflow references expand correctly
              9. Operator requests: Verify agents can submit requests, operator processes them
              10. Dynamic injection: Verify steps can be injected at various positions
              11. Operator queue view: Verify pending/decided requests display with reasoning

              Build and test:
              - Run npm run build in plugins/m42-sprint/compiler
              - Run npm run build in plugins/m42-sprint/runtime
              - Reinstall plugin and verify all features work


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/step-8-gherkin.md (scenarios to satisfy)
              3. context/step-8-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(step-8): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
          - id: refactor
            status: pending
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              Run complete end-to-end verification of all dashboard improvements.

              Test all features:
              1. Live Activity: Start sprint, verify chat-style display with assistant messages
              2. Elapsed time: Verify steps show timing in sidebar
              3. Sprint timer: Verify prominent HH:MM:SS display in header
              4. Step count: Verify "Step X of Y" indicator
              5. Sprint switching: Use dropdown to switch sprints
              6. Stale detection: Kill a sprint and verify stale indicator
              7. Model selection: Verify model override works at step/phase/sprint/workflow levels
              8. Workflow reference: Verify single-phase workflow references expand correctly
              9. Operator requests: Verify agents can submit requests, operator processes them
              10. Dynamic injection: Verify steps can be injected at various positions
              11. Operator queue view: Verify pending/decided requests display with reasoning

              Build and test:
              - Run npm run build in plugins/m42-sprint/compiler
              - Run npm run build in plugins/m42-sprint/runtime
              - Reinstall plugin and verify all features work


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/step-8-context.md (target patterns)
              Read: artifacts/step-8-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(step-8): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-8-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/step-8-qa-report.md

              ```markdown
              # QA Report: step-8

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/step-8-qa-report.md
              git commit -m "qa(step-8): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for step-8.\n\nRead: artifacts/step-8-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/step-8-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Run complete end-to-end verification of all dashboard improvements.

              Test all features:
              1. Live Activity: Start sprint, verify chat-style display with assistant messages
              2. Elapsed time: Verify steps show timing in sidebar
              3. Sprint timer: Verify prominent HH:MM:SS display in header
              4. Step count: Verify "Step X of Y" indicator
              5. Sprint switching: Use dropdown to switch sprints
              6. Stale detection: Kill a sprint and verify stale indicator
              7. Model selection: Verify model override works at step/phase/sprint/workflow levels
              8. Workflow reference: Verify single-phase workflow references expand correctly
              9. Operator requests: Verify agents can submit requests, operator processes them
              10. Dynamic injection: Verify steps can be injected at various positions
              11. Operator queue view: Verify pending/decided requests display with reasoning

              Build and test:
              - Run npm run build in plugins/m42-sprint/compiler
              - Run npm run build in plugins/m42-sprint/runtime
              - Reinstall plugin and verify all features work


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-8-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(step-8): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
    started-at: '2026-01-20T21:41:57.876Z'
  - id: doc-analyze
    status: pending
    prompt: |
      Analyze code changes and plan documentation updates.

      ## Step 0: Ensure Working in Worktree
      ```bash
      cd trees/2026-01-20_dashboard-improvements 2>/dev/null || true
      pwd
      git branch --show-current  # Verify: sprint/2026-01-20_dashboard-improvements
      ```

      ## Context
      Read: context/_shared-context.md (documentation structure)
      Read: context/sprint-plan.md (documentation update plan)

      ## Step 1: Review All Code Changes
      ```bash
      # See all changes in this sprint
      git diff main..HEAD --name-only

      # Get detailed diff
      git diff main..HEAD -- "*.ts" "*.tsx" "*.js"
      ```

      ## Step 2: Identify Documentation Impact

      For each change, determine:
      - New features that need documenting
      - Changed behavior that needs updating
      - Removed features that need removing from docs
      - New/changed CLI commands
      - New/changed configuration options
      - New/changed API endpoints or functions

      ## Step 3: Audit Existing Documentation
      ```bash
      # Find all documentation files
      find . -name "*.md" -path "*/docs/*" -o -name "README.md" | head -30
      ```

      Review each relevant doc file and note:
      - What's accurate and complete
      - What's outdated
      - What's missing

      ## Step 4: Generate Documentation Plan
      Create: artifacts/docs-update-plan.md

      ```markdown
      # Documentation Update Plan: 2026-01-20_dashboard-improvements

      ## Code Changes Summary
      | File | Change Type | Description |
      |------|-------------|-------------|
      | [path] | Added/Modified | [what changed] |

      ## Documentation Impact

      ### User Guide Updates
      | Section | Action | Reason |
      |---------|--------|--------|
      | [section] | Update/Add/Remove | [why] |

      ### Getting Started Updates
      | Section | Action | Reason |
      |---------|--------|--------|
      | [section] | Update/Add | [why] |

      ### Reference Updates
      | Item | Action | Details |
      |------|--------|---------|
      | [command/function] | Update/Add | [changes] |

      ## New Documentation Needed
      - [ ] [New doc 1]: [purpose]
      - [ ] [New doc 2]: [purpose]

      ## Files to Update
      | File | Updates Needed |
      |------|----------------|
      | [path] | [specific updates] |

      ## Verification Plan
      - [ ] All code examples tested
      - [ ] All commands verified
      - [ ] All links checked
      ```

      ## Commit
      ```bash
      git add artifacts/docs-update-plan.md
      git commit -m "docs(plan): documentation update analysis"
      ```
  - id: doc-user-guide
    status: pending
    prompt: |
      Update user-facing documentation based on analysis.

      ## Context
      Read: artifacts/docs-update-plan.md (what needs updating)
      Read: context/_shared-context.md (documentation structure)

      ## User Guide Principles
      1. **Task-oriented**: Organize by what users want to DO
      2. **Progressive**: Simple → Advanced
      3. **Example-rich**: Every feature needs an example
      4. **Scannable**: Use headers, lists, tables

      ## Step 1: Locate or Create User Guide
      The user guide should be at: `docs/USER-GUIDE.md` or `docs/user-guide/`

      If it doesn't exist, create it using the template below.

      ## Step 2: Update Each Section

      For each item in docs-update-plan.md's "User Guide Updates":

      ### Adding New Features
      ```markdown
      ## [Feature Name]

      [One paragraph explaining WHAT it does and WHY you'd use it]

      ### Quick Example
      \`\`\`bash
      # Show the simplest possible example
      [command or code]
      \`\`\`

      ### How It Works
      [Explain the feature in more detail]

      ### Examples

      #### Basic Usage
      \`\`\`bash
      [example]
      \`\`\`

      #### Advanced Usage
      \`\`\`bash
      [example with options]
      \`\`\`

      ### Tips
      - [Helpful tip 1]
      - [Helpful tip 2]
      ```

      ### Updating Existing Features
      - Locate the existing section
      - Update examples if behavior changed
      - Update descriptions if functionality changed
      - Add new subsections for new capabilities

      ### Removing Features
      - Remove the section entirely
      - Or add deprecation notice if replacing

      ## Step 3: Verify Examples Work
      Run each code example in the documentation to ensure it works:
      ```bash
      # Test each example manually
      [example command from docs]
      ```

      ## Step 4: Commit Updates
      ```bash
      git add docs/
      git commit -m "docs(user-guide): update for 2026-01-20_dashboard-improvements changes"
      ```
  - id: doc-getting-started
    status: pending
    prompt: |
      Update getting started and quickstart documentation.

      ## Context
      Read: artifacts/docs-update-plan.md (what needs updating)
      Read: context/_shared-context.md (documentation structure)

      ## Getting Started Principles
      1. **Fast**: Get to "Hello World" in < 5 steps
      2. **Complete**: All prerequisites clearly listed
      3. **Copy-paste**: Every command should work as written
      4. **No assumptions**: Don't assume prior knowledge

      ## Step 1: Locate or Create Getting Started
      Should be at: `docs/getting-started/` or `docs/QUICKSTART.md` or in README.md

      ## Step 2: Update Prerequisites
      List everything needed before starting:
      ```markdown
      ## Prerequisites

      - [Requirement 1] - [how to check/install]
      - [Requirement 2] - [how to check/install]

      ### Version Requirements
      | Tool | Minimum Version | Check Command |
      |------|-----------------|---------------|
      | [tool] | [version] | `[command]` |
      ```

      ## Step 3: Update Installation
      ```markdown
      ## Installation

      ### Option 1: [Primary method]
      \`\`\`bash
      [installation commands]
      \`\`\`

      ### Option 2: [Alternative method]
      \`\`\`bash
      [alternative commands]
      \`\`\`

      ### Verify Installation
      \`\`\`bash
      [verification command]
      # Expected output: [what they should see]
      \`\`\`
      ```

      ## Step 4: Update First Steps
      ```markdown
      ## Your First [Thing]

      ### Step 1: [Action]
      \`\`\`bash
      [command]
      \`\`\`

      You should see:
      \`\`\`
      [expected output]
      \`\`\`

      ### Step 2: [Action]
      [Continue with clear steps]

      ### Step 3: [Action]
      [Each step should be verifiable]

      ## Success!
      You've now [accomplished goal]. Next steps:
      - [Link to User Guide]
      - [Link to next tutorial]
      ```

      ## Step 5: Update README Quick Example
      If README.md has a quick example section, ensure it's current:
      - Examples should work with latest code
      - Version numbers should be accurate
      - Links should be valid

      ## Step 6: Test the Flow
      Follow the getting started guide yourself:
      1. Start from a fresh state
      2. Run each command exactly as written
      3. Verify expected outputs match
      4. Fix any issues found

      ## Step 7: Commit Updates
      ```bash
      git add docs/ README.md
      git commit -m "docs(getting-started): update onboarding for 2026-01-20_dashboard-improvements"
      ```
  - id: doc-reference
    status: pending
    prompt: |
      Update technical reference and API documentation.

      ## Context
      Read: artifacts/docs-update-plan.md (what needs updating)
      Read: context/_shared-context.md (documentation structure)

      ## Reference Documentation Principles
      1. **Complete**: Document ALL public APIs
      2. **Accurate**: Generated from code when possible
      3. **Structured**: Consistent format for all items
      4. **Searchable**: Easy to find specific items

      ## Step 1: Locate or Create Reference Docs
      Should be at: `docs/reference/` or `docs/api/`

      ## Step 2: Update Command Reference
      For CLI commands, use this format:

      ```markdown
      ## Commands Reference

      ### [command-name]

      [One-line description]

      #### Synopsis
      \`\`\`
      [command] [options] [arguments]
      \`\`\`

      #### Description
      [Detailed description of what the command does]

      #### Options
      | Option | Type | Default | Description |
      |--------|------|---------|-------------|
      | `--option` | string | none | [description] |
      | `-f, --flag` | boolean | false | [description] |

      #### Arguments
      | Argument | Required | Description |
      |----------|----------|-------------|
      | `<name>` | Yes | [description] |
      | `[path]` | No | [description] |

      #### Examples
      \`\`\`bash
      # Basic usage
      [command] [basic-args]

      # With options
      [command] --option value

      # Advanced usage
      [command] --flag -o value
      \`\`\`

      #### See Also
      - [Related command 1]
      - [Related command 2]
      ```

      ## Step 3: Update API Reference
      For functions/classes, use this format:

      ```markdown
      ## API Reference

      ### [FunctionName]

      \`\`\`typescript
      function name(param: Type): ReturnType
      \`\`\`

      [Description of what the function does]

      #### Parameters
      | Parameter | Type | Required | Description |
      |-----------|------|----------|-------------|
      | `param` | `Type` | Yes | [description] |

      #### Returns
      `ReturnType` - [description of return value]

      #### Throws
      - `ErrorType` - [when this error is thrown]

      #### Example
      \`\`\`typescript
      const result = name(value);
      console.log(result); // [expected output]
      \`\`\`
      ```

      ## Step 4: Update Configuration Reference
      For config options:

      ```markdown
      ## Configuration Reference

      ### [config-file-name]

      #### Schema
      \`\`\`yaml
      # Full schema with comments
      option: value  # description
      nested:
        key: value   # description
      \`\`\`

      #### Options

      ##### `option`
      - **Type**: string
      - **Required**: Yes/No
      - **Default**: `value`
      - **Description**: [what this option does]
      - **Example**: `option: "example"`
      ```

      ## Step 5: Update Type Definitions
      If there are TypeScript types that users need to know:

      ```markdown
      ## Type Definitions

      ### [TypeName]
      \`\`\`typescript
      interface TypeName {
        property: string;
        optional?: number;
      }
      \`\`\`

      | Property | Type | Required | Description |
      |----------|------|----------|-------------|
      | `property` | `string` | Yes | [description] |
      ```

      ## Step 6: Verify Reference Accuracy
      - Check that all documented APIs actually exist
      - Verify parameter names and types match code
      - Test example code snippets

      ## Step 7: Commit Updates
      ```bash
      git add docs/reference/
      git commit -m "docs(reference): update API and command reference for 2026-01-20_dashboard-improvements"
      ```
  - id: doc-validate
    status: pending
    prompt: |
      Validate all documentation updates.

      ## Context
      Read: artifacts/docs-update-plan.md (original plan)

      ## Step 1: Completeness Check
      Verify all planned updates were made:
      ```bash
      # Show all doc changes in this sprint
      git diff main..HEAD -- "*.md" --stat
      ```

      Cross-reference with docs-update-plan.md:
      - [ ] All User Guide updates complete
      - [ ] All Getting Started updates complete
      - [ ] All Reference updates complete
      - [ ] All new docs created

      ## Step 2: Link Validation
      Check all internal links work:
      ```bash
      # Find all markdown links
      grep -rh "\[.*\](.*\.md)" docs/ | head -30
      ```

      Verify each linked file exists.

      ## Step 3: Code Example Validation
      Test each code example in the documentation:
      - Run CLI examples
      - Compile TypeScript examples
      - Execute JavaScript examples

      Document any failures.

      ## Step 4: Consistency Check
      - Consistent formatting across all docs
      - Consistent terminology
      - Consistent example style
      - Version numbers match

      ## Step 5: Generate Validation Report
      Create: artifacts/docs-validation-report.md

      ```markdown
      # Documentation Validation Report: 2026-01-20_dashboard-improvements

      ## Completeness
      | Planned Update | Status | Notes |
      |----------------|--------|-------|
      | [update 1] | DONE/MISSING | [notes] |

      ## Link Validation
      | Link | Target | Status |
      |------|--------|--------|
      | [link text] | [file] | OK/BROKEN |

      ## Code Example Validation
      | File | Example | Status | Output |
      |------|---------|--------|--------|
      | [path] | Line [N] | PASS/FAIL | [output] |

      ## Consistency Check
      - [ ] Formatting consistent
      - [ ] Terminology consistent
      - [ ] Examples consistent
      - [ ] Versions accurate

      ## Issues Found
      [List any issues, or "None"]

      ## Documentation Files Updated
      | File | Lines Changed | Summary |
      |------|---------------|---------|
      | [path] | +[N]/-[N] | [summary] |

      ## Overall Status: PASS / FAIL
      ```

      ## Step 6: Fix Any Issues
      If validation found issues:
      - Fix broken links
      - Update failed examples
      - Correct inconsistencies

      ## Step 7: Final Commit
      ```bash
      git add artifacts/docs-validation-report.md
      git add docs/  # Any fixes
      git commit -m "docs(validate): documentation verified for 2026-01-20_dashboard-improvements"
      ```

      ## Important
      Documentation must pass validation before sprint can complete.
      All code examples must work with the actual code.
  - id: final-qa
    status: pending
    prompt: |
      Comprehensive Quality Assurance for the entire sprint.

      ## Step 0: Ensure Working in Worktree
      ```bash
      cd trees/2026-01-20_dashboard-improvements 2>/dev/null || true
      pwd
      git branch --show-current  # Verify: sprint/2026-01-20_dashboard-improvements
      ```

      ## Context
      Read: context/_shared-context.md for build/test commands
      Read: context/sprint-plan.md for success criteria

      ## Step 1: Full Build Verification
      Run ALL build checks:
      ```bash
      npm run build
      npm run typecheck
      npm run lint
      ```

      Record each result in the QA report.

      ## Step 2: Complete Test Suite
      Run the full test suite:
      ```bash
      npm test
      ```

      Record test results, coverage, and any failures.

      ## Step 3: Review All Step QA Reports
      Read all artifacts/step-*-qa-report.md files:
      - Verify all steps show PASS status
      - Calculate total gherkin score
      - Consolidate warnings or notes

      ## Step 4: Documentation Verification
      Verify documentation was updated:
      ```bash
      # Check for documentation changes
      git diff main..HEAD -- "*.md" --stat
      ```

      Verify:
      - User guide reflects new features
      - Getting started is accurate
      - Reference material is complete
      - Examples work correctly

      ## Step 5: Integration Verification
      - Check modules properly import each other
      - Verify no circular dependencies
      - Test end-to-end flow if applicable

      ## Step 6: Regression Check
      ```bash
      git diff main...HEAD --stat
      ```

      Verify:
      - No unintended changes
      - All modified files are expected
      - No debug code left in

      ## Step 7: Generate Sprint QA Report
      Create: artifacts/sprint-qa-report.md

      ```markdown
      # Sprint QA Report: 2026-01-20_dashboard-improvements

      ## Build Verification
      | Check | Result | Output |
      |-------|--------|--------|
      | Build | PASS/FAIL | [summary] |
      | TypeCheck | PASS/FAIL | [summary] |
      | Lint | PASS/FAIL | [summary] |

      ## Test Suite
      | Metric | Value |
      |--------|-------|
      | Tests Run | [count] |
      | Passed | [count] |
      | Failed | [count] |
      | Coverage | [percentage] |

      ## Gherkin Scenario Summary
      | Step | Total | Passed | Score |
      |------|-------|--------|-------|
      | step-0 | [N] | [N] | 100% |
      | step-1 | [N] | [N] | 100% |
      | **Total** | [N] | [N] | **100%** |

      ## Documentation Status
      | Document | Status | Changes |
      |----------|--------|---------|
      | User Guide | PASS/FAIL | [summary] |
      | Getting Started | PASS/FAIL | [summary] |
      | Reference | PASS/FAIL | [summary] |

      ## Integration Verification
      - [ ] Modules import correctly
      - [ ] No circular dependencies
      - [ ] End-to-end flow works

      ## Overall Status: PASS / FAIL
      ```

      ## Step 8: Handle Outcome

      ### If PASS:
      ```bash
      git add artifacts/sprint-qa-report.md
      git commit -m "qa: sprint-level verification passed"
      ```

      ### If FAIL:
      - Document specific failures
      - Set status to needs-human with details
  - id: summary
    status: pending
    prompt: |
      Generate sprint summary with TDD and documentation highlights.

      ## Context
      Read: context/sprint-plan.md for original goals
      Read: artifacts/sprint-qa-report.md for verification results
      Read: All artifacts/step-*-qa-report.md for step details

      ## Step 1: Collect Commit History
      ```bash
      git log main..HEAD --oneline --no-decorate
      ```

      ## Step 2: Collect File Changes
      ```bash
      git diff main..HEAD --stat
      ```

      ## Step 3: Generate Sprint Summary
      Create: artifacts/sprint-summary.md

      ```markdown
      # Sprint Summary: 2026-01-20_dashboard-improvements

      ## What Was Accomplished

      ### Step 0: [Step title]
      **TDD Cycle**:
      - Tests written: [count]
      - Gherkin scenarios: [count], all passing

      **Implementation**:
      - [Key accomplishment 1]
      - [Key accomplishment 2]

      **Files**: [list]

      [Continue for each step]

      ## Test Coverage Summary
      | Metric | Before | After | Delta |
      |--------|--------|-------|-------|
      | Tests | [N] | [N] | +[N] |
      | Gherkin | [N] | [N] | +[N] |
      | Coverage | [%] | [%] | +[%] |

      ## Documentation Updates
      | Document | Change |
      |----------|--------|
      | [path] | [what changed] |

      ## Files Changed
      | File | Change Type | Description |
      |------|-------------|-------------|
      | [path] | Created/Modified | [description] |

      ## Commits Made
      | Hash | Type | Message |
      |------|------|---------|
      | [hash] | test | [message] |
      | [hash] | feat | [message] |
      | [hash] | docs | [message] |

      ## Verification Status
      - Build: PASS
      - TypeCheck: PASS
      - Lint: PASS
      - Tests: [X/Y passed]
      - Gherkin: [X/Y scenarios, 100%]
      - Documentation: Updated

      ## Sprint Statistics
      - Steps completed: [X/Y]
      - Total commits: [count]
      - Tests added: [count]
      - Gherkin scenarios: [count]
      - Files changed: [count]
      ```

      ## Step 4: Commit Summary
      ```bash
      git add artifacts/sprint-summary.md
      git commit -m "docs: add sprint summary"
      ```
  - id: version-bump
    status: pending
    prompt: |
      Increment the plugin version number.

      ## Step 0: Ensure Working in Worktree
      ```bash
      cd trees/2026-01-20_dashboard-improvements 2>/dev/null || true
      pwd
      ```

      ## Step 1: Identify the Plugin
      Determine which plugin this sprint modifies by checking:
      1. The sprint name/id for plugin hints
      2. Files changed in this sprint
      3. The SPRINT.yaml description

      ```bash
      # List changed files to identify plugin
      git diff main..HEAD --name-only | grep "^plugins/" | cut -d'/' -f2 | sort -u
      ```

      ## Step 2: Read Current Versions
      For the identified plugin (e.g., `m42-sprint`):

      ```bash
      # Plugin's own version
      cat plugins/<plugin-name>/.claude-plugin/plugin.json | grep version

      # Marketplace entry version
      cat .claude-plugin/marketplace.json | grep -A5 '"<plugin-name>"'
      ```

      ## Step 3: Determine Version Bump Type
      Based on changes in this sprint:
      - **MAJOR** (X.0.0): Breaking changes, incompatible API changes
      - **MINOR** (0.X.0): New features, backward-compatible additions
      - **PATCH** (0.0.X): Bug fixes, small improvements

      Default to MINOR for feature sprints, PATCH for bugfix sprints.

      ## Step 4: Update Plugin Version
      Update `plugins/<plugin-name>/.claude-plugin/plugin.json`:

      ```bash
      # Example: bump from 2.0.0 to 2.1.0
      # Use jq or manual edit to update version field
      ```

      ## Step 5: Update Marketplace Version
      Update `.claude-plugin/marketplace.json` to match:

      Find the plugin entry and update its version to match plugin.json.

      **IMPORTANT**: Both versions MUST be identical.

      ## Step 6: Commit Version Bump
      ```bash
      git add plugins/<plugin-name>/.claude-plugin/plugin.json
      git add .claude-plugin/marketplace.json
      git commit -m "chore: bump <plugin-name> version to X.Y.Z"
      ```

      ## Output
      - Plugin version updated in `plugins/<plugin-name>/.claude-plugin/plugin.json`
      - Marketplace version updated in `.claude-plugin/marketplace.json`
      - Both versions are in sync
  - id: pr-create
    status: pending
    prompt: |
      Push the sprint branch and create a pull request.

      ## Context
      Read: artifacts/sprint-summary.md for PR body content
      Read: artifacts/sprint-qa-report.md for verification checklist
      Read: context/worktree-info.md for worktree paths

      ## Step 0: Verify Working in Worktree
      ```bash
      # Ensure we're in the sprint worktree
      pwd
      git branch --show-current  # Should be: sprint/2026-01-20_dashboard-improvements
      ```

      ## Step 1: Ensure All Changes Committed
      ```bash
      git status
      ```

      ## Step 2: Push Branch
      ```bash
      git push -u origin sprint/2026-01-20_dashboard-improvements
      ```

      ## Step 3: Create Pull Request
      ```bash
      gh pr create \
        --title "Sprint: 2026-01-20_dashboard-improvements" \
        --body "$(cat <<'EOF'
      ## Summary
      [Extract key points from sprint-summary.md]

      ## TDD Approach
      - Tests written first for each step
      - All gherkin scenarios pass
      - [X] new tests added

      ## Changes
      [List major changes]

      ## Documentation
      - [ ] User Guide updated
      - [ ] Getting Started updated
      - [ ] Reference updated

      ## Verification Checklist
      - [x] Build passes
      - [x] TypeCheck passes
      - [x] Lint passes
      - [x] All tests pass
      - [x] Gherkin scenarios: 100%
      - [x] Documentation updated
      - [x] No regressions

      ---
      Full details in `artifacts/sprint-summary.md`

      🧪 TDD Sprint with Documentation
      EOF
      )"
      ```

      ## Step 4: Output PR URL
      ```bash
      gh pr view --json url -q '.url'
      ```

      ## Step 5: Worktree Cleanup Instructions
      After the PR is merged, clean up the worktree:

      ```bash
      # From the main repository (not the worktree)
      cd ..  # Go to main repo root

      # Remove the worktree
      git worktree remove trees/2026-01-20_dashboard-improvements

      # Delete the remote branch (optional, after PR merge)
      git push origin --delete sprint/2026-01-20_dashboard-improvements

      # List remaining worktrees
      git worktree list
      ```

      Note: Do NOT remove the worktree until the PR is merged!
current:
  phase: 2
  step: 6
  sub-phase: 6
stats:
  started-at: '2026-01-20T21:37:04.190Z'
  total-phases: 75
  completed-phases: 0
  total-steps: 9
  completed-steps: 0
  current-iteration: 51
parallel-tasks: []
