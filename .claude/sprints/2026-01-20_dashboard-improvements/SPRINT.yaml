# SPRINT.yaml - Dashboard Improvements for m42-sprint Plugin
# Workflow-based sprint definition with worktree isolation

workflow: plugin-development

steps:
  # Phase 1: Live Activity Chat-Like UI (P0)
  - prompt: |
      Implement chat-like Live Activity UI showing assistant messages alongside tool calls.

      Requirements:
      1. Extend ActivityEvent type in activity-types.ts:
         - Add 'assistant' event type
         - Add text, isThinking fields

      2. Modify TranscriptionWatcher in transcription-watcher.ts:
         - Parse content_block_start with type "text"
         - Parse content_block_delta with text_delta
         - Accumulate text deltas with 500ms debouncing
         - Emit ActivityEvent with type='assistant'

      3. Update page.ts renderLiveActivity():
         - Assistant messages: chat bubble style, full content
         - Tool calls: grey/secondary style with better descriptions
         - TodoWrite â†’ "Updated task list"
         - Edit â†’ "Editing {filename}"
         - Read â†’ "Reading {filename}"

      4. Add CSS styling for chat-like appearance

      Files:
      - plugins/m42-sprint/compiler/src/status-server/activity-types.ts
      - plugins/m42-sprint/compiler/src/status-server/transcription-watcher.ts
      - plugins/m42-sprint/compiler/src/status-server/page.ts

      Verification: Start a sprint and verify assistant messages appear in chat style

  # Phase 2: Elapsed Time & Progress Display (P2/P3/P4)
  - prompt: |
      Add elapsed time display and prominent progress indicators.

      Requirements:
      1. Calculate elapsed in transforms.ts:
         - In buildSubPhaseNode(), buildStepNode(), buildTopPhaseNode()
         - If elapsed not set but started-at exists â†’ calculate using calculateElapsed()

      2. Add prominent timer in page.ts:
         - Add sprint-timer div in header with â± icon
         - Format as HH:MM:SS
         - Update every second
         - Large font, blue accent color

      3. Add step progress counter:
         - Count total steps from phases in transforms.ts
         - Add totalSteps to SprintHeader
         - Display "Step X of Y" in header

      Files:
      - plugins/m42-sprint/compiler/src/status-server/transforms.ts
      - plugins/m42-sprint/compiler/src/status-server/page.ts
      - plugins/m42-sprint/compiler/src/status-server/status-types.ts

      Verification:
      - Steps show elapsed time in sidebar
      - Prominent HH:MM:SS timer in header
      - "Step X of Y" displays

  # Phase 3: Sprint Dropdown & Stale Detection (P1)
  - prompt: |
      Fix sprint dropdown switching and add stale sprint detection.

      Requirements:
      1. Fix dropdown in page.ts:
         - Close existing SSE connection on change
         - Navigate to /sprint/{id} with full page reload
         - Add loading indicator

      2. Add heartbeat in loop.ts:
         - Write last-activity timestamp each iteration
         - Add process.on('SIGTERM') handler
         - Add process.on('SIGINT') handler
         - Mark sprint as 'interrupted' before exit

      3. Detect staleness in transforms.ts:
         - If in-progress but last-activity > 15 min â†’ stale
         - Add isStale flag to status

      4. Show stale indicator in page.ts:
         - Display "Stale" badge next to status
         - Show "Resume Sprint" button

      5. Add resume endpoint in server.ts:
         - Add /api/sprint/:id/resume endpoint
         - Trigger sprint loop restart

      Files:
      - plugins/m42-sprint/compiler/src/status-server/page.ts
      - plugins/m42-sprint/compiler/src/status-server/server.ts
      - plugins/m42-sprint/compiler/src/status-server/transforms.ts
      - plugins/m42-sprint/runtime/src/loop.ts
      - plugins/m42-sprint/runtime/src/cli.ts

      Verification:
      - Switch sprints via dropdown, verify correct data loads
      - Kill sprint process, wait 15 min, verify "Stale" badge + "Resume" button

  # Phase 4: Workflow Reference for Single Phases
  - prompt: |
      Enable referencing another workflow for a single phase (not just for-each).

      ## Overview
      Currently, `workflow:` can only be used with `for-each:` iterations:
      ```yaml
      phases:
        - id: development
          for-each: step
          workflow: tdd-step-workflow  # Works - iterates steps through workflow
      ```

      We want to also support workflow references WITHOUT for-each:
      ```yaml
      phases:
        - id: documentation
          workflow: documentation-workflow  # NEW - run entire workflow as single phase
        - id: qa
          prompt: |
            Run QA checks...  # Regular inline phase
      ```

      This makes workflows composable and reusable.

      ## Use Cases

      1. **Reusable documentation workflow**:
         ```yaml
         # plugin-development.yaml
         phases:
           - id: development
             for-each: step
             workflow: tdd-step-workflow
           - id: documentation
             workflow: documentation-workflow  # Reuse in multiple parent workflows
           - id: qa
             prompt: |
               ...
         ```

      2. **Nested workflow composition**:
         ```yaml
         # full-release.yaml
         phases:
           - id: develop
             workflow: plugin-development  # Run entire dev workflow
           - id: release
             workflow: release-workflow    # Then run release workflow
         ```

      ## Requirements

      ### 1. Schema Changes

      Phase can have EITHER `prompt` OR `workflow` (mutually exclusive):
      ```typescript
      interface Phase {
        id: string;
        // Option A: Inline prompt
        prompt?: string;
        // Option B: Reference workflow (with optional for-each)
        workflow?: string;
        'for-each'?: 'step' | 'phase';
        // Common fields
        model?: string;
      }
      ```

      Validation:
      - If `workflow` specified without `for-each`: run entire workflow as single phase
      - If `workflow` specified with `for-each`: iterate items through workflow (existing behavior)
      - If `prompt` specified: inline phase (existing behavior)
      - Error if both `prompt` and `workflow` specified

      ### 2. Compiler Changes

      Update `plugins/m42-sprint/compiler/src/compile.ts`:

      1. Detect phases with `workflow:` but no `for-each:`
      2. Load the referenced workflow
      3. Expand its phases inline into PROGRESS.yaml
      4. Prefix phase IDs to avoid collisions: `{parent-phase-id}-{child-phase-id}`

      Example expansion:
      ```yaml
      # Input (SPRINT.yaml with workflow reference)
      phases:
        - id: docs
          workflow: documentation-workflow

      # Output (PROGRESS.yaml after compilation)
      phases:
        - id: docs-analyze
          prompt: "..." (from documentation-workflow)
        - id: docs-user-guide
          prompt: "..."
        - id: docs-reference
          prompt: "..."
      ```

      ### 3. Context Passing

      When expanding a referenced workflow:
      - Pass parent sprint context (sprint.id, sprint variables)
      - Pass parent phase context (phase.id becomes prefix)
      - Inherited model resolution still applies

      ### 4. Recursive Reference Detection

      Prevent infinite loops:
      - Track workflow stack during compilation
      - Error if workflow references itself (directly or indirectly)
      - Max depth limit (e.g., 5 levels)

      ## Files to Modify

      **Compiler:**
      - plugins/m42-sprint/compiler/src/compile.ts - expand workflow references
      - plugins/m42-sprint/compiler/src/types.ts - update Phase type
      - plugins/m42-sprint/compiler/src/workflow-loader.ts - recursive loading

      ## Verification

      1. Create a test workflow that references documentation-workflow:
         ```yaml
         workflow: test-workflow
         phases:
           - id: setup
             prompt: "Setup task"
           - id: docs
             workflow: documentation-workflow
           - id: cleanup
             prompt: "Cleanup task"
         ```

      2. Compile and verify PROGRESS.yaml contains:
         - setup phase
         - docs-analyze, docs-user-guide, docs-reference (expanded)
         - cleanup phase

      3. Run the sprint and verify all phases execute in order

  # Phase 5: Model Selection per Level
  - prompt: |
      Implement configurable model selection with cascading override.

      ## Overview
      Allow setting the Claude model (sonnet, opus, haiku) at different levels:
      - workflow (default for all phases)
      - sprint (overrides workflow)
      - phase (overrides sprint)
      - step (overrides phase) - highest priority

      Override priority: step > phase > sprint > workflow

      ## Requirements

      ### 1. Schema Updates

      **SPRINT.yaml schema** - add optional `model` field:
      ```yaml
      workflow: plugin-development
      model: sonnet  # Sprint-level default (optional)

      steps:
        - prompt: |
            Complex task requiring more reasoning...
          model: opus  # Step-level override (optional)
        - prompt: |
            Simple task...
          # No model specified - inherits from sprint/workflow
      ```

      **Workflow YAML schema** - add optional `model` field:
      ```yaml
      name: My Workflow
      model: sonnet  # Workflow-level default (optional)

      phases:
        - id: planning
          model: opus  # Phase-level override (optional)
          prompt: |
            ...
        - id: implement
          # No model - inherits from workflow
          prompt: |
            ...
      ```

      ### 2. Compiler Changes (plugins/m42-sprint/compiler/)

      Update the compiler to:
      1. Parse `model` field from SPRINT.yaml at sprint level
      2. Parse `model` field from each step
      3. Parse `model` field from workflow YAML at workflow level
      4. Parse `model` field from each phase
      5. Store resolved model in PROGRESS.yaml for each phase

      **Resolution logic**:
      ```typescript
      function resolveModel(step, phase, sprint, workflow): string | undefined {
        return step.model ?? phase.model ?? sprint.model ?? workflow.model;
      }
      ```

      ### 3. Runtime Changes (plugins/m42-sprint/runtime/)

      Update the runtime loop to:
      1. Read the `model` field from current phase in PROGRESS.yaml
      2. Pass model to claude-runner when invoking Claude CLI
      3. Use `--model` flag in Claude CLI invocation

      **claude-runner.ts changes**:
      ```typescript
      interface ClaudeRunnerOptions {
        // ... existing options
        model?: 'sonnet' | 'opus' | 'haiku';
      }

      // In runClaude():
      const args = [
        '--print', 'text',
        // ... other args
      ];
      if (options.model) {
        args.push('--model', options.model);
      }
      ```

      ### 4. Dashboard Display (optional enhancement)

      Show current model in the sprint detail page:
      - Display model name next to phase in sidebar
      - Different icon/color for each model tier

      ## Files to Modify

      **Compiler:**
      - plugins/m42-sprint/compiler/src/compile.ts - parse model fields
      - plugins/m42-sprint/compiler/src/types.ts - add model to types
      - plugins/m42-sprint/compiler/src/workflow-loader.ts - parse workflow model

      **Runtime:**
      - plugins/m42-sprint/runtime/src/loop.ts - pass model to runner
      - plugins/m42-sprint/runtime/src/claude-runner.ts - add --model flag
      - plugins/m42-sprint/runtime/src/types.ts - add model to phase type

      **Dashboard (optional):**
      - plugins/m42-sprint/compiler/src/status-server/page.ts - display model
      - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include model

      ## Verification

      1. Create test sprint with mixed models:
         ```yaml
         model: sonnet
         steps:
           - prompt: "Task 1"           # Uses sonnet (sprint default)
           - prompt: "Task 2"
             model: opus                # Uses opus (step override)
         ```

      2. Run the sprint and verify:
         - Task 1 runs with sonnet
         - Task 2 runs with opus

      3. Check PROGRESS.yaml contains resolved model for each phase

  # Phase 6: Operator Request System
  - prompt: |
      Implement operator request system for discovered issues.

      ## Overview
      Claude can submit requests to the operator when it discovers issues during execution.
      All requests go to the operator queue - no auto-handling modes. The operator (a
      dedicated Claude instance) reviews requests, makes decisions with reasoning, and
      uses dynamic step injection to add work to the sprint.

      ## Phase Result JSON Schema (Agent Response)

      ```typescript
      interface PhaseResult {
        // Existing fields
        status: 'completed' | 'failed' | 'blocked';
        summary: string;
        artifacts?: string[];

        // NEW: Requests for operator review
        operatorRequests?: OperatorRequest[];
      }

      interface OperatorRequest {
        id: string;                    // Unique identifier (nanoid)
        title: string;                 // Short description
        description: string;           // Full description of what needs to be done
        priority: 'critical' | 'high' | 'medium' | 'low';
        type: 'bug' | 'improvement' | 'refactor' | 'test' | 'docs' | 'security';

        // Context for operator decision
        context?: {
          discoveredIn: string;        // Phase ID where discovered
          relatedFiles?: string[];
          codeSnippet?: string;        // Relevant code excerpt
          suggestedWorkflow?: string;  // Agent's suggestion (operator can override)
        };
      }
      ```

      ## Operator Response JSON Schema

      The operator responds with decisions AND reasoning:

      ```typescript
      interface OperatorDecision {
        requestId: string;             // Which request this decides
        decision: 'approve' | 'reject' | 'defer' | 'backlog';

        // Required: Explain the reasoning
        reasoning: string;             // Why this decision was made

        // If approved: injection details
        injection?: {
          workflow?: string;           // Workflow to compile (optional)
          prompt?: string;             // Direct prompt if no workflow
          position: InsertPosition;    // Where to inject
          model?: string;              // Model override
          idPrefix: string;            // Prefix for generated IDs
        };

        // If deferred: when to revisit
        deferredUntil?: 'end-of-phase' | 'end-of-sprint' | 'next-sprint';

        // If backlog: for human review (NOT auto-implemented)
        backlogEntry?: {
          category: string;            // e.g., 'tech-debt', 'feature', 'investigation'
          suggestedPriority: 'high' | 'medium' | 'low';
          notes: string;               // Additional context for human
        };

        // If rejected: why
        rejectionReason?: string;
      }

      interface OperatorResponse {
        decisions: OperatorDecision[];
        operatorLog: string;           // Summary of operator's analysis
        timestamp: string;
      }
      ```

      ## Decision Types

      | Decision | Behavior |
      |----------|----------|
      | `approve` | Inject step/workflow into sprint immediately |
      | `reject` | Decline with reason, no action taken |
      | `defer` | Queue for later in sprint (end-of-phase, end-of-sprint) |
      | `backlog` | **NEW**: Add to backlog for human review, NOT auto-implemented |

      The `backlog` decision is for items that:
      - Are valid but out of scope for current sprint
      - Need human judgment before implementation
      - Should be tracked but not automatically acted upon
      - May require discussion or prioritization

      ## Backlog Storage

      Backlog items stored in `BACKLOG.yaml` in sprint directory:

      ```yaml
      # .claude/sprints/<sprint-id>/BACKLOG.yaml
      items:
        - id: req_abc123
          title: "Refactor authentication to use OAuth2"
          description: "Current auth is basic, should upgrade..."
          category: tech-debt
          suggested-priority: medium
          operator-notes: "Valid improvement but significant scope. Needs arch review."
          source:
            request-id: req_abc123
            discovered-in: development-step-3
            discovered-at: 2026-01-20T10:00:00Z
          created-at: 2026-01-20T10:05:00Z
          status: pending-review  # pending-review | acknowledged | converted-to-issue
      ```

      ## Operator as Skill/Command

      The default operator is implemented as a **skill** that can be:
      - Used as-is with default prompt
      - Overridden at workflow or sprint level
      - Extended with custom logic

      ### Default Operator Skill

      Create: `.claude/skills/sprint-operator/skill.md`

      ```markdown
      # Sprint Operator

      You are the sprint operator responsible for reviewing discovered issues
      and deciding how to handle them.

      ## Your Responsibilities

      1. **Triage**: Assess each request's urgency and relevance
      2. **Decide**: Choose appropriate action (approve/reject/defer/backlog)
      3. **Reason**: Always explain your decision clearly
      4. **Place**: If approving, determine optimal injection point

      ## Decision Guidelines

      ### Approve when:
      - Issue blocks current sprint progress
      - Fix is small and well-defined
      - Directly related to sprint goals

      ### Reject when:
      - Request is invalid or duplicate
      - Already addressed elsewhere
      - Not actually an issue

      ### Defer when:
      - Valid but not urgent
      - Can wait until later in sprint
      - Dependencies not yet ready

      ### Backlog when:
      - Valid but out of scope for sprint
      - Needs human review/discussion
      - Significant scope or architectural impact
      - "Nice to have" improvements

      ## Context Available

      - Sprint goals and progress
      - Current phase and remaining work
      - Request details and context
      - Related files and code snippets
      ```

      ### Override in Workflow/Sprint

      ```yaml
      # workflow.yaml or SPRINT.yaml
      operator:
        enabled: true                  # Default: true
        model: sonnet                  # Model for operator (default: sonnet)
        skill: sprint-operator         # Default skill (can override)
        # OR provide custom prompt:
        prompt: |                      # Overrides skill if provided
          Custom operator instructions...
      ```

      ## Request Lifecycle

      ```
      Agent discovers issue â†’ Creates OperatorRequest â†’ Added to queue (status: pending)
                                                              â†“
      Operator reviews (batch or immediate) â†’ Makes decision with reasoning
                                                              â†“
                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â†“                                 â†“                                 â†“
                         [approve]                          [reject]                          [defer]
                              â†“                                 â†“                                 â†“
                    Inject step/workflow              Log rejection reason             Queue for later
                              â†“                                 â†“                                 â†“
                     status: approved                  status: rejected                 status: deferred
      ```

      ## Requirements

      ### 1. Update Claude Runner

      Modify `claude-runner.ts` to:
      - Use `--output-format json` with schema including `operatorRequests`
      - Parse requests from response
      - Return them to the loop

      ### 2. Request Queue Storage

      Store requests in `PROGRESS.yaml` or separate file:
      ```yaml
      operator-queue:
        - id: req_abc123
          title: "Fix memory leak in parser"
          status: pending
          created-at: 2026-01-20T10:00:00Z
          discovered-in: development-step-2
          # ... rest of request

        - id: req_def456
          title: "Add input validation"
          status: approved
          decided-at: 2026-01-20T10:05:00Z
          decision:
            reasoning: "Security issue, should be addressed before QA"
            injection:
              position: { type: after-current }
              workflow: bugfix-workflow
          # ... rest
      ```

      ### 3. Operator Handler

      Create `operator.ts`:
      - Batch process pending requests (or immediate for critical)
      - Run operator prompt with context
      - Parse decisions and reasoning
      - Execute injections for approved requests
      - Update queue status

      ### 4. Operator Trigger Points

      When does operator run?
      - After each phase completes (if pending requests exist)
      - Immediately for `critical` priority requests
      - Can be triggered manually from dashboard

      ## Files to Modify

      **Runtime:**
      - plugins/m42-sprint/runtime/src/claude-runner.ts - parse operatorRequests
      - plugins/m42-sprint/runtime/src/loop.ts - queue requests, trigger operator
      - plugins/m42-sprint/runtime/src/operator.ts - NEW: operator logic with skill loading
      - plugins/m42-sprint/runtime/src/backlog.ts - NEW: backlog management
      - plugins/m42-sprint/runtime/src/types.ts - request/decision types

      **Compiler:**
      - plugins/m42-sprint/compiler/src/types.ts - operator config in workflow schema

      **Skill:**
      - plugins/m42-sprint/skills/sprint-operator/skill.md - NEW: default operator skill

      ## Verification

      1. Create phase that submits operator request:
         ```yaml
         - prompt: |
             Review the code. If you find issues, add them to operatorRequests.
         ```

      2. Verify request appears in queue with status: pending
      3. Verify operator runs using default skill and makes decision with reasoning
      4. Verify approved requests get injected correctly
      5. Verify rejected/deferred requests logged properly
      6. Verify backlog items written to BACKLOG.yaml for human review
      7. Verify custom operator prompt overrides default skill

  # Phase 7: Dynamic Step Injection
  - prompt: |
      Implement dynamic step injection into running sprints.

      ## Overview
      Allow adding steps to PROGRESS.yaml at runtime:
      - Add single steps to a specific position
      - Compile a workflow to add multiple steps
      - Choose insertion point (after current, end of phase, specific position)

      This is required for the operator and suggested-steps features.

      ## API Design

      ### Single Step Injection

      ```typescript
      interface StepInjection {
        step: {
          id: string;
          prompt: string;
          model?: string;
        };
        position: InsertPosition;
      }

      type InsertPosition =
        | { type: 'after-current' }                    // After currently executing step
        | { type: 'after-step'; stepId: string }      // After specific step
        | { type: 'end-of-phase'; phaseId: string }   // At end of specific phase
        | { type: 'end-of-workflow' }                 // At very end
        | { type: 'before-step'; stepId: string };    // Before specific step
      ```

      ### Workflow-Based Injection

      ```typescript
      interface WorkflowInjection {
        workflow: string;           // Workflow name to compile
        context?: {                 // Context for the workflow
          step?: StepDefinition;    // If workflow uses for-each: step
          variables?: Record<string, any>;
        };
        position: InsertPosition;
        idPrefix: string;           // Prefix for generated phase IDs
      }
      ```

      ## Implementation

      ### 1. Progress File Manipulation

      Create `progress-injector.ts`:

      ```typescript
      export class ProgressInjector {
        constructor(private progressPath: string) {}

        // Inject single step
        async injectStep(injection: StepInjection): Promise<void> {
          const progress = await this.loadProgress();
          const insertIndex = this.resolvePosition(progress, injection.position);

          // Create phase entry
          const phase = {
            id: injection.step.id,
            prompt: injection.step.prompt,
            status: 'pending',
            model: injection.step.model,
            injected: true,  // Mark as dynamically injected
            'injected-at': new Date().toISOString(),
          };

          // Insert at position
          progress.phases.splice(insertIndex, 0, phase);

          // Recalculate stats
          this.updateStats(progress);

          await this.saveProgress(progress);
        }

        // Inject compiled workflow
        async injectWorkflow(injection: WorkflowInjection): Promise<void> {
          // Load and compile workflow
          const compiledPhases = await compileWorkflow(
            injection.workflow,
            injection.context
          );

          // Prefix IDs
          const prefixedPhases = compiledPhases.map(phase => ({
            ...phase,
            id: `${injection.idPrefix}-${phase.id}`,
            injected: true,
            'injected-at': new Date().toISOString(),
          }));

          // Insert all phases at position
          const progress = await this.loadProgress();
          const insertIndex = this.resolvePosition(progress, injection.position);
          progress.phases.splice(insertIndex, 0, ...prefixedPhases);

          this.updateStats(progress);
          await this.saveProgress(progress);
        }

        private resolvePosition(progress: Progress, pos: InsertPosition): number {
          switch (pos.type) {
            case 'after-current':
              return this.findCurrentIndex(progress) + 1;
            case 'after-step':
              return this.findStepIndex(progress, pos.stepId) + 1;
            case 'before-step':
              return this.findStepIndex(progress, pos.stepId);
            case 'end-of-phase':
              return this.findPhaseEndIndex(progress, pos.phaseId);
            case 'end-of-workflow':
              return progress.phases.length;
          }
        }
      }
      ```

      ### 2. Integration with Loop

      Modify `loop.ts` to:
      - Detect injected steps (phases with `injected: true`)
      - Handle them like regular phases
      - Log injection events to activity

      ### 3. Dashboard Display

      Show injected steps distinctly:
      - Different icon/badge for injected steps
      - Show injection timestamp
      - Indicate source (operator, suggested-step, manual)

      ### 4. CLI Command (Optional)

      Add command for manual injection:
      ```bash
      m42-sprint inject-step <sprint-path> \
        --prompt "Fix the bug in auth.ts" \
        --position after-current \
        --workflow bugfix-workflow
      ```

      ## Files to Modify

      **Runtime:**
      - plugins/m42-sprint/runtime/src/progress-injector.ts - NEW: injection logic
      - plugins/m42-sprint/runtime/src/loop.ts - integrate injector
      - plugins/m42-sprint/runtime/src/cli.ts - add inject-step command

      **Compiler:**
      - plugins/m42-sprint/compiler/src/compile.ts - export compile function for runtime use

      **Dashboard:**
      - plugins/m42-sprint/compiler/src/status-server/page.ts - show injected badge
      - plugins/m42-sprint/compiler/src/status-server/transforms.ts - include injection info

      ## Verification

      1. Inject a step manually via API:
         ```typescript
         const injector = new ProgressInjector(progressPath);
         await injector.injectStep({
           step: { id: 'hotfix-1', prompt: 'Fix critical bug' },
           position: { type: 'after-current' }
         });
         ```

      2. Verify PROGRESS.yaml updated correctly
      3. Verify loop executes injected step
      4. Verify dashboard shows injected badge

      5. Test workflow injection:
         ```typescript
         await injector.injectWorkflow({
           workflow: 'bugfix-workflow',
           context: { variables: { issue: 'Auth token expiry' } },
           position: { type: 'end-of-phase', phaseId: 'development' },
           idPrefix: 'hotfix'
         });
         ```

  # Phase 8: Operator Queue View UI
  - prompt: |
      Design and implement the Operator Queue View in the dashboard.

      ## IMPORTANT: UX/UI Planning First

      Before implementing, use a subagent (Explore/Plan) to:
      1. Research existing dashboard patterns and components
      2. Design the UX flow for operator interactions
      3. Create wireframes/mockups (can be ASCII or markdown)
      4. Get alignment on the design before coding

      ## Overview

      A dedicated view per sprint showing:
      - **Pending requests**: Waiting for operator decision
      - **Decided requests**: Approved, rejected, or deferred with reasoning

      This is THE central place to see what the operator is doing and why.

      ## UX Requirements

      ### Navigation
      - Accessible from sprint detail page (tab or sidebar link)
      - Badge showing pending count: "Operator (3)"
      - Quick access from notification when new request arrives

      ### Pending Requests Section

      ```
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ ğŸ”” Pending Requests (3)                          [Process All] â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
      â”‚ â”‚ ğŸ”´ CRITICAL  Fix SQL injection in user input               â”‚ â”‚
      â”‚ â”‚ Discovered in: development-step-2 â€¢ 2 min ago              â”‚ â”‚
      â”‚ â”‚ Files: src/api/users.ts                                    â”‚ â”‚
      â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
      â”‚ â”‚ â”‚ User input is passed directly to query without...       â”‚ â”‚ â”‚
      â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
      â”‚ â”‚ Suggested: bugfix-workflow                                  â”‚ â”‚
      â”‚ â”‚                                    [Approve] [Reject] [Defer]â”‚ â”‚
      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
      â”‚                                                                 â”‚
      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
      â”‚ â”‚ ğŸŸ¡ HIGH  Add rate limiting to API endpoints                 â”‚ â”‚
      â”‚ â”‚ Discovered in: development-step-3 â€¢ 5 min ago              â”‚ â”‚
      â”‚ â”‚ ...                                                         â”‚ â”‚
      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      ```

      ### Decided Requests Section (History)

      ```
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ ğŸ“‹ Decision History                    [Filter: All â–¼] [Search]â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
      â”‚ â”‚ âœ… APPROVED  Fix null pointer in config parser             â”‚ â”‚
      â”‚ â”‚ Decided: 10 min ago â€¢ Injected after: development-step-2   â”‚ â”‚
      â”‚ â”‚ â”Œâ”€ Operator Reasoning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
      â”‚ â”‚ â”‚ This is a blocking bug that will cause test failures.   â”‚ â”‚ â”‚
      â”‚ â”‚ â”‚ Injecting immediately to unblock QA phase. Using        â”‚ â”‚ â”‚
      â”‚ â”‚ â”‚ bugfix-workflow for proper test coverage.               â”‚ â”‚ â”‚
      â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
      â”‚                                                                 â”‚
      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
      â”‚ â”‚ âŒ REJECTED  Refactor utils to use lodash                  â”‚ â”‚
      â”‚ â”‚ Decided: 15 min ago                                        â”‚ â”‚
      â”‚ â”‚ â”Œâ”€ Operator Reasoning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
      â”‚ â”‚ â”‚ Invalid request - lodash adds unnecessary dependency.   â”‚ â”‚ â”‚
      â”‚ â”‚ â”‚ Current implementation is sufficient.                   â”‚ â”‚ â”‚
      â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
      â”‚                                                                 â”‚
      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
      â”‚ â”‚ â¸ï¸ DEFERRED  Add comprehensive logging                      â”‚ â”‚
      â”‚ â”‚ Decided: 20 min ago â€¢ Deferred until: end-of-sprint        â”‚ â”‚
      â”‚ â”‚ â”Œâ”€ Operator Reasoning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
      â”‚ â”‚ â”‚ Good idea but not urgent. Will revisit after core       â”‚ â”‚ â”‚
      â”‚ â”‚ â”‚ features are complete.                                  â”‚ â”‚ â”‚
      â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      ```

      ### Backlog Section (For Human Review)

      Items sent to backlog are NOT auto-implemented. They're tracked for human review.

      ```
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â”‚ ğŸ“ Backlog (For Human Review)                    [Export CSV]  â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ Items in backlog will NOT be auto-implemented. Review and      â”‚
      â”‚ convert to GitHub issues or add to future sprints manually.    â”‚
      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
      â”‚ â”‚ ğŸ“Œ BACKLOG  Upgrade to OAuth2 authentication               â”‚ â”‚
      â”‚ â”‚ Category: tech-debt â€¢ Suggested Priority: medium           â”‚ â”‚
      â”‚ â”‚ Added: 25 min ago                                          â”‚ â”‚
      â”‚ â”‚ â”Œâ”€ Operator Notes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
      â”‚ â”‚ â”‚ Valid improvement but significant scope. Current basic  â”‚ â”‚ â”‚
      â”‚ â”‚ â”‚ auth works for MVP. Recommend architectural review      â”‚ â”‚ â”‚
      â”‚ â”‚ â”‚ before implementing. Could be a dedicated sprint.       â”‚ â”‚ â”‚
      â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
      â”‚ â”‚ Status: pending-review    [Create Issue] [Acknowledge] [Delete]â”‚
      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
      â”‚                                                                 â”‚
      â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
      â”‚ â”‚ ğŸ“Œ BACKLOG  Add API versioning                             â”‚ â”‚
      â”‚ â”‚ Category: feature â€¢ Suggested Priority: low                â”‚ â”‚
      â”‚ â”‚ Added: 30 min ago                                          â”‚ â”‚
      â”‚ â”‚ â”Œâ”€ Operator Notes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
      â”‚ â”‚ â”‚ Good practice but not needed yet - no external API      â”‚ â”‚ â”‚
      â”‚ â”‚ â”‚ consumers. Track for when we open API publicly.         â”‚ â”‚ â”‚
      â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
      â”‚ â”‚ Status: acknowledged      [Create Issue] [Delete]           â”‚ â”‚
      â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      ```

      ### Backlog Actions

      - **Create Issue**: Convert to GitHub issue (uses gh CLI)
      - **Acknowledge**: Mark as reviewed by human
      - **Delete**: Remove from backlog
      - **Export CSV**: Export all backlog items for external tracking

      ### Manual Actions (Human Override)

      Allow human to:
      - Manually approve/reject pending requests (bypassing operator)
      - Re-process a rejected request
      - Change deferred timing
      - Add notes to decisions

      ## Technical Requirements

      ### 1. Data Source

      Read from operator queue in PROGRESS.yaml or dedicated file:
      ```yaml
      operator-queue:
        - id: req_abc123
          status: pending | approved | rejected | deferred
          ...
      ```

      ### 2. Real-time Updates

      - SSE events for queue changes
      - New event types: `operator-request`, `operator-decision`
      - Update UI without page refresh

      ### 3. API Endpoints

      ```
      GET  /api/sprint/:id/operator-queue         # List all requests
      GET  /api/sprint/:id/operator-queue/pending # Pending only
      POST /api/sprint/:id/operator-queue/:reqId/decide  # Manual decision
      POST /api/sprint/:id/operator/process       # Trigger operator run
      ```

      ### 4. Components

      Create modular components:
      - `OperatorRequestCard` - Single request display
      - `OperatorReasoningBlock` - Collapsible reasoning
      - `OperatorQueueList` - List with filtering
      - `OperatorStats` - Summary stats (pending, approved, rejected)

      ## Files to Modify

      **Status Server:**
      - plugins/m42-sprint/compiler/src/status-server/page.ts - Add queue view
      - plugins/m42-sprint/compiler/src/status-server/server.ts - Add API endpoints
      - plugins/m42-sprint/compiler/src/status-server/transforms.ts - Transform queue data

      **New Files:**
      - plugins/m42-sprint/compiler/src/status-server/operator-queue-page.ts - Dedicated page

      ## Implementation Approach

      1. **Phase A: Research & Design** (use Explore subagent)
         - Study existing dashboard code structure
         - Identify reusable components and patterns
         - Create detailed wireframes
         - Document component hierarchy

      2. **Phase B: Backend**
         - Add queue storage to PROGRESS.yaml schema
         - Implement API endpoints
         - Add SSE event types

      3. **Phase C: Frontend**
         - Implement components
         - Add to navigation
         - Wire up real-time updates

      4. **Phase D: Polish**
         - Animations for new requests
         - Empty states
         - Error handling
         - Mobile responsiveness

      ## Verification

      1. Navigate to operator queue view
      2. See pending requests with full details
      3. See decision history with reasoning
      4. Manually approve a request, verify injection
      5. Verify real-time updates when new requests arrive

  # Final verification step
  - prompt: |
      Run complete end-to-end verification of all dashboard improvements.

      Test all features:
      1. Live Activity: Start sprint, verify chat-style display with assistant messages
      2. Elapsed time: Verify steps show timing in sidebar
      3. Sprint timer: Verify prominent HH:MM:SS display in header
      4. Step count: Verify "Step X of Y" indicator
      5. Sprint switching: Use dropdown to switch sprints
      6. Stale detection: Kill a sprint and verify stale indicator
      7. Model selection: Verify model override works at step/phase/sprint/workflow levels
      8. Workflow reference: Verify single-phase workflow references expand correctly
      9. Operator requests: Verify agents can submit requests, operator processes them
      10. Dynamic injection: Verify steps can be injected at various positions
      11. Operator queue view: Verify pending/decided requests display with reasoning

      Build and test:
      - Run npm run build in plugins/m42-sprint/compiler
      - Run npm run build in plugins/m42-sprint/runtime
      - Reinstall plugin and verify all features work

# Sprint metadata
sprint-id: 2026-01-20_dashboard-improvements
name: dashboard-improvements
created: 2026-01-20T19:52:00Z
