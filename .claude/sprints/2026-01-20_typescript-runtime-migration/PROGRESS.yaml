sprint-id: 2026-01-20_typescript-runtime-migration
status: completed
phases:
  - id: preflight
    status: completed
    prompt: >
      Create comprehensive sprint context for TDD-based plugin development.


      ## Your Task

      Analyze the sprint scope and prepare shared context for all development phases.


      ## Step 1: Create Sprint Branch

      ```bash

      git checkout -b sprint/2026-01-20_typescript-runtime-migration 2>/dev/null || git checkout sprint/2026-01-20_typescript-runtime-migration

      ```


      ## Step 2: Analyze Sprint Scope

      Read SPRINT.yaml to understand:

      - All steps and their relationships

      - Overall sprint goal

      - Technical requirements

      - Dependencies between steps


      ## Step 3: Research Project Context

      Investigate the codebase to understand:

      - Project architecture and structure

      - Existing patterns and conventions

      - Test frameworks and patterns used

      - Build/test/lint commands

      - Documentation structure


      ## Step 4: Documentation Inventory

      Catalog existing documentation that may need updates:

      ```bash

      # Find all documentation files

      find . -name "*.md" -type f | grep -E "(README|docs/|GUIDE|REFERENCE)" | head -50

      ```


      Create a documentation map showing what exists and may need updates.


      ## Step 5: Generate Shared Context

      Create: context/_shared-context.md


      ```markdown

      # Shared Sprint Context


      ## Project Architecture

      [High-level architecture overview relevant to this sprint]


      ## Test Patterns

      - Test framework: [framework used]

      - Test file location: [where tests live]

      - Test naming: [naming conventions]

      - Mocking patterns: [how mocks are done]


      ## Key Patterns

      - [Pattern 1]: [Where and how it's used]

      - [Pattern 2]: [Where and how it's used]


      ## Commands

      - Build: `[build command]`

      - Test: `[test command]`

      - Test (watch): `[watch command if available]`

      - Lint: `[lint command]`

      - TypeCheck: `[typecheck command]`


      ## Documentation Structure

      - User Guide: [path or "does not exist"]

      - Getting Started: [path or "does not exist"]

      - Reference: [path or "does not exist"]

      - API Docs: [path or "does not exist"]


      ## Dependencies

      ### Internal Modules

      - [Module]: [Purpose]


      ### External Packages

      - [Package]: [Usage]

      ```


      ## Step 6: Generate Sprint Plan

      Create: context/sprint-plan.md


      ```markdown

      # Sprint Plan: 2026-01-20_typescript-runtime-migration


      ## Goal

      [One paragraph describing what this sprint accomplishes]


      ## TDD Approach

      Each step follows: RED → GREEN → REFACTOR → QA


      ## Success Criteria

      - [ ] All gherkin scenarios pass (100% score)

      - [ ] All unit tests pass

      - [ ] Build passes

      - [ ] Documentation updated


      ## Step Breakdown


      ### Step 0: [Step title]

      **Scope**: [What this step does]

      **Tests to Write**: [Key test cases]

      **Files**: [Expected files to create/modify]

      **Docs Impact**: [Documentation that may need updates]


      [Continue for all steps]


      ## Documentation Update Plan

      | Doc | Status | Updates Needed |

      |-----|--------|----------------|

      | User Guide | [exists/new] | [description] |

      | Getting Started | [exists/new] | [description] |

      | Reference | [exists/new] | [description] |

      ```


      ## Output

      - Sprint branch created

      - context/_shared-context.md with project patterns

      - context/sprint-plan.md with TDD plan

      - Commit preflight artifacts:








































































































































































































































































































































        ```bash
        git add context/
        git commit -m "preflight: add shared context and TDD sprint plan"
        ```
    started-at: "2026-01-19T22:53:42Z"
    completed-at: "2026-01-19T22:56:08Z"
    elapsed: 00:02:26
  - id: development
    status: completed
    steps:
      - id: type-system
        prompt: |
          GIVEN the current string-based status types in m42-sprint
          WHEN applying XState-inspired patterns for type safety
          THEN create discriminated unions and event types

          ## Scope
          Enhance plugins/m42-sprint/compiler/src/types.ts only.
          NO runtime changes - types only.

          ## Acceptance Criteria

          ### Discriminated Union: SprintState
          - [ ] `{ status: 'not-started' }`
          - [ ] `{ status: 'in-progress'; current: CurrentPointer; iteration: number; startedAt: string }`
          - [ ] `{ status: 'paused'; pausedAt: CurrentPointer; pauseReason: string }`
          - [ ] `{ status: 'blocked'; error: string; failedPhase: string; blockedAt: string }`
          - [ ] `{ status: 'needs-human'; reason: string; details?: string }`
          - [ ] `{ status: 'completed'; summary?: string; completedAt: string; elapsed: string }`

          ### Event Union: SprintEvent
          - [ ] START, TICK, MAX_ITERATIONS_REACHED
          - [ ] PHASE_COMPLETE { summary, phaseId }
          - [ ] PHASE_FAILED { error, category, phaseId }
          - [ ] STEP_COMPLETE { summary, stepId }
          - [ ] STEP_FAILED { error, category, stepId }
          - [ ] PROPOSE_STEPS { steps, proposedBy }
          - [ ] PAUSE { reason }, RESUME
          - [ ] HUMAN_NEEDED { reason, details? }
          - [ ] GOAL_COMPLETE { summary }

          ### Action Union: SprintAction
          - [ ] LOG { level, message }
          - [ ] SPAWN_CLAUDE { prompt, phaseId, onComplete }
          - [ ] WRITE_PROGRESS
          - [ ] UPDATE_STATS { updates }
          - [ ] EMIT_ACTIVITY { activity, data }
          - [ ] SCHEDULE_RETRY { phaseId, delayMs }
          - [ ] INSERT_STEP { step, position }

          ### TransitionResult Interface
          - [ ] { nextState: SprintState; actions: SprintAction[]; context: Partial<CompiledProgress> }

          ### Guard Functions
          - [ ] Create `guards` object with: hasMorePhases, hasMoreSteps, hasMoreSubPhases
          - [ ] isRetryable, hasStepQueue, orchestrationEnabled, autoApproveEnabled

          ### Backwards Compatibility
          - [ ] Add @deprecated JSDoc to old SprintStatus type
          - [ ] Keep old types working for now
          - [ ] npm run typecheck passes
          - [ ] npm run build passes

          ## Context
          Read: context/xstate-patterns-plan.md (Type System section)

          ## Files to Modify
          - plugins/m42-sprint/compiler/src/types.ts
        status: completed
        phases:
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              GIVEN the current string-based status types in m42-sprint
              WHEN applying XState-inspired patterns for type safety
              THEN create discriminated unions and event types

              ## Scope
              Enhance plugins/m42-sprint/compiler/src/types.ts only.
              NO runtime changes - types only.

              ## Acceptance Criteria

              ### Discriminated Union: SprintState
              - [ ] `{ status: 'not-started' }`
              - [ ] `{ status: 'in-progress'; current: CurrentPointer; iteration: number; startedAt: string }`
              - [ ] `{ status: 'paused'; pausedAt: CurrentPointer; pauseReason: string }`
              - [ ] `{ status: 'blocked'; error: string; failedPhase: string; blockedAt: string }`
              - [ ] `{ status: 'needs-human'; reason: string; details?: string }`
              - [ ] `{ status: 'completed'; summary?: string; completedAt: string; elapsed: string }`

              ### Event Union: SprintEvent
              - [ ] START, TICK, MAX_ITERATIONS_REACHED
              - [ ] PHASE_COMPLETE { summary, phaseId }
              - [ ] PHASE_FAILED { error, category, phaseId }
              - [ ] STEP_COMPLETE { summary, stepId }
              - [ ] STEP_FAILED { error, category, stepId }
              - [ ] PROPOSE_STEPS { steps, proposedBy }
              - [ ] PAUSE { reason }, RESUME
              - [ ] HUMAN_NEEDED { reason, details? }
              - [ ] GOAL_COMPLETE { summary }

              ### Action Union: SprintAction
              - [ ] LOG { level, message }
              - [ ] SPAWN_CLAUDE { prompt, phaseId, onComplete }
              - [ ] WRITE_PROGRESS
              - [ ] UPDATE_STATS { updates }
              - [ ] EMIT_ACTIVITY { activity, data }
              - [ ] SCHEDULE_RETRY { phaseId, delayMs }
              - [ ] INSERT_STEP { step, position }

              ### TransitionResult Interface
              - [ ] { nextState: SprintState; actions: SprintAction[]; context: Partial<CompiledProgress> }

              ### Guard Functions
              - [ ] Create `guards` object with: hasMorePhases, hasMoreSteps, hasMoreSubPhases
              - [ ] isRetryable, hasStepQueue, orchestrationEnabled, autoApproveEnabled

              ### Backwards Compatibility
              - [ ] Add @deprecated JSDoc to old SprintStatus type
              - [ ] Keep old types working for now
              - [ ] npm run typecheck passes
              - [ ] npm run build passes

              ## Context
              Read: context/xstate-patterns-plan.md (Type System section)

              ## Files to Modify
              - plugins/m42-sprint/compiler/src/types.ts


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/type-system-gherkin.md

              ```markdown
              # Gherkin Scenarios: type-system

              ## Step Task
              GIVEN the current string-based status types in m42-sprint
              WHEN applying XState-inspired patterns for type safety
              THEN create discriminated unions and event types

              ## Scope
              Enhance plugins/m42-sprint/compiler/src/types.ts only.
              NO runtime changes - types only.

              ## Acceptance Criteria

              ### Discriminated Union: SprintState
              - [ ] `{ status: 'not-started' }`
              - [ ] `{ status: 'in-progress'; current: CurrentPointer; iteration: number; startedAt: string }`
              - [ ] `{ status: 'paused'; pausedAt: CurrentPointer; pauseReason: string }`
              - [ ] `{ status: 'blocked'; error: string; failedPhase: string; blockedAt: string }`
              - [ ] `{ status: 'needs-human'; reason: string; details?: string }`
              - [ ] `{ status: 'completed'; summary?: string; completedAt: string; elapsed: string }`

              ### Event Union: SprintEvent
              - [ ] START, TICK, MAX_ITERATIONS_REACHED
              - [ ] PHASE_COMPLETE { summary, phaseId }
              - [ ] PHASE_FAILED { error, category, phaseId }
              - [ ] STEP_COMPLETE { summary, stepId }
              - [ ] STEP_FAILED { error, category, stepId }
              - [ ] PROPOSE_STEPS { steps, proposedBy }
              - [ ] PAUSE { reason }, RESUME
              - [ ] HUMAN_NEEDED { reason, details? }
              - [ ] GOAL_COMPLETE { summary }

              ### Action Union: SprintAction
              - [ ] LOG { level, message }
              - [ ] SPAWN_CLAUDE { prompt, phaseId, onComplete }
              - [ ] WRITE_PROGRESS
              - [ ] UPDATE_STATS { updates }
              - [ ] EMIT_ACTIVITY { activity, data }
              - [ ] SCHEDULE_RETRY { phaseId, delayMs }
              - [ ] INSERT_STEP { step, position }

              ### TransitionResult Interface
              - [ ] { nextState: SprintState; actions: SprintAction[]; context: Partial<CompiledProgress> }

              ### Guard Functions
              - [ ] Create `guards` object with: hasMorePhases, hasMoreSteps, hasMoreSubPhases
              - [ ] isRetryable, hasStepQueue, orchestrationEnabled, autoApproveEnabled

              ### Backwards Compatibility
              - [ ] Add @deprecated JSDoc to old SprintStatus type
              - [ ] Keep old types working for now
              - [ ] npm run typecheck passes
              - [ ] npm run build passes

              ## Context
              Read: context/xstate-patterns-plan.md (Type System section)

              ## Files to Modify
              - plugins/m42-sprint/compiler/src/types.ts


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/type-system-gherkin.md
              git commit -m "test(type-system): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: "2026-01-19T22:56:12Z"
            completed-at: "2026-01-19T22:59:45Z"
            elapsed: 00:03:33
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              GIVEN the current string-based status types in m42-sprint
              WHEN applying XState-inspired patterns for type safety
              THEN create discriminated unions and event types

              ## Scope
              Enhance plugins/m42-sprint/compiler/src/types.ts only.
              NO runtime changes - types only.

              ## Acceptance Criteria

              ### Discriminated Union: SprintState
              - [ ] `{ status: 'not-started' }`
              - [ ] `{ status: 'in-progress'; current: CurrentPointer; iteration: number; startedAt: string }`
              - [ ] `{ status: 'paused'; pausedAt: CurrentPointer; pauseReason: string }`
              - [ ] `{ status: 'blocked'; error: string; failedPhase: string; blockedAt: string }`
              - [ ] `{ status: 'needs-human'; reason: string; details?: string }`
              - [ ] `{ status: 'completed'; summary?: string; completedAt: string; elapsed: string }`

              ### Event Union: SprintEvent
              - [ ] START, TICK, MAX_ITERATIONS_REACHED
              - [ ] PHASE_COMPLETE { summary, phaseId }
              - [ ] PHASE_FAILED { error, category, phaseId }
              - [ ] STEP_COMPLETE { summary, stepId }
              - [ ] STEP_FAILED { error, category, stepId }
              - [ ] PROPOSE_STEPS { steps, proposedBy }
              - [ ] PAUSE { reason }, RESUME
              - [ ] HUMAN_NEEDED { reason, details? }
              - [ ] GOAL_COMPLETE { summary }

              ### Action Union: SprintAction
              - [ ] LOG { level, message }
              - [ ] SPAWN_CLAUDE { prompt, phaseId, onComplete }
              - [ ] WRITE_PROGRESS
              - [ ] UPDATE_STATS { updates }
              - [ ] EMIT_ACTIVITY { activity, data }
              - [ ] SCHEDULE_RETRY { phaseId, delayMs }
              - [ ] INSERT_STEP { step, position }

              ### TransitionResult Interface
              - [ ] { nextState: SprintState; actions: SprintAction[]; context: Partial<CompiledProgress> }

              ### Guard Functions
              - [ ] Create `guards` object with: hasMorePhases, hasMoreSteps, hasMoreSubPhases
              - [ ] isRetryable, hasStepQueue, orchestrationEnabled, autoApproveEnabled

              ### Backwards Compatibility
              - [ ] Add @deprecated JSDoc to old SprintStatus type
              - [ ] Keep old types working for now
              - [ ] npm run typecheck passes
              - [ ] npm run build passes

              ## Context
              Read: context/xstate-patterns-plan.md (Type System section)

              ## Files to Modify
              - plugins/m42-sprint/compiler/src/types.ts


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/type-system-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/type-system-context.md

              ```markdown
              # Step Context: type-system

              ## Task
              GIVEN the current string-based status types in m42-sprint
              WHEN applying XState-inspired patterns for type safety
              THEN create discriminated unions and event types

              ## Scope
              Enhance plugins/m42-sprint/compiler/src/types.ts only.
              NO runtime changes - types only.

              ## Acceptance Criteria

              ### Discriminated Union: SprintState
              - [ ] `{ status: 'not-started' }`
              - [ ] `{ status: 'in-progress'; current: CurrentPointer; iteration: number; startedAt: string }`
              - [ ] `{ status: 'paused'; pausedAt: CurrentPointer; pauseReason: string }`
              - [ ] `{ status: 'blocked'; error: string; failedPhase: string; blockedAt: string }`
              - [ ] `{ status: 'needs-human'; reason: string; details?: string }`
              - [ ] `{ status: 'completed'; summary?: string; completedAt: string; elapsed: string }`

              ### Event Union: SprintEvent
              - [ ] START, TICK, MAX_ITERATIONS_REACHED
              - [ ] PHASE_COMPLETE { summary, phaseId }
              - [ ] PHASE_FAILED { error, category, phaseId }
              - [ ] STEP_COMPLETE { summary, stepId }
              - [ ] STEP_FAILED { error, category, stepId }
              - [ ] PROPOSE_STEPS { steps, proposedBy }
              - [ ] PAUSE { reason }, RESUME
              - [ ] HUMAN_NEEDED { reason, details? }
              - [ ] GOAL_COMPLETE { summary }

              ### Action Union: SprintAction
              - [ ] LOG { level, message }
              - [ ] SPAWN_CLAUDE { prompt, phaseId, onComplete }
              - [ ] WRITE_PROGRESS
              - [ ] UPDATE_STATS { updates }
              - [ ] EMIT_ACTIVITY { activity, data }
              - [ ] SCHEDULE_RETRY { phaseId, delayMs }
              - [ ] INSERT_STEP { step, position }

              ### TransitionResult Interface
              - [ ] { nextState: SprintState; actions: SprintAction[]; context: Partial<CompiledProgress> }

              ### Guard Functions
              - [ ] Create `guards` object with: hasMorePhases, hasMoreSteps, hasMoreSubPhases
              - [ ] isRetryable, hasStepQueue, orchestrationEnabled, autoApproveEnabled

              ### Backwards Compatibility
              - [ ] Add @deprecated JSDoc to old SprintStatus type
              - [ ] Keep old types working for now
              - [ ] npm run typecheck passes
              - [ ] npm run build passes

              ## Context
              Read: context/xstate-patterns-plan.md (Type System section)

              ## Files to Modify
              - plugins/m42-sprint/compiler/src/types.ts


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/type-system-context.md
              git commit -m "context(type-system): gather implementation context"
              ```
            started-at: "2026-01-19T22:59:49Z"
            completed-at: "2026-01-19T23:01:05Z"
            elapsed: 00:01:16
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              GIVEN the current string-based status types in m42-sprint
              WHEN applying XState-inspired patterns for type safety
              THEN create discriminated unions and event types

              ## Scope
              Enhance plugins/m42-sprint/compiler/src/types.ts only.
              NO runtime changes - types only.

              ## Acceptance Criteria

              ### Discriminated Union: SprintState
              - [ ] `{ status: 'not-started' }`
              - [ ] `{ status: 'in-progress'; current: CurrentPointer; iteration: number; startedAt: string }`
              - [ ] `{ status: 'paused'; pausedAt: CurrentPointer; pauseReason: string }`
              - [ ] `{ status: 'blocked'; error: string; failedPhase: string; blockedAt: string }`
              - [ ] `{ status: 'needs-human'; reason: string; details?: string }`
              - [ ] `{ status: 'completed'; summary?: string; completedAt: string; elapsed: string }`

              ### Event Union: SprintEvent
              - [ ] START, TICK, MAX_ITERATIONS_REACHED
              - [ ] PHASE_COMPLETE { summary, phaseId }
              - [ ] PHASE_FAILED { error, category, phaseId }
              - [ ] STEP_COMPLETE { summary, stepId }
              - [ ] STEP_FAILED { error, category, stepId }
              - [ ] PROPOSE_STEPS { steps, proposedBy }
              - [ ] PAUSE { reason }, RESUME
              - [ ] HUMAN_NEEDED { reason, details? }
              - [ ] GOAL_COMPLETE { summary }

              ### Action Union: SprintAction
              - [ ] LOG { level, message }
              - [ ] SPAWN_CLAUDE { prompt, phaseId, onComplete }
              - [ ] WRITE_PROGRESS
              - [ ] UPDATE_STATS { updates }
              - [ ] EMIT_ACTIVITY { activity, data }
              - [ ] SCHEDULE_RETRY { phaseId, delayMs }
              - [ ] INSERT_STEP { step, position }

              ### TransitionResult Interface
              - [ ] { nextState: SprintState; actions: SprintAction[]; context: Partial<CompiledProgress> }

              ### Guard Functions
              - [ ] Create `guards` object with: hasMorePhases, hasMoreSteps, hasMoreSubPhases
              - [ ] isRetryable, hasStepQueue, orchestrationEnabled, autoApproveEnabled

              ### Backwards Compatibility
              - [ ] Add @deprecated JSDoc to old SprintStatus type
              - [ ] Keep old types working for now
              - [ ] npm run typecheck passes
              - [ ] npm run build passes

              ## Context
              Read: context/xstate-patterns-plan.md (Type System section)

              ## Files to Modify
              - plugins/m42-sprint/compiler/src/types.ts


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/type-system-gherkin.md (scenarios to satisfy)
              3. context/type-system-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(type-system): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: "2026-01-19T23:01:09Z"
            completed-at: "2026-01-19T23:04:20Z"
            elapsed: 00:03:11
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              GIVEN the current string-based status types in m42-sprint
              WHEN applying XState-inspired patterns for type safety
              THEN create discriminated unions and event types

              ## Scope
              Enhance plugins/m42-sprint/compiler/src/types.ts only.
              NO runtime changes - types only.

              ## Acceptance Criteria

              ### Discriminated Union: SprintState
              - [ ] `{ status: 'not-started' }`
              - [ ] `{ status: 'in-progress'; current: CurrentPointer; iteration: number; startedAt: string }`
              - [ ] `{ status: 'paused'; pausedAt: CurrentPointer; pauseReason: string }`
              - [ ] `{ status: 'blocked'; error: string; failedPhase: string; blockedAt: string }`
              - [ ] `{ status: 'needs-human'; reason: string; details?: string }`
              - [ ] `{ status: 'completed'; summary?: string; completedAt: string; elapsed: string }`

              ### Event Union: SprintEvent
              - [ ] START, TICK, MAX_ITERATIONS_REACHED
              - [ ] PHASE_COMPLETE { summary, phaseId }
              - [ ] PHASE_FAILED { error, category, phaseId }
              - [ ] STEP_COMPLETE { summary, stepId }
              - [ ] STEP_FAILED { error, category, stepId }
              - [ ] PROPOSE_STEPS { steps, proposedBy }
              - [ ] PAUSE { reason }, RESUME
              - [ ] HUMAN_NEEDED { reason, details? }
              - [ ] GOAL_COMPLETE { summary }

              ### Action Union: SprintAction
              - [ ] LOG { level, message }
              - [ ] SPAWN_CLAUDE { prompt, phaseId, onComplete }
              - [ ] WRITE_PROGRESS
              - [ ] UPDATE_STATS { updates }
              - [ ] EMIT_ACTIVITY { activity, data }
              - [ ] SCHEDULE_RETRY { phaseId, delayMs }
              - [ ] INSERT_STEP { step, position }

              ### TransitionResult Interface
              - [ ] { nextState: SprintState; actions: SprintAction[]; context: Partial<CompiledProgress> }

              ### Guard Functions
              - [ ] Create `guards` object with: hasMorePhases, hasMoreSteps, hasMoreSubPhases
              - [ ] isRetryable, hasStepQueue, orchestrationEnabled, autoApproveEnabled

              ### Backwards Compatibility
              - [ ] Add @deprecated JSDoc to old SprintStatus type
              - [ ] Keep old types working for now
              - [ ] npm run typecheck passes
              - [ ] npm run build passes

              ## Context
              Read: context/xstate-patterns-plan.md (Type System section)

              ## Files to Modify
              - plugins/m42-sprint/compiler/src/types.ts


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/type-system-context.md (target patterns)
              Read: artifacts/type-system-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(type-system): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: "2026-01-19T23:04:24Z"
            completed-at: "2026-01-19T23:07:03Z"
            elapsed: 00:02:39
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/type-system-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/type-system-qa-report.md

              ```markdown
              # QA Report: type-system

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/type-system-qa-report.md
              git commit -m "qa(type-system): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for type-system.\n\nRead: artifacts/type-system-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/type-system-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: "2026-01-19T23:07:07Z"
            completed-at: "2026-01-19T23:08:58Z"
            elapsed: 00:01:51
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              GIVEN the current string-based status types in m42-sprint
              WHEN applying XState-inspired patterns for type safety
              THEN create discriminated unions and event types

              ## Scope
              Enhance plugins/m42-sprint/compiler/src/types.ts only.
              NO runtime changes - types only.

              ## Acceptance Criteria

              ### Discriminated Union: SprintState
              - [ ] `{ status: 'not-started' }`
              - [ ] `{ status: 'in-progress'; current: CurrentPointer; iteration: number; startedAt: string }`
              - [ ] `{ status: 'paused'; pausedAt: CurrentPointer; pauseReason: string }`
              - [ ] `{ status: 'blocked'; error: string; failedPhase: string; blockedAt: string }`
              - [ ] `{ status: 'needs-human'; reason: string; details?: string }`
              - [ ] `{ status: 'completed'; summary?: string; completedAt: string; elapsed: string }`

              ### Event Union: SprintEvent
              - [ ] START, TICK, MAX_ITERATIONS_REACHED
              - [ ] PHASE_COMPLETE { summary, phaseId }
              - [ ] PHASE_FAILED { error, category, phaseId }
              - [ ] STEP_COMPLETE { summary, stepId }
              - [ ] STEP_FAILED { error, category, stepId }
              - [ ] PROPOSE_STEPS { steps, proposedBy }
              - [ ] PAUSE { reason }, RESUME
              - [ ] HUMAN_NEEDED { reason, details? }
              - [ ] GOAL_COMPLETE { summary }

              ### Action Union: SprintAction
              - [ ] LOG { level, message }
              - [ ] SPAWN_CLAUDE { prompt, phaseId, onComplete }
              - [ ] WRITE_PROGRESS
              - [ ] UPDATE_STATS { updates }
              - [ ] EMIT_ACTIVITY { activity, data }
              - [ ] SCHEDULE_RETRY { phaseId, delayMs }
              - [ ] INSERT_STEP { step, position }

              ### TransitionResult Interface
              - [ ] { nextState: SprintState; actions: SprintAction[]; context: Partial<CompiledProgress> }

              ### Guard Functions
              - [ ] Create `guards` object with: hasMorePhases, hasMoreSteps, hasMoreSubPhases
              - [ ] isRetryable, hasStepQueue, orchestrationEnabled, autoApproveEnabled

              ### Backwards Compatibility
              - [ ] Add @deprecated JSDoc to old SprintStatus type
              - [ ] Keep old types working for now
              - [ ] npm run typecheck passes
              - [ ] npm run build passes

              ## Context
              Read: context/xstate-patterns-plan.md (Type System section)

              ## Files to Modify
              - plugins/m42-sprint/compiler/src/types.ts


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/type-system-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(type-system): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: "2026-01-19T23:09:02Z"
            completed-at: "2026-01-19T23:10:45Z"
            elapsed: 00:01:43
      - id: transition-function
        prompt: |
          GIVEN the discriminated union types from Step 0
          WHEN implementing transition logic
          THEN create testable pure function returning state + actions

          ## Scope
          Create NEW file: plugins/m42-sprint/runtime/src/transition.ts
          Create runtime directory structure if needed.

          ## Acceptance Criteria

          ### Core Function
          - [ ] `transition(state: SprintState, event: SprintEvent, context: CompiledProgress): TransitionResult`
          - [ ] Pure function - NO side effects
          - [ ] Returns { nextState, actions, context }

          ### Event Handling (exhaustive matching)
          - [ ] START → in-progress + SPAWN_CLAUDE action
          - [ ] PHASE_COMPLETE → advance pointer or completed + WRITE_PROGRESS
          - [ ] PHASE_FAILED + retryable → same state + SCHEDULE_RETRY
          - [ ] PHASE_FAILED + not retryable → blocked + WRITE_PROGRESS
          - [ ] PAUSE → paused + WRITE_PROGRESS
          - [ ] RESUME → in-progress + SPAWN_CLAUDE
          - [ ] PROPOSE_STEPS + autoApprove → INSERT_STEP actions
          - [ ] PROPOSE_STEPS + !autoApprove → update step-queue context
          - [ ] MAX_ITERATIONS_REACHED → blocked
          - [ ] HUMAN_NEEDED → needs-human

          ### Helper Functions
          - [ ] `advancePointer(current, context)` → { nextPointer, hasMore }
          - [ ] `calculateBackoff(context)` → delay in ms
          - [ ] `getCurrentPhase/Step/SubPhase(progress)` → current item

          ### Guards Integration
          - [ ] Use guards from types.ts for conditions
          - [ ] TypeScript enforces exhaustive switch

          ### Tests
          - [ ] Unit test for each state × event combination
          - [ ] Test: invalid transitions return unchanged state
          - [ ] Test: actions are correct for each transition
          - [ ] 100% code coverage

          ## Files to Create
          - plugins/m42-sprint/runtime/src/transition.ts
          - plugins/m42-sprint/runtime/src/transition.test.ts

          ## Context
          Read: context/xstate-patterns-plan.md (Phase 2 section)
        status: completed
        phases:
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              GIVEN the discriminated union types from Step 0
              WHEN implementing transition logic
              THEN create testable pure function returning state + actions

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/transition.ts
              Create runtime directory structure if needed.

              ## Acceptance Criteria

              ### Core Function
              - [ ] `transition(state: SprintState, event: SprintEvent, context: CompiledProgress): TransitionResult`
              - [ ] Pure function - NO side effects
              - [ ] Returns { nextState, actions, context }

              ### Event Handling (exhaustive matching)
              - [ ] START → in-progress + SPAWN_CLAUDE action
              - [ ] PHASE_COMPLETE → advance pointer or completed + WRITE_PROGRESS
              - [ ] PHASE_FAILED + retryable → same state + SCHEDULE_RETRY
              - [ ] PHASE_FAILED + not retryable → blocked + WRITE_PROGRESS
              - [ ] PAUSE → paused + WRITE_PROGRESS
              - [ ] RESUME → in-progress + SPAWN_CLAUDE
              - [ ] PROPOSE_STEPS + autoApprove → INSERT_STEP actions
              - [ ] PROPOSE_STEPS + !autoApprove → update step-queue context
              - [ ] MAX_ITERATIONS_REACHED → blocked
              - [ ] HUMAN_NEEDED → needs-human

              ### Helper Functions
              - [ ] `advancePointer(current, context)` → { nextPointer, hasMore }
              - [ ] `calculateBackoff(context)` → delay in ms
              - [ ] `getCurrentPhase/Step/SubPhase(progress)` → current item

              ### Guards Integration
              - [ ] Use guards from types.ts for conditions
              - [ ] TypeScript enforces exhaustive switch

              ### Tests
              - [ ] Unit test for each state × event combination
              - [ ] Test: invalid transitions return unchanged state
              - [ ] Test: actions are correct for each transition
              - [ ] 100% code coverage

              ## Files to Create
              - plugins/m42-sprint/runtime/src/transition.ts
              - plugins/m42-sprint/runtime/src/transition.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 2 section)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/transition-function-gherkin.md

              ```markdown
              # Gherkin Scenarios: transition-function

              ## Step Task
              GIVEN the discriminated union types from Step 0
              WHEN implementing transition logic
              THEN create testable pure function returning state + actions

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/transition.ts
              Create runtime directory structure if needed.

              ## Acceptance Criteria

              ### Core Function
              - [ ] `transition(state: SprintState, event: SprintEvent, context: CompiledProgress): TransitionResult`
              - [ ] Pure function - NO side effects
              - [ ] Returns { nextState, actions, context }

              ### Event Handling (exhaustive matching)
              - [ ] START → in-progress + SPAWN_CLAUDE action
              - [ ] PHASE_COMPLETE → advance pointer or completed + WRITE_PROGRESS
              - [ ] PHASE_FAILED + retryable → same state + SCHEDULE_RETRY
              - [ ] PHASE_FAILED + not retryable → blocked + WRITE_PROGRESS
              - [ ] PAUSE → paused + WRITE_PROGRESS
              - [ ] RESUME → in-progress + SPAWN_CLAUDE
              - [ ] PROPOSE_STEPS + autoApprove → INSERT_STEP actions
              - [ ] PROPOSE_STEPS + !autoApprove → update step-queue context
              - [ ] MAX_ITERATIONS_REACHED → blocked
              - [ ] HUMAN_NEEDED → needs-human

              ### Helper Functions
              - [ ] `advancePointer(current, context)` → { nextPointer, hasMore }
              - [ ] `calculateBackoff(context)` → delay in ms
              - [ ] `getCurrentPhase/Step/SubPhase(progress)` → current item

              ### Guards Integration
              - [ ] Use guards from types.ts for conditions
              - [ ] TypeScript enforces exhaustive switch

              ### Tests
              - [ ] Unit test for each state × event combination
              - [ ] Test: invalid transitions return unchanged state
              - [ ] Test: actions are correct for each transition
              - [ ] 100% code coverage

              ## Files to Create
              - plugins/m42-sprint/runtime/src/transition.ts
              - plugins/m42-sprint/runtime/src/transition.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 2 section)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/transition-function-gherkin.md
              git commit -m "test(transition-function): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: "2026-01-19T23:10:49Z"
            completed-at: "2026-01-19T23:16:14Z"
            elapsed: 00:05:25
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              GIVEN the discriminated union types from Step 0
              WHEN implementing transition logic
              THEN create testable pure function returning state + actions

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/transition.ts
              Create runtime directory structure if needed.

              ## Acceptance Criteria

              ### Core Function
              - [ ] `transition(state: SprintState, event: SprintEvent, context: CompiledProgress): TransitionResult`
              - [ ] Pure function - NO side effects
              - [ ] Returns { nextState, actions, context }

              ### Event Handling (exhaustive matching)
              - [ ] START → in-progress + SPAWN_CLAUDE action
              - [ ] PHASE_COMPLETE → advance pointer or completed + WRITE_PROGRESS
              - [ ] PHASE_FAILED + retryable → same state + SCHEDULE_RETRY
              - [ ] PHASE_FAILED + not retryable → blocked + WRITE_PROGRESS
              - [ ] PAUSE → paused + WRITE_PROGRESS
              - [ ] RESUME → in-progress + SPAWN_CLAUDE
              - [ ] PROPOSE_STEPS + autoApprove → INSERT_STEP actions
              - [ ] PROPOSE_STEPS + !autoApprove → update step-queue context
              - [ ] MAX_ITERATIONS_REACHED → blocked
              - [ ] HUMAN_NEEDED → needs-human

              ### Helper Functions
              - [ ] `advancePointer(current, context)` → { nextPointer, hasMore }
              - [ ] `calculateBackoff(context)` → delay in ms
              - [ ] `getCurrentPhase/Step/SubPhase(progress)` → current item

              ### Guards Integration
              - [ ] Use guards from types.ts for conditions
              - [ ] TypeScript enforces exhaustive switch

              ### Tests
              - [ ] Unit test for each state × event combination
              - [ ] Test: invalid transitions return unchanged state
              - [ ] Test: actions are correct for each transition
              - [ ] 100% code coverage

              ## Files to Create
              - plugins/m42-sprint/runtime/src/transition.ts
              - plugins/m42-sprint/runtime/src/transition.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 2 section)


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/transition-function-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/transition-function-context.md

              ```markdown
              # Step Context: transition-function

              ## Task
              GIVEN the discriminated union types from Step 0
              WHEN implementing transition logic
              THEN create testable pure function returning state + actions

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/transition.ts
              Create runtime directory structure if needed.

              ## Acceptance Criteria

              ### Core Function
              - [ ] `transition(state: SprintState, event: SprintEvent, context: CompiledProgress): TransitionResult`
              - [ ] Pure function - NO side effects
              - [ ] Returns { nextState, actions, context }

              ### Event Handling (exhaustive matching)
              - [ ] START → in-progress + SPAWN_CLAUDE action
              - [ ] PHASE_COMPLETE → advance pointer or completed + WRITE_PROGRESS
              - [ ] PHASE_FAILED + retryable → same state + SCHEDULE_RETRY
              - [ ] PHASE_FAILED + not retryable → blocked + WRITE_PROGRESS
              - [ ] PAUSE → paused + WRITE_PROGRESS
              - [ ] RESUME → in-progress + SPAWN_CLAUDE
              - [ ] PROPOSE_STEPS + autoApprove → INSERT_STEP actions
              - [ ] PROPOSE_STEPS + !autoApprove → update step-queue context
              - [ ] MAX_ITERATIONS_REACHED → blocked
              - [ ] HUMAN_NEEDED → needs-human

              ### Helper Functions
              - [ ] `advancePointer(current, context)` → { nextPointer, hasMore }
              - [ ] `calculateBackoff(context)` → delay in ms
              - [ ] `getCurrentPhase/Step/SubPhase(progress)` → current item

              ### Guards Integration
              - [ ] Use guards from types.ts for conditions
              - [ ] TypeScript enforces exhaustive switch

              ### Tests
              - [ ] Unit test for each state × event combination
              - [ ] Test: invalid transitions return unchanged state
              - [ ] Test: actions are correct for each transition
              - [ ] 100% code coverage

              ## Files to Create
              - plugins/m42-sprint/runtime/src/transition.ts
              - plugins/m42-sprint/runtime/src/transition.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 2 section)


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/transition-function-context.md
              git commit -m "context(transition-function): gather implementation context"
              ```
            started-at: "2026-01-19T23:16:19Z"
            completed-at: "2026-01-19T23:18:19Z"
            elapsed: 00:02:00
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              GIVEN the discriminated union types from Step 0
              WHEN implementing transition logic
              THEN create testable pure function returning state + actions

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/transition.ts
              Create runtime directory structure if needed.

              ## Acceptance Criteria

              ### Core Function
              - [ ] `transition(state: SprintState, event: SprintEvent, context: CompiledProgress): TransitionResult`
              - [ ] Pure function - NO side effects
              - [ ] Returns { nextState, actions, context }

              ### Event Handling (exhaustive matching)
              - [ ] START → in-progress + SPAWN_CLAUDE action
              - [ ] PHASE_COMPLETE → advance pointer or completed + WRITE_PROGRESS
              - [ ] PHASE_FAILED + retryable → same state + SCHEDULE_RETRY
              - [ ] PHASE_FAILED + not retryable → blocked + WRITE_PROGRESS
              - [ ] PAUSE → paused + WRITE_PROGRESS
              - [ ] RESUME → in-progress + SPAWN_CLAUDE
              - [ ] PROPOSE_STEPS + autoApprove → INSERT_STEP actions
              - [ ] PROPOSE_STEPS + !autoApprove → update step-queue context
              - [ ] MAX_ITERATIONS_REACHED → blocked
              - [ ] HUMAN_NEEDED → needs-human

              ### Helper Functions
              - [ ] `advancePointer(current, context)` → { nextPointer, hasMore }
              - [ ] `calculateBackoff(context)` → delay in ms
              - [ ] `getCurrentPhase/Step/SubPhase(progress)` → current item

              ### Guards Integration
              - [ ] Use guards from types.ts for conditions
              - [ ] TypeScript enforces exhaustive switch

              ### Tests
              - [ ] Unit test for each state × event combination
              - [ ] Test: invalid transitions return unchanged state
              - [ ] Test: actions are correct for each transition
              - [ ] 100% code coverage

              ## Files to Create
              - plugins/m42-sprint/runtime/src/transition.ts
              - plugins/m42-sprint/runtime/src/transition.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 2 section)


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/transition-function-gherkin.md (scenarios to satisfy)
              3. context/transition-function-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(transition-function): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: "2026-01-19T23:18:25Z"
            completed-at: "2026-01-19T23:24:11Z"
            elapsed: 00:05:46
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              GIVEN the discriminated union types from Step 0
              WHEN implementing transition logic
              THEN create testable pure function returning state + actions

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/transition.ts
              Create runtime directory structure if needed.

              ## Acceptance Criteria

              ### Core Function
              - [ ] `transition(state: SprintState, event: SprintEvent, context: CompiledProgress): TransitionResult`
              - [ ] Pure function - NO side effects
              - [ ] Returns { nextState, actions, context }

              ### Event Handling (exhaustive matching)
              - [ ] START → in-progress + SPAWN_CLAUDE action
              - [ ] PHASE_COMPLETE → advance pointer or completed + WRITE_PROGRESS
              - [ ] PHASE_FAILED + retryable → same state + SCHEDULE_RETRY
              - [ ] PHASE_FAILED + not retryable → blocked + WRITE_PROGRESS
              - [ ] PAUSE → paused + WRITE_PROGRESS
              - [ ] RESUME → in-progress + SPAWN_CLAUDE
              - [ ] PROPOSE_STEPS + autoApprove → INSERT_STEP actions
              - [ ] PROPOSE_STEPS + !autoApprove → update step-queue context
              - [ ] MAX_ITERATIONS_REACHED → blocked
              - [ ] HUMAN_NEEDED → needs-human

              ### Helper Functions
              - [ ] `advancePointer(current, context)` → { nextPointer, hasMore }
              - [ ] `calculateBackoff(context)` → delay in ms
              - [ ] `getCurrentPhase/Step/SubPhase(progress)` → current item

              ### Guards Integration
              - [ ] Use guards from types.ts for conditions
              - [ ] TypeScript enforces exhaustive switch

              ### Tests
              - [ ] Unit test for each state × event combination
              - [ ] Test: invalid transitions return unchanged state
              - [ ] Test: actions are correct for each transition
              - [ ] 100% code coverage

              ## Files to Create
              - plugins/m42-sprint/runtime/src/transition.ts
              - plugins/m42-sprint/runtime/src/transition.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 2 section)


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/transition-function-context.md (target patterns)
              Read: artifacts/transition-function-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(transition-function): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: "2026-01-19T23:24:16Z"
            completed-at: "2026-01-19T23:28:12Z"
            elapsed: 00:03:56
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/transition-function-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/transition-function-qa-report.md

              ```markdown
              # QA Report: transition-function

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/transition-function-qa-report.md
              git commit -m "qa(transition-function): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for transition-function.\n\nRead: artifacts/transition-function-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/transition-function-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: "2026-01-19T23:28:17Z"
            completed-at: "2026-01-19T23:29:33Z"
            elapsed: 00:01:16
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              GIVEN the discriminated union types from Step 0
              WHEN implementing transition logic
              THEN create testable pure function returning state + actions

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/transition.ts
              Create runtime directory structure if needed.

              ## Acceptance Criteria

              ### Core Function
              - [ ] `transition(state: SprintState, event: SprintEvent, context: CompiledProgress): TransitionResult`
              - [ ] Pure function - NO side effects
              - [ ] Returns { nextState, actions, context }

              ### Event Handling (exhaustive matching)
              - [ ] START → in-progress + SPAWN_CLAUDE action
              - [ ] PHASE_COMPLETE → advance pointer or completed + WRITE_PROGRESS
              - [ ] PHASE_FAILED + retryable → same state + SCHEDULE_RETRY
              - [ ] PHASE_FAILED + not retryable → blocked + WRITE_PROGRESS
              - [ ] PAUSE → paused + WRITE_PROGRESS
              - [ ] RESUME → in-progress + SPAWN_CLAUDE
              - [ ] PROPOSE_STEPS + autoApprove → INSERT_STEP actions
              - [ ] PROPOSE_STEPS + !autoApprove → update step-queue context
              - [ ] MAX_ITERATIONS_REACHED → blocked
              - [ ] HUMAN_NEEDED → needs-human

              ### Helper Functions
              - [ ] `advancePointer(current, context)` → { nextPointer, hasMore }
              - [ ] `calculateBackoff(context)` → delay in ms
              - [ ] `getCurrentPhase/Step/SubPhase(progress)` → current item

              ### Guards Integration
              - [ ] Use guards from types.ts for conditions
              - [ ] TypeScript enforces exhaustive switch

              ### Tests
              - [ ] Unit test for each state × event combination
              - [ ] Test: invalid transitions return unchanged state
              - [ ] Test: actions are correct for each transition
              - [ ] 100% code coverage

              ## Files to Create
              - plugins/m42-sprint/runtime/src/transition.ts
              - plugins/m42-sprint/runtime/src/transition.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 2 section)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/transition-function-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(transition-function): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: "2026-01-19T23:29:39Z"
            completed-at: "2026-01-19T23:31:04Z"
            elapsed: 00:01:25
      - id: yaml-ops
        prompt: |
          GIVEN the need to replace yq shell commands with TypeScript
          WHEN implementing YAML operations
          THEN create atomic read/write with checksum validation

          ## Scope
          Create NEW file: plugins/m42-sprint/runtime/src/yaml-ops.ts

          ## Acceptance Criteria

          ### Atomic Write
          - [ ] `writeProgressAtomic(filePath, progress)` → Promise<void>
          - [ ] Write to temp file first (same directory for same filesystem)
          - [ ] Atomic rename (mv is atomic on POSIX)
          - [ ] Update checksum file after successful write

          ### Read with Validation
          - [ ] `readProgress(filePath)` → CompiledProgress
          - [ ] Validate checksum if checksum file exists
          - [ ] Throw on checksum mismatch (corruption detection)

          ### Transaction Support
          - [ ] `backupProgress(filePath)` → void (create .backup)
          - [ ] `restoreProgress(filePath)` → boolean (restore from .backup)
          - [ ] `cleanupBackup(filePath)` → void (remove .backup)

          ### Checksum
          - [ ] `calculateChecksum(content)` → string (SHA256)
          - [ ] Store in {file}.checksum

          ### Tests
          - [ ] Test: atomic write survives process.exit
          - [ ] Test: checksum detects file modification
          - [ ] Test: backup/restore works correctly
          - [ ] Test: missing checksum file is OK (first run)

          ## Dependencies
          - js-yaml (already in compiler/package.json)
          - crypto (Node.js built-in)

          ## Files to Create
          - plugins/m42-sprint/runtime/src/yaml-ops.ts
          - plugins/m42-sprint/runtime/src/yaml-ops.test.ts

          ## Context
          Read: context/xstate-patterns-plan.md (Phase 7 section)
          Reference: plugins/m42-sprint/scripts/sprint-loop.sh lines 190-340 (yaml_atomic_update)
        status: completed
        phases:
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              GIVEN the need to replace yq shell commands with TypeScript
              WHEN implementing YAML operations
              THEN create atomic read/write with checksum validation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/yaml-ops.ts

              ## Acceptance Criteria

              ### Atomic Write
              - [ ] `writeProgressAtomic(filePath, progress)` → Promise<void>
              - [ ] Write to temp file first (same directory for same filesystem)
              - [ ] Atomic rename (mv is atomic on POSIX)
              - [ ] Update checksum file after successful write

              ### Read with Validation
              - [ ] `readProgress(filePath)` → CompiledProgress
              - [ ] Validate checksum if checksum file exists
              - [ ] Throw on checksum mismatch (corruption detection)

              ### Transaction Support
              - [ ] `backupProgress(filePath)` → void (create .backup)
              - [ ] `restoreProgress(filePath)` → boolean (restore from .backup)
              - [ ] `cleanupBackup(filePath)` → void (remove .backup)

              ### Checksum
              - [ ] `calculateChecksum(content)` → string (SHA256)
              - [ ] Store in {file}.checksum

              ### Tests
              - [ ] Test: atomic write survives process.exit
              - [ ] Test: checksum detects file modification
              - [ ] Test: backup/restore works correctly
              - [ ] Test: missing checksum file is OK (first run)

              ## Dependencies
              - js-yaml (already in compiler/package.json)
              - crypto (Node.js built-in)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/yaml-ops.ts
              - plugins/m42-sprint/runtime/src/yaml-ops.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 7 section)
              Reference: plugins/m42-sprint/scripts/sprint-loop.sh lines 190-340 (yaml_atomic_update)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/yaml-ops-gherkin.md

              ```markdown
              # Gherkin Scenarios: yaml-ops

              ## Step Task
              GIVEN the need to replace yq shell commands with TypeScript
              WHEN implementing YAML operations
              THEN create atomic read/write with checksum validation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/yaml-ops.ts

              ## Acceptance Criteria

              ### Atomic Write
              - [ ] `writeProgressAtomic(filePath, progress)` → Promise<void>
              - [ ] Write to temp file first (same directory for same filesystem)
              - [ ] Atomic rename (mv is atomic on POSIX)
              - [ ] Update checksum file after successful write

              ### Read with Validation
              - [ ] `readProgress(filePath)` → CompiledProgress
              - [ ] Validate checksum if checksum file exists
              - [ ] Throw on checksum mismatch (corruption detection)

              ### Transaction Support
              - [ ] `backupProgress(filePath)` → void (create .backup)
              - [ ] `restoreProgress(filePath)` → boolean (restore from .backup)
              - [ ] `cleanupBackup(filePath)` → void (remove .backup)

              ### Checksum
              - [ ] `calculateChecksum(content)` → string (SHA256)
              - [ ] Store in {file}.checksum

              ### Tests
              - [ ] Test: atomic write survives process.exit
              - [ ] Test: checksum detects file modification
              - [ ] Test: backup/restore works correctly
              - [ ] Test: missing checksum file is OK (first run)

              ## Dependencies
              - js-yaml (already in compiler/package.json)
              - crypto (Node.js built-in)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/yaml-ops.ts
              - plugins/m42-sprint/runtime/src/yaml-ops.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 7 section)
              Reference: plugins/m42-sprint/scripts/sprint-loop.sh lines 190-340 (yaml_atomic_update)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/yaml-ops-gherkin.md
              git commit -m "test(yaml-ops): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: "2026-01-19T23:31:10Z"
            completed-at: "2026-01-19T23:34:48Z"
            elapsed: 00:03:38
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              GIVEN the need to replace yq shell commands with TypeScript
              WHEN implementing YAML operations
              THEN create atomic read/write with checksum validation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/yaml-ops.ts

              ## Acceptance Criteria

              ### Atomic Write
              - [ ] `writeProgressAtomic(filePath, progress)` → Promise<void>
              - [ ] Write to temp file first (same directory for same filesystem)
              - [ ] Atomic rename (mv is atomic on POSIX)
              - [ ] Update checksum file after successful write

              ### Read with Validation
              - [ ] `readProgress(filePath)` → CompiledProgress
              - [ ] Validate checksum if checksum file exists
              - [ ] Throw on checksum mismatch (corruption detection)

              ### Transaction Support
              - [ ] `backupProgress(filePath)` → void (create .backup)
              - [ ] `restoreProgress(filePath)` → boolean (restore from .backup)
              - [ ] `cleanupBackup(filePath)` → void (remove .backup)

              ### Checksum
              - [ ] `calculateChecksum(content)` → string (SHA256)
              - [ ] Store in {file}.checksum

              ### Tests
              - [ ] Test: atomic write survives process.exit
              - [ ] Test: checksum detects file modification
              - [ ] Test: backup/restore works correctly
              - [ ] Test: missing checksum file is OK (first run)

              ## Dependencies
              - js-yaml (already in compiler/package.json)
              - crypto (Node.js built-in)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/yaml-ops.ts
              - plugins/m42-sprint/runtime/src/yaml-ops.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 7 section)
              Reference: plugins/m42-sprint/scripts/sprint-loop.sh lines 190-340 (yaml_atomic_update)


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/yaml-ops-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/yaml-ops-context.md

              ```markdown
              # Step Context: yaml-ops

              ## Task
              GIVEN the need to replace yq shell commands with TypeScript
              WHEN implementing YAML operations
              THEN create atomic read/write with checksum validation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/yaml-ops.ts

              ## Acceptance Criteria

              ### Atomic Write
              - [ ] `writeProgressAtomic(filePath, progress)` → Promise<void>
              - [ ] Write to temp file first (same directory for same filesystem)
              - [ ] Atomic rename (mv is atomic on POSIX)
              - [ ] Update checksum file after successful write

              ### Read with Validation
              - [ ] `readProgress(filePath)` → CompiledProgress
              - [ ] Validate checksum if checksum file exists
              - [ ] Throw on checksum mismatch (corruption detection)

              ### Transaction Support
              - [ ] `backupProgress(filePath)` → void (create .backup)
              - [ ] `restoreProgress(filePath)` → boolean (restore from .backup)
              - [ ] `cleanupBackup(filePath)` → void (remove .backup)

              ### Checksum
              - [ ] `calculateChecksum(content)` → string (SHA256)
              - [ ] Store in {file}.checksum

              ### Tests
              - [ ] Test: atomic write survives process.exit
              - [ ] Test: checksum detects file modification
              - [ ] Test: backup/restore works correctly
              - [ ] Test: missing checksum file is OK (first run)

              ## Dependencies
              - js-yaml (already in compiler/package.json)
              - crypto (Node.js built-in)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/yaml-ops.ts
              - plugins/m42-sprint/runtime/src/yaml-ops.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 7 section)
              Reference: plugins/m42-sprint/scripts/sprint-loop.sh lines 190-340 (yaml_atomic_update)


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/yaml-ops-context.md
              git commit -m "context(yaml-ops): gather implementation context"
              ```
            started-at: "2026-01-19T23:34:53Z"
            completed-at: "2026-01-19T23:36:19Z"
            elapsed: 00:01:26
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              GIVEN the need to replace yq shell commands with TypeScript
              WHEN implementing YAML operations
              THEN create atomic read/write with checksum validation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/yaml-ops.ts

              ## Acceptance Criteria

              ### Atomic Write
              - [ ] `writeProgressAtomic(filePath, progress)` → Promise<void>
              - [ ] Write to temp file first (same directory for same filesystem)
              - [ ] Atomic rename (mv is atomic on POSIX)
              - [ ] Update checksum file after successful write

              ### Read with Validation
              - [ ] `readProgress(filePath)` → CompiledProgress
              - [ ] Validate checksum if checksum file exists
              - [ ] Throw on checksum mismatch (corruption detection)

              ### Transaction Support
              - [ ] `backupProgress(filePath)` → void (create .backup)
              - [ ] `restoreProgress(filePath)` → boolean (restore from .backup)
              - [ ] `cleanupBackup(filePath)` → void (remove .backup)

              ### Checksum
              - [ ] `calculateChecksum(content)` → string (SHA256)
              - [ ] Store in {file}.checksum

              ### Tests
              - [ ] Test: atomic write survives process.exit
              - [ ] Test: checksum detects file modification
              - [ ] Test: backup/restore works correctly
              - [ ] Test: missing checksum file is OK (first run)

              ## Dependencies
              - js-yaml (already in compiler/package.json)
              - crypto (Node.js built-in)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/yaml-ops.ts
              - plugins/m42-sprint/runtime/src/yaml-ops.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 7 section)
              Reference: plugins/m42-sprint/scripts/sprint-loop.sh lines 190-340 (yaml_atomic_update)


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/yaml-ops-gherkin.md (scenarios to satisfy)
              3. context/yaml-ops-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(yaml-ops): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: "2026-01-19T23:36:24Z"
            completed-at: "2026-01-19T23:39:06Z"
            elapsed: 00:02:42
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              GIVEN the need to replace yq shell commands with TypeScript
              WHEN implementing YAML operations
              THEN create atomic read/write with checksum validation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/yaml-ops.ts

              ## Acceptance Criteria

              ### Atomic Write
              - [ ] `writeProgressAtomic(filePath, progress)` → Promise<void>
              - [ ] Write to temp file first (same directory for same filesystem)
              - [ ] Atomic rename (mv is atomic on POSIX)
              - [ ] Update checksum file after successful write

              ### Read with Validation
              - [ ] `readProgress(filePath)` → CompiledProgress
              - [ ] Validate checksum if checksum file exists
              - [ ] Throw on checksum mismatch (corruption detection)

              ### Transaction Support
              - [ ] `backupProgress(filePath)` → void (create .backup)
              - [ ] `restoreProgress(filePath)` → boolean (restore from .backup)
              - [ ] `cleanupBackup(filePath)` → void (remove .backup)

              ### Checksum
              - [ ] `calculateChecksum(content)` → string (SHA256)
              - [ ] Store in {file}.checksum

              ### Tests
              - [ ] Test: atomic write survives process.exit
              - [ ] Test: checksum detects file modification
              - [ ] Test: backup/restore works correctly
              - [ ] Test: missing checksum file is OK (first run)

              ## Dependencies
              - js-yaml (already in compiler/package.json)
              - crypto (Node.js built-in)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/yaml-ops.ts
              - plugins/m42-sprint/runtime/src/yaml-ops.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 7 section)
              Reference: plugins/m42-sprint/scripts/sprint-loop.sh lines 190-340 (yaml_atomic_update)


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/yaml-ops-context.md (target patterns)
              Read: artifacts/yaml-ops-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(yaml-ops): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: "2026-01-19T23:39:12Z"
            completed-at: "2026-01-19T23:41:55Z"
            elapsed: 00:02:43
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/yaml-ops-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/yaml-ops-qa-report.md

              ```markdown
              # QA Report: yaml-ops

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/yaml-ops-qa-report.md
              git commit -m "qa(yaml-ops): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for yaml-ops.\n\nRead: artifacts/yaml-ops-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/yaml-ops-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: "2026-01-19T23:42:01Z"
            completed-at: "2026-01-19T23:43:35Z"
            elapsed: 00:01:34
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              GIVEN the need to replace yq shell commands with TypeScript
              WHEN implementing YAML operations
              THEN create atomic read/write with checksum validation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/yaml-ops.ts

              ## Acceptance Criteria

              ### Atomic Write
              - [ ] `writeProgressAtomic(filePath, progress)` → Promise<void>
              - [ ] Write to temp file first (same directory for same filesystem)
              - [ ] Atomic rename (mv is atomic on POSIX)
              - [ ] Update checksum file after successful write

              ### Read with Validation
              - [ ] `readProgress(filePath)` → CompiledProgress
              - [ ] Validate checksum if checksum file exists
              - [ ] Throw on checksum mismatch (corruption detection)

              ### Transaction Support
              - [ ] `backupProgress(filePath)` → void (create .backup)
              - [ ] `restoreProgress(filePath)` → boolean (restore from .backup)
              - [ ] `cleanupBackup(filePath)` → void (remove .backup)

              ### Checksum
              - [ ] `calculateChecksum(content)` → string (SHA256)
              - [ ] Store in {file}.checksum

              ### Tests
              - [ ] Test: atomic write survives process.exit
              - [ ] Test: checksum detects file modification
              - [ ] Test: backup/restore works correctly
              - [ ] Test: missing checksum file is OK (first run)

              ## Dependencies
              - js-yaml (already in compiler/package.json)
              - crypto (Node.js built-in)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/yaml-ops.ts
              - plugins/m42-sprint/runtime/src/yaml-ops.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 7 section)
              Reference: plugins/m42-sprint/scripts/sprint-loop.sh lines 190-340 (yaml_atomic_update)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/yaml-ops-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(yaml-ops): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: "2026-01-19T23:43:41Z"
            completed-at: "2026-01-19T23:45:39Z"
            elapsed: 00:01:58
      - id: prompt-builder
        prompt: |
          GIVEN build-sprint-prompt.sh (354 lines) and build-parallel-prompt.sh (82 lines)
          WHEN migrating to TypeScript
          THEN create unified prompt builder with template support

          ## Scope
          Create NEW file: plugins/m42-sprint/runtime/src/prompt-builder.ts

          ## Acceptance Criteria

          ### Main Function
          - [ ] `buildPrompt(progress, sprintDir, customPrompts?)` → string
          - [ ] Handles regular phases, for-each steps, and sub-phases

          ### Template Variables
          - [ ] {{sprint.id}}, {{sprint.name}}
          - [ ] {{iteration}}
          - [ ] {{phase.id}}, {{phase.index}}
          - [ ] {{step.id}}, {{step.prompt}}, {{step.index}}
          - [ ] {{subPhase.id}}, {{subPhase.index}}
          - [ ] {{retryCount}}

          ### Prompt Sections
          - [ ] Header: sprint info, iteration count
          - [ ] Position: phase/step/sub-phase indicator
          - [ ] Retry Warning: if retryCount > 0
          - [ ] Context: load and concatenate context/*.md files
          - [ ] Task: the actual prompt from phase/step
          - [ ] Instructions: general guidelines
          - [ ] Result Reporting: JSON format instructions

          ### Custom Prompts Override
          - [ ] Read prompts.header from SPRINT.yaml
          - [ ] Read prompts.position, prompts.instructions, etc.
          - [ ] Fall back to defaults if not specified

          ### Parallel Support
          - [ ] `buildParallelPrompt(...)` for parallel phases
          - [ ] Include parallel task ID in prompt

          ### Tests
          - [ ] Test: all template variables substituted
          - [ ] Test: custom prompts override defaults
          - [ ] Test: context files loaded correctly
          - [ ] Test: output matches build-sprint-prompt.sh output

          ## Files to Create
          - plugins/m42-sprint/runtime/src/prompt-builder.ts
          - plugins/m42-sprint/runtime/src/prompt-builder.test.ts

          ## Reference
          Read: plugins/m42-sprint/scripts/build-sprint-prompt.sh
          Read: plugins/m42-sprint/scripts/build-parallel-prompt.sh
        status: completed
        phases:
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              GIVEN build-sprint-prompt.sh (354 lines) and build-parallel-prompt.sh (82 lines)
              WHEN migrating to TypeScript
              THEN create unified prompt builder with template support

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/prompt-builder.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `buildPrompt(progress, sprintDir, customPrompts?)` → string
              - [ ] Handles regular phases, for-each steps, and sub-phases

              ### Template Variables
              - [ ] 2026-01-20_typescript-runtime-migration, typescript-runtime-migration
              - [ ] {{iteration}}
              - [ ] red, 0
              - [ ] prompt-builder, {{step.prompt}}, 3
              - [ ] {{subPhase.id}}, {{subPhase.index}}
              - [ ] {{retryCount}}

              ### Prompt Sections
              - [ ] Header: sprint info, iteration count
              - [ ] Position: phase/step/sub-phase indicator
              - [ ] Retry Warning: if retryCount > 0
              - [ ] Context: load and concatenate context/*.md files
              - [ ] Task: the actual prompt from phase/step
              - [ ] Instructions: general guidelines
              - [ ] Result Reporting: JSON format instructions

              ### Custom Prompts Override
              - [ ] Read prompts.header from SPRINT.yaml
              - [ ] Read prompts.position, prompts.instructions, etc.
              - [ ] Fall back to defaults if not specified

              ### Parallel Support
              - [ ] `buildParallelPrompt(...)` for parallel phases
              - [ ] Include parallel task ID in prompt

              ### Tests
              - [ ] Test: all template variables substituted
              - [ ] Test: custom prompts override defaults
              - [ ] Test: context files loaded correctly
              - [ ] Test: output matches build-sprint-prompt.sh output

              ## Files to Create
              - plugins/m42-sprint/runtime/src/prompt-builder.ts
              - plugins/m42-sprint/runtime/src/prompt-builder.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              Read: plugins/m42-sprint/scripts/build-parallel-prompt.sh


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/prompt-builder-gherkin.md

              ```markdown
              # Gherkin Scenarios: prompt-builder

              ## Step Task
              GIVEN build-sprint-prompt.sh (354 lines) and build-parallel-prompt.sh (82 lines)
              WHEN migrating to TypeScript
              THEN create unified prompt builder with template support

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/prompt-builder.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `buildPrompt(progress, sprintDir, customPrompts?)` → string
              - [ ] Handles regular phases, for-each steps, and sub-phases

              ### Template Variables
              - [ ] 2026-01-20_typescript-runtime-migration, typescript-runtime-migration
              - [ ] {{iteration}}
              - [ ] red, 0
              - [ ] prompt-builder, {{step.prompt}}, 3
              - [ ] {{subPhase.id}}, {{subPhase.index}}
              - [ ] {{retryCount}}

              ### Prompt Sections
              - [ ] Header: sprint info, iteration count
              - [ ] Position: phase/step/sub-phase indicator
              - [ ] Retry Warning: if retryCount > 0
              - [ ] Context: load and concatenate context/*.md files
              - [ ] Task: the actual prompt from phase/step
              - [ ] Instructions: general guidelines
              - [ ] Result Reporting: JSON format instructions

              ### Custom Prompts Override
              - [ ] Read prompts.header from SPRINT.yaml
              - [ ] Read prompts.position, prompts.instructions, etc.
              - [ ] Fall back to defaults if not specified

              ### Parallel Support
              - [ ] `buildParallelPrompt(...)` for parallel phases
              - [ ] Include parallel task ID in prompt

              ### Tests
              - [ ] Test: all template variables substituted
              - [ ] Test: custom prompts override defaults
              - [ ] Test: context files loaded correctly
              - [ ] Test: output matches build-sprint-prompt.sh output

              ## Files to Create
              - plugins/m42-sprint/runtime/src/prompt-builder.ts
              - plugins/m42-sprint/runtime/src/prompt-builder.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              Read: plugins/m42-sprint/scripts/build-parallel-prompt.sh


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/prompt-builder-gherkin.md
              git commit -m "test(prompt-builder): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: "2026-01-19T23:45:44Z"
            completed-at: "2026-01-19T23:50:12Z"
            elapsed: 00:04:28
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              GIVEN build-sprint-prompt.sh (354 lines) and build-parallel-prompt.sh (82 lines)
              WHEN migrating to TypeScript
              THEN create unified prompt builder with template support

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/prompt-builder.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `buildPrompt(progress, sprintDir, customPrompts?)` → string
              - [ ] Handles regular phases, for-each steps, and sub-phases

              ### Template Variables
              - [ ] 2026-01-20_typescript-runtime-migration, typescript-runtime-migration
              - [ ] {{iteration}}
              - [ ] context, 1
              - [ ] prompt-builder, {{step.prompt}}, 3
              - [ ] {{subPhase.id}}, {{subPhase.index}}
              - [ ] {{retryCount}}

              ### Prompt Sections
              - [ ] Header: sprint info, iteration count
              - [ ] Position: phase/step/sub-phase indicator
              - [ ] Retry Warning: if retryCount > 0
              - [ ] Context: load and concatenate context/*.md files
              - [ ] Task: the actual prompt from phase/step
              - [ ] Instructions: general guidelines
              - [ ] Result Reporting: JSON format instructions

              ### Custom Prompts Override
              - [ ] Read prompts.header from SPRINT.yaml
              - [ ] Read prompts.position, prompts.instructions, etc.
              - [ ] Fall back to defaults if not specified

              ### Parallel Support
              - [ ] `buildParallelPrompt(...)` for parallel phases
              - [ ] Include parallel task ID in prompt

              ### Tests
              - [ ] Test: all template variables substituted
              - [ ] Test: custom prompts override defaults
              - [ ] Test: context files loaded correctly
              - [ ] Test: output matches build-sprint-prompt.sh output

              ## Files to Create
              - plugins/m42-sprint/runtime/src/prompt-builder.ts
              - plugins/m42-sprint/runtime/src/prompt-builder.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              Read: plugins/m42-sprint/scripts/build-parallel-prompt.sh


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/prompt-builder-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/prompt-builder-context.md

              ```markdown
              # Step Context: prompt-builder

              ## Task
              GIVEN build-sprint-prompt.sh (354 lines) and build-parallel-prompt.sh (82 lines)
              WHEN migrating to TypeScript
              THEN create unified prompt builder with template support

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/prompt-builder.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `buildPrompt(progress, sprintDir, customPrompts?)` → string
              - [ ] Handles regular phases, for-each steps, and sub-phases

              ### Template Variables
              - [ ] 2026-01-20_typescript-runtime-migration, typescript-runtime-migration
              - [ ] {{iteration}}
              - [ ] context, 1
              - [ ] prompt-builder, {{step.prompt}}, 3
              - [ ] {{subPhase.id}}, {{subPhase.index}}
              - [ ] {{retryCount}}

              ### Prompt Sections
              - [ ] Header: sprint info, iteration count
              - [ ] Position: phase/step/sub-phase indicator
              - [ ] Retry Warning: if retryCount > 0
              - [ ] Context: load and concatenate context/*.md files
              - [ ] Task: the actual prompt from phase/step
              - [ ] Instructions: general guidelines
              - [ ] Result Reporting: JSON format instructions

              ### Custom Prompts Override
              - [ ] Read prompts.header from SPRINT.yaml
              - [ ] Read prompts.position, prompts.instructions, etc.
              - [ ] Fall back to defaults if not specified

              ### Parallel Support
              - [ ] `buildParallelPrompt(...)` for parallel phases
              - [ ] Include parallel task ID in prompt

              ### Tests
              - [ ] Test: all template variables substituted
              - [ ] Test: custom prompts override defaults
              - [ ] Test: context files loaded correctly
              - [ ] Test: output matches build-sprint-prompt.sh output

              ## Files to Create
              - plugins/m42-sprint/runtime/src/prompt-builder.ts
              - plugins/m42-sprint/runtime/src/prompt-builder.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              Read: plugins/m42-sprint/scripts/build-parallel-prompt.sh


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/prompt-builder-context.md
              git commit -m "context(prompt-builder): gather implementation context"
              ```
            started-at: "2026-01-19T23:50:18Z"
            completed-at: "2026-01-19T23:51:45Z"
            elapsed: 00:01:27
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              GIVEN build-sprint-prompt.sh (354 lines) and build-parallel-prompt.sh (82 lines)
              WHEN migrating to TypeScript
              THEN create unified prompt builder with template support

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/prompt-builder.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `buildPrompt(progress, sprintDir, customPrompts?)` → string
              - [ ] Handles regular phases, for-each steps, and sub-phases

              ### Template Variables
              - [ ] 2026-01-20_typescript-runtime-migration, typescript-runtime-migration
              - [ ] {{iteration}}
              - [ ] green, 2
              - [ ] prompt-builder, {{step.prompt}}, 3
              - [ ] {{subPhase.id}}, {{subPhase.index}}
              - [ ] {{retryCount}}

              ### Prompt Sections
              - [ ] Header: sprint info, iteration count
              - [ ] Position: phase/step/sub-phase indicator
              - [ ] Retry Warning: if retryCount > 0
              - [ ] Context: load and concatenate context/*.md files
              - [ ] Task: the actual prompt from phase/step
              - [ ] Instructions: general guidelines
              - [ ] Result Reporting: JSON format instructions

              ### Custom Prompts Override
              - [ ] Read prompts.header from SPRINT.yaml
              - [ ] Read prompts.position, prompts.instructions, etc.
              - [ ] Fall back to defaults if not specified

              ### Parallel Support
              - [ ] `buildParallelPrompt(...)` for parallel phases
              - [ ] Include parallel task ID in prompt

              ### Tests
              - [ ] Test: all template variables substituted
              - [ ] Test: custom prompts override defaults
              - [ ] Test: context files loaded correctly
              - [ ] Test: output matches build-sprint-prompt.sh output

              ## Files to Create
              - plugins/m42-sprint/runtime/src/prompt-builder.ts
              - plugins/m42-sprint/runtime/src/prompt-builder.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              Read: plugins/m42-sprint/scripts/build-parallel-prompt.sh


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/prompt-builder-gherkin.md (scenarios to satisfy)
              3. context/prompt-builder-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(prompt-builder): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: "2026-01-19T23:51:51Z"
            completed-at: "2026-01-19T23:54:03Z"
            elapsed: 00:02:12
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              GIVEN build-sprint-prompt.sh (354 lines) and build-parallel-prompt.sh (82 lines)
              WHEN migrating to TypeScript
              THEN create unified prompt builder with template support

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/prompt-builder.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `buildPrompt(progress, sprintDir, customPrompts?)` → string
              - [ ] Handles regular phases, for-each steps, and sub-phases

              ### Template Variables
              - [ ] 2026-01-20_typescript-runtime-migration, typescript-runtime-migration
              - [ ] {{iteration}}
              - [ ] refactor, 3
              - [ ] prompt-builder, {{step.prompt}}, 3
              - [ ] {{subPhase.id}}, {{subPhase.index}}
              - [ ] {{retryCount}}

              ### Prompt Sections
              - [ ] Header: sprint info, iteration count
              - [ ] Position: phase/step/sub-phase indicator
              - [ ] Retry Warning: if retryCount > 0
              - [ ] Context: load and concatenate context/*.md files
              - [ ] Task: the actual prompt from phase/step
              - [ ] Instructions: general guidelines
              - [ ] Result Reporting: JSON format instructions

              ### Custom Prompts Override
              - [ ] Read prompts.header from SPRINT.yaml
              - [ ] Read prompts.position, prompts.instructions, etc.
              - [ ] Fall back to defaults if not specified

              ### Parallel Support
              - [ ] `buildParallelPrompt(...)` for parallel phases
              - [ ] Include parallel task ID in prompt

              ### Tests
              - [ ] Test: all template variables substituted
              - [ ] Test: custom prompts override defaults
              - [ ] Test: context files loaded correctly
              - [ ] Test: output matches build-sprint-prompt.sh output

              ## Files to Create
              - plugins/m42-sprint/runtime/src/prompt-builder.ts
              - plugins/m42-sprint/runtime/src/prompt-builder.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              Read: plugins/m42-sprint/scripts/build-parallel-prompt.sh


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/prompt-builder-context.md (target patterns)
              Read: artifacts/prompt-builder-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(prompt-builder): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: "2026-01-19T23:54:10Z"
            completed-at: "2026-01-19T23:57:03Z"
            elapsed: 00:02:53
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/prompt-builder-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/prompt-builder-qa-report.md

              ```markdown
              # QA Report: prompt-builder

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/prompt-builder-qa-report.md
              git commit -m "qa(prompt-builder): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for prompt-builder.\n\nRead: artifacts/prompt-builder-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/prompt-builder-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: "2026-01-19T23:57:10Z"
            completed-at: "2026-01-20T00:01:01Z"
            elapsed: 00:03:51
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              GIVEN build-sprint-prompt.sh (354 lines) and build-parallel-prompt.sh (82 lines)
              WHEN migrating to TypeScript
              THEN create unified prompt builder with template support

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/prompt-builder.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `buildPrompt(progress, sprintDir, customPrompts?)` → string
              - [ ] Handles regular phases, for-each steps, and sub-phases

              ### Template Variables
              - [ ] 2026-01-20_typescript-runtime-migration, typescript-runtime-migration
              - [ ] {{iteration}}
              - [ ] verify, 5
              - [ ] prompt-builder, {{step.prompt}}, 3
              - [ ] {{subPhase.id}}, {{subPhase.index}}
              - [ ] {{retryCount}}

              ### Prompt Sections
              - [ ] Header: sprint info, iteration count
              - [ ] Position: phase/step/sub-phase indicator
              - [ ] Retry Warning: if retryCount > 0
              - [ ] Context: load and concatenate context/*.md files
              - [ ] Task: the actual prompt from phase/step
              - [ ] Instructions: general guidelines
              - [ ] Result Reporting: JSON format instructions

              ### Custom Prompts Override
              - [ ] Read prompts.header from SPRINT.yaml
              - [ ] Read prompts.position, prompts.instructions, etc.
              - [ ] Fall back to defaults if not specified

              ### Parallel Support
              - [ ] `buildParallelPrompt(...)` for parallel phases
              - [ ] Include parallel task ID in prompt

              ### Tests
              - [ ] Test: all template variables substituted
              - [ ] Test: custom prompts override defaults
              - [ ] Test: context files loaded correctly
              - [ ] Test: output matches build-sprint-prompt.sh output

              ## Files to Create
              - plugins/m42-sprint/runtime/src/prompt-builder.ts
              - plugins/m42-sprint/runtime/src/prompt-builder.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              Read: plugins/m42-sprint/scripts/build-parallel-prompt.sh


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/prompt-builder-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(prompt-builder): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: "2026-01-20T00:01:07Z"
            completed-at: "2026-01-20T00:03:10Z"
            elapsed: 00:02:03
      - id: claude-runner
        prompt: |
          GIVEN the need to invoke Claude CLI from TypeScript
          WHEN creating the runner module
          THEN wrap Claude CLI with proper error handling and result parsing

          ## Scope
          Create NEW file: plugins/m42-sprint/runtime/src/claude-runner.ts

          ## Acceptance Criteria

          ### Main Function
          - [ ] `runClaude(options: ClaudeRunOptions)` → Promise<ClaudeResult>

          ### Options Interface
          - [ ] prompt: string (required)
          - [ ] outputFile?: string
          - [ ] maxTurns?: number
          - [ ] model?: string
          - [ ] allowedTools?: string[]
          - [ ] continueSession?: string

          ### Result Interface
          - [ ] success: boolean
          - [ ] output: string (full stdout)
          - [ ] exitCode: number
          - [ ] jsonResult?: unknown (parsed from ```json block)

          ### Implementation
          - [ ] Use child_process.spawn for Claude CLI
          - [ ] Send prompt via stdin
          - [ ] Capture stdout and stderr
          - [ ] Extract JSON from ```json blocks in output
          - [ ] Handle timeouts gracefully

          ### Error Handling
          - [ ] Detect rate-limit errors
          - [ ] Detect network errors
          - [ ] Detect timeout errors
          - [ ] Return appropriate error category

          ### Tests
          - [ ] Test: successful run returns output
          - [ ] Test: JSON extraction works
          - [ ] Test: exit code captured
          - [ ] Test: error handling (mock failures)

          ## Files to Create
          - plugins/m42-sprint/runtime/src/claude-runner.ts
          - plugins/m42-sprint/runtime/src/claude-runner.test.ts
        status: completed
        phases:
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              GIVEN the need to invoke Claude CLI from TypeScript
              WHEN creating the runner module
              THEN wrap Claude CLI with proper error handling and result parsing

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/claude-runner.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runClaude(options: ClaudeRunOptions)` → Promise<ClaudeResult>

              ### Options Interface
              - [ ] prompt: string (required)
              - [ ] outputFile?: string
              - [ ] maxTurns?: number
              - [ ] model?: string
              - [ ] allowedTools?: string[]
              - [ ] continueSession?: string

              ### Result Interface
              - [ ] success: boolean
              - [ ] output: string (full stdout)
              - [ ] exitCode: number
              - [ ] jsonResult?: unknown (parsed from ```json block)

              ### Implementation
              - [ ] Use child_process.spawn for Claude CLI
              - [ ] Send prompt via stdin
              - [ ] Capture stdout and stderr
              - [ ] Extract JSON from ```json blocks in output
              - [ ] Handle timeouts gracefully

              ### Error Handling
              - [ ] Detect rate-limit errors
              - [ ] Detect network errors
              - [ ] Detect timeout errors
              - [ ] Return appropriate error category

              ### Tests
              - [ ] Test: successful run returns output
              - [ ] Test: JSON extraction works
              - [ ] Test: exit code captured
              - [ ] Test: error handling (mock failures)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/claude-runner.ts
              - plugins/m42-sprint/runtime/src/claude-runner.test.ts


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/claude-runner-gherkin.md

              ```markdown
              # Gherkin Scenarios: claude-runner

              ## Step Task
              GIVEN the need to invoke Claude CLI from TypeScript
              WHEN creating the runner module
              THEN wrap Claude CLI with proper error handling and result parsing

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/claude-runner.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runClaude(options: ClaudeRunOptions)` → Promise<ClaudeResult>

              ### Options Interface
              - [ ] prompt: string (required)
              - [ ] outputFile?: string
              - [ ] maxTurns?: number
              - [ ] model?: string
              - [ ] allowedTools?: string[]
              - [ ] continueSession?: string

              ### Result Interface
              - [ ] success: boolean
              - [ ] output: string (full stdout)
              - [ ] exitCode: number
              - [ ] jsonResult?: unknown (parsed from ```json block)

              ### Implementation
              - [ ] Use child_process.spawn for Claude CLI
              - [ ] Send prompt via stdin
              - [ ] Capture stdout and stderr
              - [ ] Extract JSON from ```json blocks in output
              - [ ] Handle timeouts gracefully

              ### Error Handling
              - [ ] Detect rate-limit errors
              - [ ] Detect network errors
              - [ ] Detect timeout errors
              - [ ] Return appropriate error category

              ### Tests
              - [ ] Test: successful run returns output
              - [ ] Test: JSON extraction works
              - [ ] Test: exit code captured
              - [ ] Test: error handling (mock failures)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/claude-runner.ts
              - plugins/m42-sprint/runtime/src/claude-runner.test.ts


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/claude-runner-gherkin.md
              git commit -m "test(claude-runner): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: "2026-01-20T00:03:16Z"
            completed-at: "2026-01-20T00:05:57Z"
            elapsed: 00:02:41
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              GIVEN the need to invoke Claude CLI from TypeScript
              WHEN creating the runner module
              THEN wrap Claude CLI with proper error handling and result parsing

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/claude-runner.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runClaude(options: ClaudeRunOptions)` → Promise<ClaudeResult>

              ### Options Interface
              - [ ] prompt: string (required)
              - [ ] outputFile?: string
              - [ ] maxTurns?: number
              - [ ] model?: string
              - [ ] allowedTools?: string[]
              - [ ] continueSession?: string

              ### Result Interface
              - [ ] success: boolean
              - [ ] output: string (full stdout)
              - [ ] exitCode: number
              - [ ] jsonResult?: unknown (parsed from ```json block)

              ### Implementation
              - [ ] Use child_process.spawn for Claude CLI
              - [ ] Send prompt via stdin
              - [ ] Capture stdout and stderr
              - [ ] Extract JSON from ```json blocks in output
              - [ ] Handle timeouts gracefully

              ### Error Handling
              - [ ] Detect rate-limit errors
              - [ ] Detect network errors
              - [ ] Detect timeout errors
              - [ ] Return appropriate error category

              ### Tests
              - [ ] Test: successful run returns output
              - [ ] Test: JSON extraction works
              - [ ] Test: exit code captured
              - [ ] Test: error handling (mock failures)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/claude-runner.ts
              - plugins/m42-sprint/runtime/src/claude-runner.test.ts


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/claude-runner-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/claude-runner-context.md

              ```markdown
              # Step Context: claude-runner

              ## Task
              GIVEN the need to invoke Claude CLI from TypeScript
              WHEN creating the runner module
              THEN wrap Claude CLI with proper error handling and result parsing

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/claude-runner.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runClaude(options: ClaudeRunOptions)` → Promise<ClaudeResult>

              ### Options Interface
              - [ ] prompt: string (required)
              - [ ] outputFile?: string
              - [ ] maxTurns?: number
              - [ ] model?: string
              - [ ] allowedTools?: string[]
              - [ ] continueSession?: string

              ### Result Interface
              - [ ] success: boolean
              - [ ] output: string (full stdout)
              - [ ] exitCode: number
              - [ ] jsonResult?: unknown (parsed from ```json block)

              ### Implementation
              - [ ] Use child_process.spawn for Claude CLI
              - [ ] Send prompt via stdin
              - [ ] Capture stdout and stderr
              - [ ] Extract JSON from ```json blocks in output
              - [ ] Handle timeouts gracefully

              ### Error Handling
              - [ ] Detect rate-limit errors
              - [ ] Detect network errors
              - [ ] Detect timeout errors
              - [ ] Return appropriate error category

              ### Tests
              - [ ] Test: successful run returns output
              - [ ] Test: JSON extraction works
              - [ ] Test: exit code captured
              - [ ] Test: error handling (mock failures)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/claude-runner.ts
              - plugins/m42-sprint/runtime/src/claude-runner.test.ts


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/claude-runner-context.md
              git commit -m "context(claude-runner): gather implementation context"
              ```
            started-at: "2026-01-20T00:06:03Z"
            completed-at: "2026-01-20T00:07:47Z"
            elapsed: 00:01:44
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              GIVEN the need to invoke Claude CLI from TypeScript
              WHEN creating the runner module
              THEN wrap Claude CLI with proper error handling and result parsing

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/claude-runner.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runClaude(options: ClaudeRunOptions)` → Promise<ClaudeResult>

              ### Options Interface
              - [ ] prompt: string (required)
              - [ ] outputFile?: string
              - [ ] maxTurns?: number
              - [ ] model?: string
              - [ ] allowedTools?: string[]
              - [ ] continueSession?: string

              ### Result Interface
              - [ ] success: boolean
              - [ ] output: string (full stdout)
              - [ ] exitCode: number
              - [ ] jsonResult?: unknown (parsed from ```json block)

              ### Implementation
              - [ ] Use child_process.spawn for Claude CLI
              - [ ] Send prompt via stdin
              - [ ] Capture stdout and stderr
              - [ ] Extract JSON from ```json blocks in output
              - [ ] Handle timeouts gracefully

              ### Error Handling
              - [ ] Detect rate-limit errors
              - [ ] Detect network errors
              - [ ] Detect timeout errors
              - [ ] Return appropriate error category

              ### Tests
              - [ ] Test: successful run returns output
              - [ ] Test: JSON extraction works
              - [ ] Test: exit code captured
              - [ ] Test: error handling (mock failures)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/claude-runner.ts
              - plugins/m42-sprint/runtime/src/claude-runner.test.ts


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/claude-runner-gherkin.md (scenarios to satisfy)
              3. context/claude-runner-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(claude-runner): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: "2026-01-20T00:07:54Z"
            completed-at: "2026-01-20T00:09:57Z"
            elapsed: 00:02:03
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              GIVEN the need to invoke Claude CLI from TypeScript
              WHEN creating the runner module
              THEN wrap Claude CLI with proper error handling and result parsing

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/claude-runner.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runClaude(options: ClaudeRunOptions)` → Promise<ClaudeResult>

              ### Options Interface
              - [ ] prompt: string (required)
              - [ ] outputFile?: string
              - [ ] maxTurns?: number
              - [ ] model?: string
              - [ ] allowedTools?: string[]
              - [ ] continueSession?: string

              ### Result Interface
              - [ ] success: boolean
              - [ ] output: string (full stdout)
              - [ ] exitCode: number
              - [ ] jsonResult?: unknown (parsed from ```json block)

              ### Implementation
              - [ ] Use child_process.spawn for Claude CLI
              - [ ] Send prompt via stdin
              - [ ] Capture stdout and stderr
              - [ ] Extract JSON from ```json blocks in output
              - [ ] Handle timeouts gracefully

              ### Error Handling
              - [ ] Detect rate-limit errors
              - [ ] Detect network errors
              - [ ] Detect timeout errors
              - [ ] Return appropriate error category

              ### Tests
              - [ ] Test: successful run returns output
              - [ ] Test: JSON extraction works
              - [ ] Test: exit code captured
              - [ ] Test: error handling (mock failures)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/claude-runner.ts
              - plugins/m42-sprint/runtime/src/claude-runner.test.ts


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/claude-runner-context.md (target patterns)
              Read: artifacts/claude-runner-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(claude-runner): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: "2026-01-20T00:10:03Z"
            completed-at: "2026-01-20T00:11:42Z"
            elapsed: 00:01:39
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/claude-runner-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/claude-runner-qa-report.md

              ```markdown
              # QA Report: claude-runner

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/claude-runner-qa-report.md
              git commit -m "qa(claude-runner): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for claude-runner.\n\nRead: artifacts/claude-runner-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/claude-runner-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: "2026-01-20T00:11:49Z"
            completed-at: "2026-01-20T00:13:35Z"
            elapsed: 00:01:46
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              GIVEN the need to invoke Claude CLI from TypeScript
              WHEN creating the runner module
              THEN wrap Claude CLI with proper error handling and result parsing

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/claude-runner.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runClaude(options: ClaudeRunOptions)` → Promise<ClaudeResult>

              ### Options Interface
              - [ ] prompt: string (required)
              - [ ] outputFile?: string
              - [ ] maxTurns?: number
              - [ ] model?: string
              - [ ] allowedTools?: string[]
              - [ ] continueSession?: string

              ### Result Interface
              - [ ] success: boolean
              - [ ] output: string (full stdout)
              - [ ] exitCode: number
              - [ ] jsonResult?: unknown (parsed from ```json block)

              ### Implementation
              - [ ] Use child_process.spawn for Claude CLI
              - [ ] Send prompt via stdin
              - [ ] Capture stdout and stderr
              - [ ] Extract JSON from ```json blocks in output
              - [ ] Handle timeouts gracefully

              ### Error Handling
              - [ ] Detect rate-limit errors
              - [ ] Detect network errors
              - [ ] Detect timeout errors
              - [ ] Return appropriate error category

              ### Tests
              - [ ] Test: successful run returns output
              - [ ] Test: JSON extraction works
              - [ ] Test: exit code captured
              - [ ] Test: error handling (mock failures)

              ## Files to Create
              - plugins/m42-sprint/runtime/src/claude-runner.ts
              - plugins/m42-sprint/runtime/src/claude-runner.test.ts


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/claude-runner-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(claude-runner): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: "2026-01-20T00:13:41Z"
            completed-at: "2026-01-20T00:14:42Z"
            elapsed: 00:01:01
      - id: executor
        prompt: |
          GIVEN the SprintAction types and support modules (yaml-ops, prompt-builder, claude-runner)
          WHEN implementing the executor
          THEN map each action type to its implementation

          ## Scope
          Create NEW file: plugins/m42-sprint/runtime/src/executor.ts

          ## Acceptance Criteria

          ### Main Functions
          - [ ] `executeAction(action: SprintAction, context: ExecutorContext)` → Promise<SprintEvent | null>
          - [ ] `executeActions(actions: SprintAction[], context)` → Promise<SprintEvent[]>

          ### Action Implementations
          - [ ] LOG → console.log/warn/error based on level
          - [ ] SPAWN_CLAUDE → call claude-runner, return PHASE_COMPLETE or PHASE_FAILED
          - [ ] WRITE_PROGRESS → call yaml-ops.writeProgressAtomic
          - [ ] UPDATE_STATS → update in-memory context (will be persisted by WRITE_PROGRESS)
          - [ ] EMIT_ACTIVITY → append to .sprint-activity.jsonl
          - [ ] SCHEDULE_RETRY → sleep for delayMs, return event to retry
          - [ ] INSERT_STEP → update progress.phases with new step

          ### ExecutorContext Interface
          - [ ] sprintDir: string
          - [ ] progress: CompiledProgress (mutable reference)
          - [ ] verbose: boolean

          ### Type Safety
          - [ ] Exhaustive switch with `never` check
          - [ ] TypeScript error if action type missing

          ### Tests
          - [ ] Unit test for each action type
          - [ ] Mock claude-runner for SPAWN_CLAUDE tests
          - [ ] Mock fs for WRITE_PROGRESS tests
          - [ ] Test: executeActions runs in sequence

          ## Files to Create
          - plugins/m42-sprint/runtime/src/executor.ts
          - plugins/m42-sprint/runtime/src/executor.test.ts

          ## Context
          Read: context/xstate-patterns-plan.md (Phase 3 section)
        status: completed
        phases:
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              GIVEN the SprintAction types and support modules (yaml-ops, prompt-builder, claude-runner)
              WHEN implementing the executor
              THEN map each action type to its implementation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/executor.ts

              ## Acceptance Criteria

              ### Main Functions
              - [ ] `executeAction(action: SprintAction, context: ExecutorContext)` → Promise<SprintEvent | null>
              - [ ] `executeActions(actions: SprintAction[], context)` → Promise<SprintEvent[]>

              ### Action Implementations
              - [ ] LOG → console.log/warn/error based on level
              - [ ] SPAWN_CLAUDE → call claude-runner, return PHASE_COMPLETE or PHASE_FAILED
              - [ ] WRITE_PROGRESS → call yaml-ops.writeProgressAtomic
              - [ ] UPDATE_STATS → update in-memory context (will be persisted by WRITE_PROGRESS)
              - [ ] EMIT_ACTIVITY → append to .sprint-activity.jsonl
              - [ ] SCHEDULE_RETRY → sleep for delayMs, return event to retry
              - [ ] INSERT_STEP → update progress.phases with new step

              ### ExecutorContext Interface
              - [ ] sprintDir: string
              - [ ] progress: CompiledProgress (mutable reference)
              - [ ] verbose: boolean

              ### Type Safety
              - [ ] Exhaustive switch with `never` check
              - [ ] TypeScript error if action type missing

              ### Tests
              - [ ] Unit test for each action type
              - [ ] Mock claude-runner for SPAWN_CLAUDE tests
              - [ ] Mock fs for WRITE_PROGRESS tests
              - [ ] Test: executeActions runs in sequence

              ## Files to Create
              - plugins/m42-sprint/runtime/src/executor.ts
              - plugins/m42-sprint/runtime/src/executor.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 3 section)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/executor-gherkin.md

              ```markdown
              # Gherkin Scenarios: executor

              ## Step Task
              GIVEN the SprintAction types and support modules (yaml-ops, prompt-builder, claude-runner)
              WHEN implementing the executor
              THEN map each action type to its implementation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/executor.ts

              ## Acceptance Criteria

              ### Main Functions
              - [ ] `executeAction(action: SprintAction, context: ExecutorContext)` → Promise<SprintEvent | null>
              - [ ] `executeActions(actions: SprintAction[], context)` → Promise<SprintEvent[]>

              ### Action Implementations
              - [ ] LOG → console.log/warn/error based on level
              - [ ] SPAWN_CLAUDE → call claude-runner, return PHASE_COMPLETE or PHASE_FAILED
              - [ ] WRITE_PROGRESS → call yaml-ops.writeProgressAtomic
              - [ ] UPDATE_STATS → update in-memory context (will be persisted by WRITE_PROGRESS)
              - [ ] EMIT_ACTIVITY → append to .sprint-activity.jsonl
              - [ ] SCHEDULE_RETRY → sleep for delayMs, return event to retry
              - [ ] INSERT_STEP → update progress.phases with new step

              ### ExecutorContext Interface
              - [ ] sprintDir: string
              - [ ] progress: CompiledProgress (mutable reference)
              - [ ] verbose: boolean

              ### Type Safety
              - [ ] Exhaustive switch with `never` check
              - [ ] TypeScript error if action type missing

              ### Tests
              - [ ] Unit test for each action type
              - [ ] Mock claude-runner for SPAWN_CLAUDE tests
              - [ ] Mock fs for WRITE_PROGRESS tests
              - [ ] Test: executeActions runs in sequence

              ## Files to Create
              - plugins/m42-sprint/runtime/src/executor.ts
              - plugins/m42-sprint/runtime/src/executor.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 3 section)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/executor-gherkin.md
              git commit -m "test(executor): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: "2026-01-20T00:14:48Z"
            completed-at: "2026-01-20T00:19:16Z"
            elapsed: 00:04:28
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              GIVEN the SprintAction types and support modules (yaml-ops, prompt-builder, claude-runner)
              WHEN implementing the executor
              THEN map each action type to its implementation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/executor.ts

              ## Acceptance Criteria

              ### Main Functions
              - [ ] `executeAction(action: SprintAction, context: ExecutorContext)` → Promise<SprintEvent | null>
              - [ ] `executeActions(actions: SprintAction[], context)` → Promise<SprintEvent[]>

              ### Action Implementations
              - [ ] LOG → console.log/warn/error based on level
              - [ ] SPAWN_CLAUDE → call claude-runner, return PHASE_COMPLETE or PHASE_FAILED
              - [ ] WRITE_PROGRESS → call yaml-ops.writeProgressAtomic
              - [ ] UPDATE_STATS → update in-memory context (will be persisted by WRITE_PROGRESS)
              - [ ] EMIT_ACTIVITY → append to .sprint-activity.jsonl
              - [ ] SCHEDULE_RETRY → sleep for delayMs, return event to retry
              - [ ] INSERT_STEP → update progress.phases with new step

              ### ExecutorContext Interface
              - [ ] sprintDir: string
              - [ ] progress: CompiledProgress (mutable reference)
              - [ ] verbose: boolean

              ### Type Safety
              - [ ] Exhaustive switch with `never` check
              - [ ] TypeScript error if action type missing

              ### Tests
              - [ ] Unit test for each action type
              - [ ] Mock claude-runner for SPAWN_CLAUDE tests
              - [ ] Mock fs for WRITE_PROGRESS tests
              - [ ] Test: executeActions runs in sequence

              ## Files to Create
              - plugins/m42-sprint/runtime/src/executor.ts
              - plugins/m42-sprint/runtime/src/executor.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 3 section)


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/executor-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/executor-context.md

              ```markdown
              # Step Context: executor

              ## Task
              GIVEN the SprintAction types and support modules (yaml-ops, prompt-builder, claude-runner)
              WHEN implementing the executor
              THEN map each action type to its implementation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/executor.ts

              ## Acceptance Criteria

              ### Main Functions
              - [ ] `executeAction(action: SprintAction, context: ExecutorContext)` → Promise<SprintEvent | null>
              - [ ] `executeActions(actions: SprintAction[], context)` → Promise<SprintEvent[]>

              ### Action Implementations
              - [ ] LOG → console.log/warn/error based on level
              - [ ] SPAWN_CLAUDE → call claude-runner, return PHASE_COMPLETE or PHASE_FAILED
              - [ ] WRITE_PROGRESS → call yaml-ops.writeProgressAtomic
              - [ ] UPDATE_STATS → update in-memory context (will be persisted by WRITE_PROGRESS)
              - [ ] EMIT_ACTIVITY → append to .sprint-activity.jsonl
              - [ ] SCHEDULE_RETRY → sleep for delayMs, return event to retry
              - [ ] INSERT_STEP → update progress.phases with new step

              ### ExecutorContext Interface
              - [ ] sprintDir: string
              - [ ] progress: CompiledProgress (mutable reference)
              - [ ] verbose: boolean

              ### Type Safety
              - [ ] Exhaustive switch with `never` check
              - [ ] TypeScript error if action type missing

              ### Tests
              - [ ] Unit test for each action type
              - [ ] Mock claude-runner for SPAWN_CLAUDE tests
              - [ ] Mock fs for WRITE_PROGRESS tests
              - [ ] Test: executeActions runs in sequence

              ## Files to Create
              - plugins/m42-sprint/runtime/src/executor.ts
              - plugins/m42-sprint/runtime/src/executor.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 3 section)


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/executor-context.md
              git commit -m "context(executor): gather implementation context"
              ```
            started-at: "2026-01-20T00:19:23Z"
            completed-at: "2026-01-20T00:21:19Z"
            elapsed: 00:01:56
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              GIVEN the SprintAction types and support modules (yaml-ops, prompt-builder, claude-runner)
              WHEN implementing the executor
              THEN map each action type to its implementation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/executor.ts

              ## Acceptance Criteria

              ### Main Functions
              - [ ] `executeAction(action: SprintAction, context: ExecutorContext)` → Promise<SprintEvent | null>
              - [ ] `executeActions(actions: SprintAction[], context)` → Promise<SprintEvent[]>

              ### Action Implementations
              - [ ] LOG → console.log/warn/error based on level
              - [ ] SPAWN_CLAUDE → call claude-runner, return PHASE_COMPLETE or PHASE_FAILED
              - [ ] WRITE_PROGRESS → call yaml-ops.writeProgressAtomic
              - [ ] UPDATE_STATS → update in-memory context (will be persisted by WRITE_PROGRESS)
              - [ ] EMIT_ACTIVITY → append to .sprint-activity.jsonl
              - [ ] SCHEDULE_RETRY → sleep for delayMs, return event to retry
              - [ ] INSERT_STEP → update progress.phases with new step

              ### ExecutorContext Interface
              - [ ] sprintDir: string
              - [ ] progress: CompiledProgress (mutable reference)
              - [ ] verbose: boolean

              ### Type Safety
              - [ ] Exhaustive switch with `never` check
              - [ ] TypeScript error if action type missing

              ### Tests
              - [ ] Unit test for each action type
              - [ ] Mock claude-runner for SPAWN_CLAUDE tests
              - [ ] Mock fs for WRITE_PROGRESS tests
              - [ ] Test: executeActions runs in sequence

              ## Files to Create
              - plugins/m42-sprint/runtime/src/executor.ts
              - plugins/m42-sprint/runtime/src/executor.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 3 section)


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/executor-gherkin.md (scenarios to satisfy)
              3. context/executor-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(executor): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: "2026-01-20T00:21:26Z"
            completed-at: "2026-01-20T00:32:27Z"
            elapsed: 00:11:01
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              GIVEN the SprintAction types and support modules (yaml-ops, prompt-builder, claude-runner)
              WHEN implementing the executor
              THEN map each action type to its implementation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/executor.ts

              ## Acceptance Criteria

              ### Main Functions
              - [ ] `executeAction(action: SprintAction, context: ExecutorContext)` → Promise<SprintEvent | null>
              - [ ] `executeActions(actions: SprintAction[], context)` → Promise<SprintEvent[]>

              ### Action Implementations
              - [ ] LOG → console.log/warn/error based on level
              - [ ] SPAWN_CLAUDE → call claude-runner, return PHASE_COMPLETE or PHASE_FAILED
              - [ ] WRITE_PROGRESS → call yaml-ops.writeProgressAtomic
              - [ ] UPDATE_STATS → update in-memory context (will be persisted by WRITE_PROGRESS)
              - [ ] EMIT_ACTIVITY → append to .sprint-activity.jsonl
              - [ ] SCHEDULE_RETRY → sleep for delayMs, return event to retry
              - [ ] INSERT_STEP → update progress.phases with new step

              ### ExecutorContext Interface
              - [ ] sprintDir: string
              - [ ] progress: CompiledProgress (mutable reference)
              - [ ] verbose: boolean

              ### Type Safety
              - [ ] Exhaustive switch with `never` check
              - [ ] TypeScript error if action type missing

              ### Tests
              - [ ] Unit test for each action type
              - [ ] Mock claude-runner for SPAWN_CLAUDE tests
              - [ ] Mock fs for WRITE_PROGRESS tests
              - [ ] Test: executeActions runs in sequence

              ## Files to Create
              - plugins/m42-sprint/runtime/src/executor.ts
              - plugins/m42-sprint/runtime/src/executor.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 3 section)


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/executor-context.md (target patterns)
              Read: artifacts/executor-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(executor): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: "2026-01-20T00:32:33Z"
            completed-at: "2026-01-20T00:37:28Z"
            elapsed: 00:04:55
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/executor-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/executor-qa-report.md

              ```markdown
              # QA Report: executor

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/executor-qa-report.md
              git commit -m "qa(executor): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for executor.\n\nRead: artifacts/executor-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/executor-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: "2026-01-20T00:37:34Z"
            completed-at: "2026-01-20T00:43:40Z"
            elapsed: 00:06:06
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              GIVEN the SprintAction types and support modules (yaml-ops, prompt-builder, claude-runner)
              WHEN implementing the executor
              THEN map each action type to its implementation

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/executor.ts

              ## Acceptance Criteria

              ### Main Functions
              - [ ] `executeAction(action: SprintAction, context: ExecutorContext)` → Promise<SprintEvent | null>
              - [ ] `executeActions(actions: SprintAction[], context)` → Promise<SprintEvent[]>

              ### Action Implementations
              - [ ] LOG → console.log/warn/error based on level
              - [ ] SPAWN_CLAUDE → call claude-runner, return PHASE_COMPLETE or PHASE_FAILED
              - [ ] WRITE_PROGRESS → call yaml-ops.writeProgressAtomic
              - [ ] UPDATE_STATS → update in-memory context (will be persisted by WRITE_PROGRESS)
              - [ ] EMIT_ACTIVITY → append to .sprint-activity.jsonl
              - [ ] SCHEDULE_RETRY → sleep for delayMs, return event to retry
              - [ ] INSERT_STEP → update progress.phases with new step

              ### ExecutorContext Interface
              - [ ] sprintDir: string
              - [ ] progress: CompiledProgress (mutable reference)
              - [ ] verbose: boolean

              ### Type Safety
              - [ ] Exhaustive switch with `never` check
              - [ ] TypeScript error if action type missing

              ### Tests
              - [ ] Unit test for each action type
              - [ ] Mock claude-runner for SPAWN_CLAUDE tests
              - [ ] Mock fs for WRITE_PROGRESS tests
              - [ ] Test: executeActions runs in sequence

              ## Files to Create
              - plugins/m42-sprint/runtime/src/executor.ts
              - plugins/m42-sprint/runtime/src/executor.test.ts

              ## Context
              Read: context/xstate-patterns-plan.md (Phase 3 section)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/executor-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(executor): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: "2026-01-20T00:43:46Z"
            completed-at: "2026-01-20T00:45:27Z"
            elapsed: 00:01:41
      - id: main-loop
        prompt: |
          GIVEN all support modules (transition, yaml-ops, prompt-builder, claude-runner, executor)
          WHEN implementing the main sprint loop
          THEN replace sprint-loop.sh (2,464 lines) with TypeScript

          ## Scope
          Create NEW file: plugins/m42-sprint/runtime/src/loop.ts

          ## Acceptance Criteria

          ### Main Function
          - [ ] `runLoop(sprintDir: string, options: LoopOptions)` → Promise<SprintState>

          ### Options
          - [ ] maxIterations?: number (0 = unlimited)
          - [ ] delay?: number (ms between iterations, default 2000)
          - [ ] verbose?: boolean

          ### Loop Logic
          1. [ ] Recover from interrupted transaction on startup
          2. [ ] Load PROGRESS.yaml via yaml-ops
          3. [ ] Restore SprintState from progress
          4. [ ] While not terminal state:
             - [ ] Check max iterations
             - [ ] Check pause signal (PAUSE file in sprint dir)
             - [ ] Backup progress (transaction start)
             - [ ] Determine next event based on state
             - [ ] Call transition(state, event, context)
             - [ ] Execute actions via executor
             - [ ] Process resulting events recursively
             - [ ] Write progress (transaction commit)
             - [ ] Clean up backup
             - [ ] Sleep delay

          ### Terminal States
          - [ ] 'completed', 'blocked', 'paused', 'needs-human'

          ### Recovery
          - [ ] `recoverFromInterrupt(progressPath)` → void
          - [ ] Check for .backup file on startup
          - [ ] Validate checksum, restore if needed

          ### Logging
          - [ ] Log iteration start/end
          - [ ] Log state transitions
          - [ ] Log errors with context

          ### Tests
          - [ ] Integration test: full loop with mock Claude
          - [ ] Test: pause signal stops loop
          - [ ] Test: max iterations enforced
          - [ ] Test: crash recovery works
          - [ ] Test: behavior matches sprint-loop.sh

          ## Files to Create
          - plugins/m42-sprint/runtime/src/loop.ts
          - plugins/m42-sprint/runtime/src/loop.test.ts

          ## Reference
          Read: plugins/m42-sprint/scripts/sprint-loop.sh (the whole file)
        status: completed
        phases:
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              GIVEN all support modules (transition, yaml-ops, prompt-builder, claude-runner, executor)
              WHEN implementing the main sprint loop
              THEN replace sprint-loop.sh (2,464 lines) with TypeScript

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/loop.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runLoop(sprintDir: string, options: LoopOptions)` → Promise<SprintState>

              ### Options
              - [ ] maxIterations?: number (0 = unlimited)
              - [ ] delay?: number (ms between iterations, default 2000)
              - [ ] verbose?: boolean

              ### Loop Logic
              1. [ ] Recover from interrupted transaction on startup
              2. [ ] Load PROGRESS.yaml via yaml-ops
              3. [ ] Restore SprintState from progress
              4. [ ] While not terminal state:
                 - [ ] Check max iterations
                 - [ ] Check pause signal (PAUSE file in sprint dir)
                 - [ ] Backup progress (transaction start)
                 - [ ] Determine next event based on state
                 - [ ] Call transition(state, event, context)
                 - [ ] Execute actions via executor
                 - [ ] Process resulting events recursively
                 - [ ] Write progress (transaction commit)
                 - [ ] Clean up backup
                 - [ ] Sleep delay

              ### Terminal States
              - [ ] 'completed', 'blocked', 'paused', 'needs-human'

              ### Recovery
              - [ ] `recoverFromInterrupt(progressPath)` → void
              - [ ] Check for .backup file on startup
              - [ ] Validate checksum, restore if needed

              ### Logging
              - [ ] Log iteration start/end
              - [ ] Log state transitions
              - [ ] Log errors with context

              ### Tests
              - [ ] Integration test: full loop with mock Claude
              - [ ] Test: pause signal stops loop
              - [ ] Test: max iterations enforced
              - [ ] Test: crash recovery works
              - [ ] Test: behavior matches sprint-loop.sh

              ## Files to Create
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/loop.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/sprint-loop.sh (the whole file)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/main-loop-gherkin.md

              ```markdown
              # Gherkin Scenarios: main-loop

              ## Step Task
              GIVEN all support modules (transition, yaml-ops, prompt-builder, claude-runner, executor)
              WHEN implementing the main sprint loop
              THEN replace sprint-loop.sh (2,464 lines) with TypeScript

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/loop.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runLoop(sprintDir: string, options: LoopOptions)` → Promise<SprintState>

              ### Options
              - [ ] maxIterations?: number (0 = unlimited)
              - [ ] delay?: number (ms between iterations, default 2000)
              - [ ] verbose?: boolean

              ### Loop Logic
              1. [ ] Recover from interrupted transaction on startup
              2. [ ] Load PROGRESS.yaml via yaml-ops
              3. [ ] Restore SprintState from progress
              4. [ ] While not terminal state:
                 - [ ] Check max iterations
                 - [ ] Check pause signal (PAUSE file in sprint dir)
                 - [ ] Backup progress (transaction start)
                 - [ ] Determine next event based on state
                 - [ ] Call transition(state, event, context)
                 - [ ] Execute actions via executor
                 - [ ] Process resulting events recursively
                 - [ ] Write progress (transaction commit)
                 - [ ] Clean up backup
                 - [ ] Sleep delay

              ### Terminal States
              - [ ] 'completed', 'blocked', 'paused', 'needs-human'

              ### Recovery
              - [ ] `recoverFromInterrupt(progressPath)` → void
              - [ ] Check for .backup file on startup
              - [ ] Validate checksum, restore if needed

              ### Logging
              - [ ] Log iteration start/end
              - [ ] Log state transitions
              - [ ] Log errors with context

              ### Tests
              - [ ] Integration test: full loop with mock Claude
              - [ ] Test: pause signal stops loop
              - [ ] Test: max iterations enforced
              - [ ] Test: crash recovery works
              - [ ] Test: behavior matches sprint-loop.sh

              ## Files to Create
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/loop.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/sprint-loop.sh (the whole file)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/main-loop-gherkin.md
              git commit -m "test(main-loop): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: "2026-01-20T00:45:34Z"
            completed-at: "2026-01-20T00:49:42Z"
            elapsed: 00:04:08
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              GIVEN all support modules (transition, yaml-ops, prompt-builder, claude-runner, executor)
              WHEN implementing the main sprint loop
              THEN replace sprint-loop.sh (2,464 lines) with TypeScript

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/loop.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runLoop(sprintDir: string, options: LoopOptions)` → Promise<SprintState>

              ### Options
              - [ ] maxIterations?: number (0 = unlimited)
              - [ ] delay?: number (ms between iterations, default 2000)
              - [ ] verbose?: boolean

              ### Loop Logic
              1. [ ] Recover from interrupted transaction on startup
              2. [ ] Load PROGRESS.yaml via yaml-ops
              3. [ ] Restore SprintState from progress
              4. [ ] While not terminal state:
                 - [ ] Check max iterations
                 - [ ] Check pause signal (PAUSE file in sprint dir)
                 - [ ] Backup progress (transaction start)
                 - [ ] Determine next event based on state
                 - [ ] Call transition(state, event, context)
                 - [ ] Execute actions via executor
                 - [ ] Process resulting events recursively
                 - [ ] Write progress (transaction commit)
                 - [ ] Clean up backup
                 - [ ] Sleep delay

              ### Terminal States
              - [ ] 'completed', 'blocked', 'paused', 'needs-human'

              ### Recovery
              - [ ] `recoverFromInterrupt(progressPath)` → void
              - [ ] Check for .backup file on startup
              - [ ] Validate checksum, restore if needed

              ### Logging
              - [ ] Log iteration start/end
              - [ ] Log state transitions
              - [ ] Log errors with context

              ### Tests
              - [ ] Integration test: full loop with mock Claude
              - [ ] Test: pause signal stops loop
              - [ ] Test: max iterations enforced
              - [ ] Test: crash recovery works
              - [ ] Test: behavior matches sprint-loop.sh

              ## Files to Create
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/loop.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/sprint-loop.sh (the whole file)


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/main-loop-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/main-loop-context.md

              ```markdown
              # Step Context: main-loop

              ## Task
              GIVEN all support modules (transition, yaml-ops, prompt-builder, claude-runner, executor)
              WHEN implementing the main sprint loop
              THEN replace sprint-loop.sh (2,464 lines) with TypeScript

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/loop.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runLoop(sprintDir: string, options: LoopOptions)` → Promise<SprintState>

              ### Options
              - [ ] maxIterations?: number (0 = unlimited)
              - [ ] delay?: number (ms between iterations, default 2000)
              - [ ] verbose?: boolean

              ### Loop Logic
              1. [ ] Recover from interrupted transaction on startup
              2. [ ] Load PROGRESS.yaml via yaml-ops
              3. [ ] Restore SprintState from progress
              4. [ ] While not terminal state:
                 - [ ] Check max iterations
                 - [ ] Check pause signal (PAUSE file in sprint dir)
                 - [ ] Backup progress (transaction start)
                 - [ ] Determine next event based on state
                 - [ ] Call transition(state, event, context)
                 - [ ] Execute actions via executor
                 - [ ] Process resulting events recursively
                 - [ ] Write progress (transaction commit)
                 - [ ] Clean up backup
                 - [ ] Sleep delay

              ### Terminal States
              - [ ] 'completed', 'blocked', 'paused', 'needs-human'

              ### Recovery
              - [ ] `recoverFromInterrupt(progressPath)` → void
              - [ ] Check for .backup file on startup
              - [ ] Validate checksum, restore if needed

              ### Logging
              - [ ] Log iteration start/end
              - [ ] Log state transitions
              - [ ] Log errors with context

              ### Tests
              - [ ] Integration test: full loop with mock Claude
              - [ ] Test: pause signal stops loop
              - [ ] Test: max iterations enforced
              - [ ] Test: crash recovery works
              - [ ] Test: behavior matches sprint-loop.sh

              ## Files to Create
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/loop.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/sprint-loop.sh (the whole file)


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/main-loop-context.md
              git commit -m "context(main-loop): gather implementation context"
              ```
            started-at: "2026-01-20T00:49:49Z"
            completed-at: "2026-01-20T00:52:12Z"
            elapsed: 00:02:23
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              GIVEN all support modules (transition, yaml-ops, prompt-builder, claude-runner, executor)
              WHEN implementing the main sprint loop
              THEN replace sprint-loop.sh (2,464 lines) with TypeScript

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/loop.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runLoop(sprintDir: string, options: LoopOptions)` → Promise<SprintState>

              ### Options
              - [ ] maxIterations?: number (0 = unlimited)
              - [ ] delay?: number (ms between iterations, default 2000)
              - [ ] verbose?: boolean

              ### Loop Logic
              1. [ ] Recover from interrupted transaction on startup
              2. [ ] Load PROGRESS.yaml via yaml-ops
              3. [ ] Restore SprintState from progress
              4. [ ] While not terminal state:
                 - [ ] Check max iterations
                 - [ ] Check pause signal (PAUSE file in sprint dir)
                 - [ ] Backup progress (transaction start)
                 - [ ] Determine next event based on state
                 - [ ] Call transition(state, event, context)
                 - [ ] Execute actions via executor
                 - [ ] Process resulting events recursively
                 - [ ] Write progress (transaction commit)
                 - [ ] Clean up backup
                 - [ ] Sleep delay

              ### Terminal States
              - [ ] 'completed', 'blocked', 'paused', 'needs-human'

              ### Recovery
              - [ ] `recoverFromInterrupt(progressPath)` → void
              - [ ] Check for .backup file on startup
              - [ ] Validate checksum, restore if needed

              ### Logging
              - [ ] Log iteration start/end
              - [ ] Log state transitions
              - [ ] Log errors with context

              ### Tests
              - [ ] Integration test: full loop with mock Claude
              - [ ] Test: pause signal stops loop
              - [ ] Test: max iterations enforced
              - [ ] Test: crash recovery works
              - [ ] Test: behavior matches sprint-loop.sh

              ## Files to Create
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/loop.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/sprint-loop.sh (the whole file)


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/main-loop-gherkin.md (scenarios to satisfy)
              3. context/main-loop-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(main-loop): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: "2026-01-20T00:52:19Z"
            completed-at: "2026-01-20T00:57:12Z"
            elapsed: 00:04:53
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              GIVEN all support modules (transition, yaml-ops, prompt-builder, claude-runner, executor)
              WHEN implementing the main sprint loop
              THEN replace sprint-loop.sh (2,464 lines) with TypeScript

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/loop.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runLoop(sprintDir: string, options: LoopOptions)` → Promise<SprintState>

              ### Options
              - [ ] maxIterations?: number (0 = unlimited)
              - [ ] delay?: number (ms between iterations, default 2000)
              - [ ] verbose?: boolean

              ### Loop Logic
              1. [ ] Recover from interrupted transaction on startup
              2. [ ] Load PROGRESS.yaml via yaml-ops
              3. [ ] Restore SprintState from progress
              4. [ ] While not terminal state:
                 - [ ] Check max iterations
                 - [ ] Check pause signal (PAUSE file in sprint dir)
                 - [ ] Backup progress (transaction start)
                 - [ ] Determine next event based on state
                 - [ ] Call transition(state, event, context)
                 - [ ] Execute actions via executor
                 - [ ] Process resulting events recursively
                 - [ ] Write progress (transaction commit)
                 - [ ] Clean up backup
                 - [ ] Sleep delay

              ### Terminal States
              - [ ] 'completed', 'blocked', 'paused', 'needs-human'

              ### Recovery
              - [ ] `recoverFromInterrupt(progressPath)` → void
              - [ ] Check for .backup file on startup
              - [ ] Validate checksum, restore if needed

              ### Logging
              - [ ] Log iteration start/end
              - [ ] Log state transitions
              - [ ] Log errors with context

              ### Tests
              - [ ] Integration test: full loop with mock Claude
              - [ ] Test: pause signal stops loop
              - [ ] Test: max iterations enforced
              - [ ] Test: crash recovery works
              - [ ] Test: behavior matches sprint-loop.sh

              ## Files to Create
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/loop.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/sprint-loop.sh (the whole file)


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/main-loop-context.md (target patterns)
              Read: artifacts/main-loop-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(main-loop): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: "2026-01-20T00:57:18Z"
            completed-at: "2026-01-20T01:03:19Z"
            elapsed: 00:06:01
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/main-loop-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/main-loop-qa-report.md

              ```markdown
              # QA Report: main-loop

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/main-loop-qa-report.md
              git commit -m "qa(main-loop): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for main-loop.\n\nRead: artifacts/main-loop-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/main-loop-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: "2026-01-20T01:03:26Z"
            completed-at: "2026-01-20T01:06:10Z"
            elapsed: 00:02:44
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              GIVEN all support modules (transition, yaml-ops, prompt-builder, claude-runner, executor)
              WHEN implementing the main sprint loop
              THEN replace sprint-loop.sh (2,464 lines) with TypeScript

              ## Scope
              Create NEW file: plugins/m42-sprint/runtime/src/loop.ts

              ## Acceptance Criteria

              ### Main Function
              - [ ] `runLoop(sprintDir: string, options: LoopOptions)` → Promise<SprintState>

              ### Options
              - [ ] maxIterations?: number (0 = unlimited)
              - [ ] delay?: number (ms between iterations, default 2000)
              - [ ] verbose?: boolean

              ### Loop Logic
              1. [ ] Recover from interrupted transaction on startup
              2. [ ] Load PROGRESS.yaml via yaml-ops
              3. [ ] Restore SprintState from progress
              4. [ ] While not terminal state:
                 - [ ] Check max iterations
                 - [ ] Check pause signal (PAUSE file in sprint dir)
                 - [ ] Backup progress (transaction start)
                 - [ ] Determine next event based on state
                 - [ ] Call transition(state, event, context)
                 - [ ] Execute actions via executor
                 - [ ] Process resulting events recursively
                 - [ ] Write progress (transaction commit)
                 - [ ] Clean up backup
                 - [ ] Sleep delay

              ### Terminal States
              - [ ] 'completed', 'blocked', 'paused', 'needs-human'

              ### Recovery
              - [ ] `recoverFromInterrupt(progressPath)` → void
              - [ ] Check for .backup file on startup
              - [ ] Validate checksum, restore if needed

              ### Logging
              - [ ] Log iteration start/end
              - [ ] Log state transitions
              - [ ] Log errors with context

              ### Tests
              - [ ] Integration test: full loop with mock Claude
              - [ ] Test: pause signal stops loop
              - [ ] Test: max iterations enforced
              - [ ] Test: crash recovery works
              - [ ] Test: behavior matches sprint-loop.sh

              ## Files to Create
              - plugins/m42-sprint/runtime/src/loop.ts
              - plugins/m42-sprint/runtime/src/loop.test.ts

              ## Reference
              Read: plugins/m42-sprint/scripts/sprint-loop.sh (the whole file)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/main-loop-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(main-loop): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: "2026-01-20T01:06:17Z"
            completed-at: "2026-01-20T01:08:29Z"
            elapsed: 00:02:12
      - id: cli-entrypoint
        prompt: |
          GIVEN the TypeScript runtime modules
          WHEN creating the CLI entry point
          THEN provide commands matching current bash interface

          ## Scope
          - Create CLI entry point
          - Set up runtime package.json
          - Configure build and test scripts

          ## Acceptance Criteria

          ### Package Setup
          - [ ] Create plugins/m42-sprint/runtime/package.json
          - [ ] Dependencies: js-yaml, commander
          - [ ] DevDependencies: typescript, vitest, @types/*
          - [ ] Scripts: build, test, typecheck

          ### CLI Entry Point
          - [ ] Create plugins/m42-sprint/runtime/src/cli.ts
          - [ ] `sprint run <dir>` - run sprint loop
          - [ ] `--max-iterations <n>` option
          - [ ] `--delay <ms>` option
          - [ ] `-v, --verbose` option
          - [ ] Exit code 0 on success, 1 on failure

          ### Build Setup
          - [ ] tsconfig.json for runtime
          - [ ] Output to dist/
          - [ ] Shebang for CLI: #!/usr/bin/env node

          ### Integration
          - [ ] Update root package.json with workspace reference
          - [ ] npm run build works from root
          - [ ] npm run test works from root

          ## Files to Create
          - plugins/m42-sprint/runtime/package.json
          - plugins/m42-sprint/runtime/tsconfig.json
          - plugins/m42-sprint/runtime/src/cli.ts
          - plugins/m42-sprint/runtime/src/index.ts (exports)
        status: completed
        phases:
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              GIVEN the TypeScript runtime modules
              WHEN creating the CLI entry point
              THEN provide commands matching current bash interface

              ## Scope
              - Create CLI entry point
              - Set up runtime package.json
              - Configure build and test scripts

              ## Acceptance Criteria

              ### Package Setup
              - [ ] Create plugins/m42-sprint/runtime/package.json
              - [ ] Dependencies: js-yaml, commander
              - [ ] DevDependencies: typescript, vitest, @types/*
              - [ ] Scripts: build, test, typecheck

              ### CLI Entry Point
              - [ ] Create plugins/m42-sprint/runtime/src/cli.ts
              - [ ] `sprint run <dir>` - run sprint loop
              - [ ] `--max-iterations <n>` option
              - [ ] `--delay <ms>` option
              - [ ] `-v, --verbose` option
              - [ ] Exit code 0 on success, 1 on failure

              ### Build Setup
              - [ ] tsconfig.json for runtime
              - [ ] Output to dist/
              - [ ] Shebang for CLI: #!/usr/bin/env node

              ### Integration
              - [ ] Update root package.json with workspace reference
              - [ ] npm run build works from root
              - [ ] npm run test works from root

              ## Files to Create
              - plugins/m42-sprint/runtime/package.json
              - plugins/m42-sprint/runtime/tsconfig.json
              - plugins/m42-sprint/runtime/src/cli.ts
              - plugins/m42-sprint/runtime/src/index.ts (exports)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/cli-entrypoint-gherkin.md

              ```markdown
              # Gherkin Scenarios: cli-entrypoint

              ## Step Task
              GIVEN the TypeScript runtime modules
              WHEN creating the CLI entry point
              THEN provide commands matching current bash interface

              ## Scope
              - Create CLI entry point
              - Set up runtime package.json
              - Configure build and test scripts

              ## Acceptance Criteria

              ### Package Setup
              - [ ] Create plugins/m42-sprint/runtime/package.json
              - [ ] Dependencies: js-yaml, commander
              - [ ] DevDependencies: typescript, vitest, @types/*
              - [ ] Scripts: build, test, typecheck

              ### CLI Entry Point
              - [ ] Create plugins/m42-sprint/runtime/src/cli.ts
              - [ ] `sprint run <dir>` - run sprint loop
              - [ ] `--max-iterations <n>` option
              - [ ] `--delay <ms>` option
              - [ ] `-v, --verbose` option
              - [ ] Exit code 0 on success, 1 on failure

              ### Build Setup
              - [ ] tsconfig.json for runtime
              - [ ] Output to dist/
              - [ ] Shebang for CLI: #!/usr/bin/env node

              ### Integration
              - [ ] Update root package.json with workspace reference
              - [ ] npm run build works from root
              - [ ] npm run test works from root

              ## Files to Create
              - plugins/m42-sprint/runtime/package.json
              - plugins/m42-sprint/runtime/tsconfig.json
              - plugins/m42-sprint/runtime/src/cli.ts
              - plugins/m42-sprint/runtime/src/index.ts (exports)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/cli-entrypoint-gherkin.md
              git commit -m "test(cli-entrypoint): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: "2026-01-20T01:08:36Z"
            completed-at: "2026-01-20T01:11:58Z"
            elapsed: 00:03:22
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              GIVEN the TypeScript runtime modules
              WHEN creating the CLI entry point
              THEN provide commands matching current bash interface

              ## Scope
              - Create CLI entry point
              - Set up runtime package.json
              - Configure build and test scripts

              ## Acceptance Criteria

              ### Package Setup
              - [ ] Create plugins/m42-sprint/runtime/package.json
              - [ ] Dependencies: js-yaml, commander
              - [ ] DevDependencies: typescript, vitest, @types/*
              - [ ] Scripts: build, test, typecheck

              ### CLI Entry Point
              - [ ] Create plugins/m42-sprint/runtime/src/cli.ts
              - [ ] `sprint run <dir>` - run sprint loop
              - [ ] `--max-iterations <n>` option
              - [ ] `--delay <ms>` option
              - [ ] `-v, --verbose` option
              - [ ] Exit code 0 on success, 1 on failure

              ### Build Setup
              - [ ] tsconfig.json for runtime
              - [ ] Output to dist/
              - [ ] Shebang for CLI: #!/usr/bin/env node

              ### Integration
              - [ ] Update root package.json with workspace reference
              - [ ] npm run build works from root
              - [ ] npm run test works from root

              ## Files to Create
              - plugins/m42-sprint/runtime/package.json
              - plugins/m42-sprint/runtime/tsconfig.json
              - plugins/m42-sprint/runtime/src/cli.ts
              - plugins/m42-sprint/runtime/src/index.ts (exports)


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/cli-entrypoint-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/cli-entrypoint-context.md

              ```markdown
              # Step Context: cli-entrypoint

              ## Task
              GIVEN the TypeScript runtime modules
              WHEN creating the CLI entry point
              THEN provide commands matching current bash interface

              ## Scope
              - Create CLI entry point
              - Set up runtime package.json
              - Configure build and test scripts

              ## Acceptance Criteria

              ### Package Setup
              - [ ] Create plugins/m42-sprint/runtime/package.json
              - [ ] Dependencies: js-yaml, commander
              - [ ] DevDependencies: typescript, vitest, @types/*
              - [ ] Scripts: build, test, typecheck

              ### CLI Entry Point
              - [ ] Create plugins/m42-sprint/runtime/src/cli.ts
              - [ ] `sprint run <dir>` - run sprint loop
              - [ ] `--max-iterations <n>` option
              - [ ] `--delay <ms>` option
              - [ ] `-v, --verbose` option
              - [ ] Exit code 0 on success, 1 on failure

              ### Build Setup
              - [ ] tsconfig.json for runtime
              - [ ] Output to dist/
              - [ ] Shebang for CLI: #!/usr/bin/env node

              ### Integration
              - [ ] Update root package.json with workspace reference
              - [ ] npm run build works from root
              - [ ] npm run test works from root

              ## Files to Create
              - plugins/m42-sprint/runtime/package.json
              - plugins/m42-sprint/runtime/tsconfig.json
              - plugins/m42-sprint/runtime/src/cli.ts
              - plugins/m42-sprint/runtime/src/index.ts (exports)


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/cli-entrypoint-context.md
              git commit -m "context(cli-entrypoint): gather implementation context"
              ```
            started-at: "2026-01-20T01:12:05Z"
            completed-at: "2026-01-20T01:13:30Z"
            elapsed: 00:01:25
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              GIVEN the TypeScript runtime modules
              WHEN creating the CLI entry point
              THEN provide commands matching current bash interface

              ## Scope
              - Create CLI entry point
              - Set up runtime package.json
              - Configure build and test scripts

              ## Acceptance Criteria

              ### Package Setup
              - [ ] Create plugins/m42-sprint/runtime/package.json
              - [ ] Dependencies: js-yaml, commander
              - [ ] DevDependencies: typescript, vitest, @types/*
              - [ ] Scripts: build, test, typecheck

              ### CLI Entry Point
              - [ ] Create plugins/m42-sprint/runtime/src/cli.ts
              - [ ] `sprint run <dir>` - run sprint loop
              - [ ] `--max-iterations <n>` option
              - [ ] `--delay <ms>` option
              - [ ] `-v, --verbose` option
              - [ ] Exit code 0 on success, 1 on failure

              ### Build Setup
              - [ ] tsconfig.json for runtime
              - [ ] Output to dist/
              - [ ] Shebang for CLI: #!/usr/bin/env node

              ### Integration
              - [ ] Update root package.json with workspace reference
              - [ ] npm run build works from root
              - [ ] npm run test works from root

              ## Files to Create
              - plugins/m42-sprint/runtime/package.json
              - plugins/m42-sprint/runtime/tsconfig.json
              - plugins/m42-sprint/runtime/src/cli.ts
              - plugins/m42-sprint/runtime/src/index.ts (exports)


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/cli-entrypoint-gherkin.md (scenarios to satisfy)
              3. context/cli-entrypoint-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(cli-entrypoint): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: "2026-01-20T01:13:37Z"
            completed-at: "2026-01-20T01:16:32Z"
            elapsed: 00:02:55
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              GIVEN the TypeScript runtime modules
              WHEN creating the CLI entry point
              THEN provide commands matching current bash interface

              ## Scope
              - Create CLI entry point
              - Set up runtime package.json
              - Configure build and test scripts

              ## Acceptance Criteria

              ### Package Setup
              - [ ] Create plugins/m42-sprint/runtime/package.json
              - [ ] Dependencies: js-yaml, commander
              - [ ] DevDependencies: typescript, vitest, @types/*
              - [ ] Scripts: build, test, typecheck

              ### CLI Entry Point
              - [ ] Create plugins/m42-sprint/runtime/src/cli.ts
              - [ ] `sprint run <dir>` - run sprint loop
              - [ ] `--max-iterations <n>` option
              - [ ] `--delay <ms>` option
              - [ ] `-v, --verbose` option
              - [ ] Exit code 0 on success, 1 on failure

              ### Build Setup
              - [ ] tsconfig.json for runtime
              - [ ] Output to dist/
              - [ ] Shebang for CLI: #!/usr/bin/env node

              ### Integration
              - [ ] Update root package.json with workspace reference
              - [ ] npm run build works from root
              - [ ] npm run test works from root

              ## Files to Create
              - plugins/m42-sprint/runtime/package.json
              - plugins/m42-sprint/runtime/tsconfig.json
              - plugins/m42-sprint/runtime/src/cli.ts
              - plugins/m42-sprint/runtime/src/index.ts (exports)


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/cli-entrypoint-context.md (target patterns)
              Read: artifacts/cli-entrypoint-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(cli-entrypoint): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: "2026-01-20T01:16:39Z"
            completed-at: "2026-01-20T01:21:16Z"
            elapsed: 00:04:37
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/cli-entrypoint-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/cli-entrypoint-qa-report.md

              ```markdown
              # QA Report: cli-entrypoint

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/cli-entrypoint-qa-report.md
              git commit -m "qa(cli-entrypoint): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for cli-entrypoint.\n\nRead: artifacts/cli-entrypoint-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/cli-entrypoint-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: "2026-01-20T01:21:23Z"
            completed-at: "2026-01-20T01:22:59Z"
            elapsed: 00:01:36
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              GIVEN the TypeScript runtime modules
              WHEN creating the CLI entry point
              THEN provide commands matching current bash interface

              ## Scope
              - Create CLI entry point
              - Set up runtime package.json
              - Configure build and test scripts

              ## Acceptance Criteria

              ### Package Setup
              - [ ] Create plugins/m42-sprint/runtime/package.json
              - [ ] Dependencies: js-yaml, commander
              - [ ] DevDependencies: typescript, vitest, @types/*
              - [ ] Scripts: build, test, typecheck

              ### CLI Entry Point
              - [ ] Create plugins/m42-sprint/runtime/src/cli.ts
              - [ ] `sprint run <dir>` - run sprint loop
              - [ ] `--max-iterations <n>` option
              - [ ] `--delay <ms>` option
              - [ ] `-v, --verbose` option
              - [ ] Exit code 0 on success, 1 on failure

              ### Build Setup
              - [ ] tsconfig.json for runtime
              - [ ] Output to dist/
              - [ ] Shebang for CLI: #!/usr/bin/env node

              ### Integration
              - [ ] Update root package.json with workspace reference
              - [ ] npm run build works from root
              - [ ] npm run test works from root

              ## Files to Create
              - plugins/m42-sprint/runtime/package.json
              - plugins/m42-sprint/runtime/tsconfig.json
              - plugins/m42-sprint/runtime/src/cli.ts
              - plugins/m42-sprint/runtime/src/index.ts (exports)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/cli-entrypoint-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(cli-entrypoint): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: "2026-01-20T01:23:06Z"
            completed-at: "2026-01-20T01:27:35Z"
            elapsed: 00:04:29
      - id: remove-bash
        prompt: |
          GIVEN the working TypeScript runtime
          WHEN integrating with commands and cleaning up
          THEN remove replaced bash scripts and update all references

          ## Scope
          - Update slash commands to use TypeScript runtime
          - Remove replaced bash scripts
          - Update documentation

          ## Acceptance Criteria

          ### Command Updates
          - [ ] Update /run-sprint command to call TypeScript runtime
          - [ ] Update /sprint-status to use TypeScript if applicable
          - [ ] Verify /pause-sprint, /resume-sprint, /stop-sprint work

          ### Bash Script Removal
          - [ ] Delete: plugins/m42-sprint/scripts/sprint-loop.sh
          - [ ] Delete: plugins/m42-sprint/scripts/build-sprint-prompt.sh
          - [ ] Delete: plugins/m42-sprint/scripts/build-parallel-prompt.sh
          - [ ] Delete: plugins/m42-sprint/scripts/preflight-check.sh
          - [ ] KEEP: plugins/m42-sprint/scripts/test-*.sh (integration tests)

          ### Documentation Updates
          - [ ] Update plugins/m42-sprint/README.md
          - [ ] Update any docs referencing bash scripts
          - [ ] Document new TypeScript architecture

          ### Verification
          - [ ] grep -r "sprint-loop.sh" → no results
          - [ ] grep -r "build-sprint-prompt" → no results
          - [ ] /run-sprint executes successfully
          - [ ] Full sprint execution works end-to-end
          - [ ] All existing integration tests pass

          ## Files to Delete
          - plugins/m42-sprint/scripts/sprint-loop.sh
          - plugins/m42-sprint/scripts/build-sprint-prompt.sh
          - plugins/m42-sprint/scripts/build-parallel-prompt.sh
          - plugins/m42-sprint/scripts/preflight-check.sh

          ## Files to Modify
          - plugins/m42-sprint/commands/run-sprint.md
          - plugins/m42-sprint/README.md
        status: completed
        phases:
          - id: red
            status: completed
            prompt: |
              Write tests and gherkin scenarios BEFORE any implementation.

              ## Your Task
              GIVEN the working TypeScript runtime
              WHEN integrating with commands and cleaning up
              THEN remove replaced bash scripts and update all references

              ## Scope
              - Update slash commands to use TypeScript runtime
              - Remove replaced bash scripts
              - Update documentation

              ## Acceptance Criteria

              ### Command Updates
              - [ ] Update /run-sprint command to call TypeScript runtime
              - [ ] Update /sprint-status to use TypeScript if applicable
              - [ ] Verify /pause-sprint, /resume-sprint, /stop-sprint work

              ### Bash Script Removal
              - [ ] Delete: plugins/m42-sprint/scripts/sprint-loop.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/preflight-check.sh
              - [ ] KEEP: plugins/m42-sprint/scripts/test-*.sh (integration tests)

              ### Documentation Updates
              - [ ] Update plugins/m42-sprint/README.md
              - [ ] Update any docs referencing bash scripts
              - [ ] Document new TypeScript architecture

              ### Verification
              - [ ] grep -r "sprint-loop.sh" → no results
              - [ ] grep -r "build-sprint-prompt" → no results
              - [ ] /run-sprint executes successfully
              - [ ] Full sprint execution works end-to-end
              - [ ] All existing integration tests pass

              ## Files to Delete
              - plugins/m42-sprint/scripts/sprint-loop.sh
              - plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - plugins/m42-sprint/scripts/preflight-check.sh

              ## Files to Modify
              - plugins/m42-sprint/commands/run-sprint.md
              - plugins/m42-sprint/README.md


              ## Shared Context
              Read: context/_shared-context.md (project patterns, test patterns, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## TDD Rule: RED Phase
              In this phase, you ONLY write tests. No implementation code.
              Tests should FAIL when run (because implementation doesn't exist yet).

              ## Instructions

              ### Part 1: Write Gherkin Scenarios (4-8 scenarios)
              Create scenarios that define the expected behavior:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Part 2: Write Unit Tests
              Create test files that exercise the expected functionality:

              1. Determine test file location (from _shared-context.md patterns)
              2. Write test cases that match gherkin scenarios
              3. Include edge cases and error handling tests
              4. Tests should be runnable but FAIL (code doesn't exist)

              ## Test File Template
              ```typescript
              // Filename follows project convention from _shared-context.md
              import { describe, it, expect } from '[test-framework]';

              describe('[Feature under test]', () => {
                describe('[Scenario group]', () => {
                  it('should [expected behavior from gherkin]', () => {
                    // Arrange - Given
                    // Act - When
                    // Assert - Then
                  });

                  it('should [another expected behavior]', () => {
                    // ...
                  });
                });

                describe('edge cases', () => {
                  it('should handle [edge case]', () => {
                    // ...
                  });
                });

                describe('error handling', () => {
                  it('should throw when [error condition]', () => {
                    // ...
                  });
                });
              });
              ```

              ## Output
              Create: artifacts/remove-bash-gherkin.md

              ```markdown
              # Gherkin Scenarios: remove-bash

              ## Step Task
              GIVEN the working TypeScript runtime
              WHEN integrating with commands and cleaning up
              THEN remove replaced bash scripts and update all references

              ## Scope
              - Update slash commands to use TypeScript runtime
              - Remove replaced bash scripts
              - Update documentation

              ## Acceptance Criteria

              ### Command Updates
              - [ ] Update /run-sprint command to call TypeScript runtime
              - [ ] Update /sprint-status to use TypeScript if applicable
              - [ ] Verify /pause-sprint, /resume-sprint, /stop-sprint work

              ### Bash Script Removal
              - [ ] Delete: plugins/m42-sprint/scripts/sprint-loop.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/preflight-check.sh
              - [ ] KEEP: plugins/m42-sprint/scripts/test-*.sh (integration tests)

              ### Documentation Updates
              - [ ] Update plugins/m42-sprint/README.md
              - [ ] Update any docs referencing bash scripts
              - [ ] Document new TypeScript architecture

              ### Verification
              - [ ] grep -r "sprint-loop.sh" → no results
              - [ ] grep -r "build-sprint-prompt" → no results
              - [ ] /run-sprint executes successfully
              - [ ] Full sprint execution works end-to-end
              - [ ] All existing integration tests pass

              ## Files to Delete
              - plugins/m42-sprint/scripts/sprint-loop.sh
              - plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - plugins/m42-sprint/scripts/preflight-check.sh

              ## Files to Modify
              - plugins/m42-sprint/commands/run-sprint.md
              - plugins/m42-sprint/README.md


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification]

              ---

              ## Scenario 2: [Name]
              [Continue for 4-8 scenarios]

              ---

              ## Unit Test Coverage
              | Test File | Test Cases | Scenarios Covered |
              |-----------|------------|-------------------|
              | [path] | [count] | 1, 2, 3 |

              ## RED Phase Verification
              Tests are expected to FAIL at this point:
              \`\`\`bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: FAIL (no implementation yet)
              \`\`\`
              ```

              ## Commit (Tests Only)
              ```bash
              git add [test files] artifacts/remove-bash-gherkin.md
              git commit -m "test(remove-bash): add failing tests [RED]"
              ```

              ## Important
              - Do NOT write any implementation code in this phase
              - Tests SHOULD fail - that's the point of RED
              - Each gherkin scenario should have corresponding unit test(s)
            started-at: "2026-01-20T01:27:42Z"
            completed-at: "2026-01-20T01:31:40Z"
            elapsed: 00:03:58
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              GIVEN the working TypeScript runtime
              WHEN integrating with commands and cleaning up
              THEN remove replaced bash scripts and update all references

              ## Scope
              - Update slash commands to use TypeScript runtime
              - Remove replaced bash scripts
              - Update documentation

              ## Acceptance Criteria

              ### Command Updates
              - [ ] Update /run-sprint command to call TypeScript runtime
              - [ ] Update /sprint-status to use TypeScript if applicable
              - [ ] Verify /pause-sprint, /resume-sprint, /stop-sprint work

              ### Bash Script Removal
              - [ ] Delete: plugins/m42-sprint/scripts/sprint-loop.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/preflight-check.sh
              - [ ] KEEP: plugins/m42-sprint/scripts/test-*.sh (integration tests)

              ### Documentation Updates
              - [ ] Update plugins/m42-sprint/README.md
              - [ ] Update any docs referencing bash scripts
              - [ ] Document new TypeScript architecture

              ### Verification
              - [ ] grep -r "sprint-loop.sh" → no results
              - [ ] grep -r "build-sprint-prompt" → no results
              - [ ] /run-sprint executes successfully
              - [ ] Full sprint execution works end-to-end
              - [ ] All existing integration tests pass

              ## Files to Delete
              - plugins/m42-sprint/scripts/sprint-loop.sh
              - plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - plugins/m42-sprint/scripts/preflight-check.sh

              ## Files to Modify
              - plugins/m42-sprint/commands/run-sprint.md
              - plugins/m42-sprint/README.md


              ## Shared Context
              Read: context/_shared-context.md (project-wide patterns)
              Read: artifacts/remove-bash-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules to import from
                 - Note interfaces/types to implement or extend

              2. **Dependencies**
                 - Internal module imports needed
                 - External packages needed
                 - Version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this?
                 - Existing tests to reference

              4. **Patterns for Implementation**
                 - Error handling patterns
                 - Naming conventions
                 - File organization

              ## Output
              Create: context/remove-bash-context.md

              ```markdown
              # Step Context: remove-bash

              ## Task
              GIVEN the working TypeScript runtime
              WHEN integrating with commands and cleaning up
              THEN remove replaced bash scripts and update all references

              ## Scope
              - Update slash commands to use TypeScript runtime
              - Remove replaced bash scripts
              - Update documentation

              ## Acceptance Criteria

              ### Command Updates
              - [ ] Update /run-sprint command to call TypeScript runtime
              - [ ] Update /sprint-status to use TypeScript if applicable
              - [ ] Verify /pause-sprint, /resume-sprint, /stop-sprint work

              ### Bash Script Removal
              - [ ] Delete: plugins/m42-sprint/scripts/sprint-loop.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/preflight-check.sh
              - [ ] KEEP: plugins/m42-sprint/scripts/test-*.sh (integration tests)

              ### Documentation Updates
              - [ ] Update plugins/m42-sprint/README.md
              - [ ] Update any docs referencing bash scripts
              - [ ] Document new TypeScript architecture

              ### Verification
              - [ ] grep -r "sprint-loop.sh" → no results
              - [ ] grep -r "build-sprint-prompt" → no results
              - [ ] /run-sprint executes successfully
              - [ ] Full sprint execution works end-to-end
              - [ ] All existing integration tests pass

              ## Files to Delete
              - plugins/m42-sprint/scripts/sprint-loop.sh
              - plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - plugins/m42-sprint/scripts/preflight-check.sh

              ## Files to Modify
              - plugins/m42-sprint/commands/run-sprint.md
              - plugins/m42-sprint/README.md


              ## Implementation Plan
              Based on gherkin scenarios, implement in this order:
              1. [First thing to implement]
              2. [Second thing]
              ...

              ## Related Code Patterns

              ### Pattern from: [path]
              \`\`\`typescript
              // Key pattern to follow
              [relevant code snippet]
              \`\`\`

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              \`\`\`typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              \`\`\`

              ## Integration Points
              - Called by: [consumers]
              - Calls: [dependencies]

              ## Files to Create/Modify
              | File | Action | Purpose |
              |------|--------|---------|
              | [path] | Create | [purpose] |
              | [path] | Modify | [changes] |
              ```

              ## Commit
              ```bash
              git add context/remove-bash-context.md
              git commit -m "context(remove-bash): gather implementation context"
              ```
            started-at: "2026-01-20T01:31:47Z"
            completed-at: "2026-01-20T01:33:55Z"
            elapsed: 00:02:08
          - id: green
            status: completed
            prompt: |
              Implement MINIMAL code to make tests pass.

              ## Your Task
              GIVEN the working TypeScript runtime
              WHEN integrating with commands and cleaning up
              THEN remove replaced bash scripts and update all references

              ## Scope
              - Update slash commands to use TypeScript runtime
              - Remove replaced bash scripts
              - Update documentation

              ## Acceptance Criteria

              ### Command Updates
              - [ ] Update /run-sprint command to call TypeScript runtime
              - [ ] Update /sprint-status to use TypeScript if applicable
              - [ ] Verify /pause-sprint, /resume-sprint, /stop-sprint work

              ### Bash Script Removal
              - [ ] Delete: plugins/m42-sprint/scripts/sprint-loop.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/preflight-check.sh
              - [ ] KEEP: plugins/m42-sprint/scripts/test-*.sh (integration tests)

              ### Documentation Updates
              - [ ] Update plugins/m42-sprint/README.md
              - [ ] Update any docs referencing bash scripts
              - [ ] Document new TypeScript architecture

              ### Verification
              - [ ] grep -r "sprint-loop.sh" → no results
              - [ ] grep -r "build-sprint-prompt" → no results
              - [ ] /run-sprint executes successfully
              - [ ] Full sprint execution works end-to-end
              - [ ] All existing integration tests pass

              ## Files to Delete
              - plugins/m42-sprint/scripts/sprint-loop.sh
              - plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - plugins/m42-sprint/scripts/preflight-check.sh

              ## Files to Modify
              - plugins/m42-sprint/commands/run-sprint.md
              - plugins/m42-sprint/README.md


              ## TDD Rule: GREEN Phase
              Write the simplest code that makes tests pass. No more, no less.
              "Make it work" - not beautiful, just working.

              ## MUST READ BEFORE IMPLEMENTING
              Read in order:
              1. context/_shared-context.md (project patterns)
              2. artifacts/remove-bash-gherkin.md (scenarios to satisfy)
              3. context/remove-bash-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Tests
              Your implementation MUST satisfy:
              - ALL gherkin scenario verifications
              - ALL unit tests written in RED phase

              ### Minimal Implementation
              - Write the simplest code that passes tests
              - Don't add features not covered by tests
              - Don't optimize prematurely
              - Don't add "nice to have" abstractions

              ### Follow the Context
              - Use patterns from context file
              - Import from specified modules
              - Follow naming conventions

              ### Run Tests Frequently
              ```bash
              # Run tests as you implement
              npm test -- --testPathPattern="[pattern]" --watch
              ```

              ## Commits
              Make atomic commits for logical units:
              ```bash
              git add [files]
              git commit -m "feat(remove-bash): [what now works] [GREEN]"
              ```

              ## Success Criteria
              Before marking complete:
              - [ ] All unit tests pass
              - [ ] All gherkin verifications should pass
              - [ ] No TypeScript errors
              - [ ] Code follows context patterns

              ## Run Final Test
              ```bash
              npm test -- --testPathPattern="[pattern]"
              # Expected: PASS (all tests green)
              ```

              ## Important
              - Tests MUST pass before moving to REFACTOR
              - Don't refactor yet - that's the next phase
              - "Quick and dirty" is OK - we'll clean up next
            started-at: "2026-01-20T01:34:02Z"
            completed-at: "2026-01-20T01:41:03Z"
            elapsed: 00:07:01
          - id: refactor
            status: completed
            prompt: |
              Refactor implementation while keeping tests green.

              ## Your Task
              GIVEN the working TypeScript runtime
              WHEN integrating with commands and cleaning up
              THEN remove replaced bash scripts and update all references

              ## Scope
              - Update slash commands to use TypeScript runtime
              - Remove replaced bash scripts
              - Update documentation

              ## Acceptance Criteria

              ### Command Updates
              - [ ] Update /run-sprint command to call TypeScript runtime
              - [ ] Update /sprint-status to use TypeScript if applicable
              - [ ] Verify /pause-sprint, /resume-sprint, /stop-sprint work

              ### Bash Script Removal
              - [ ] Delete: plugins/m42-sprint/scripts/sprint-loop.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/preflight-check.sh
              - [ ] KEEP: plugins/m42-sprint/scripts/test-*.sh (integration tests)

              ### Documentation Updates
              - [ ] Update plugins/m42-sprint/README.md
              - [ ] Update any docs referencing bash scripts
              - [ ] Document new TypeScript architecture

              ### Verification
              - [ ] grep -r "sprint-loop.sh" → no results
              - [ ] grep -r "build-sprint-prompt" → no results
              - [ ] /run-sprint executes successfully
              - [ ] Full sprint execution works end-to-end
              - [ ] All existing integration tests pass

              ## Files to Delete
              - plugins/m42-sprint/scripts/sprint-loop.sh
              - plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - plugins/m42-sprint/scripts/preflight-check.sh

              ## Files to Modify
              - plugins/m42-sprint/commands/run-sprint.md
              - plugins/m42-sprint/README.md


              ## TDD Rule: REFACTOR Phase
              "Make it right" - improve code quality without changing behavior.
              Tests MUST stay green throughout refactoring.

              ## Context
              Read: context/remove-bash-context.md (target patterns)
              Read: artifacts/remove-bash-gherkin.md (scenarios that must stay passing)

              ## Refactoring Checklist

              ### Code Quality
              - [ ] Remove any duplication
              - [ ] Improve naming (variables, functions, files)
              - [ ] Extract helper functions if beneficial
              - [ ] Simplify complex conditionals
              - [ ] Add necessary type annotations

              ### Pattern Conformance
              - [ ] Follows project conventions from context
              - [ ] Error handling matches patterns
              - [ ] File organization matches patterns

              ### Clean Code
              - [ ] Remove dead code
              - [ ] Remove console.log/debug statements
              - [ ] Fix any linting issues
              - [ ] Add JSDoc for public APIs only

              ## Refactoring Rules

              ### Run Tests After Each Change
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```
              If tests fail, REVERT the change immediately.

              ### Small Steps
              - One refactoring at a time
              - Commit after each successful refactoring
              - Don't refactor multiple things at once

              ### Don't Change Behavior
              - No new features
              - No API changes (unless fixing test file imports)
              - Same inputs → same outputs

              ## Commits
              ```bash
              git add [files]
              git commit -m "refactor(remove-bash): [improvement made]"
              ```

              ## Lint and Type Check
              ```bash
              npm run lint -- [files]
              npm run typecheck
              ```

              Fix any issues found.

              ## Final Verification
              ```bash
              npm test -- --testPathPattern="[pattern]"
              npm run lint
              npm run typecheck
              ```

              All must pass before completing this phase.
            started-at: "2026-01-20T01:41:10Z"
            completed-at: "2026-01-20T01:45:29Z"
            elapsed: 00:04:19
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/remove-bash-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Unit Tests
              ```bash
              npm test -- --testPathPattern="[pattern]"
              ```

              Record results: total tests, passed, failed.

              ## Step 2: Run Each Gherkin Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record result: 1 (pass) or 0 (fail)
              3. If fail, capture error output

              ## Step 3: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 4: Generate QA Report

              Create: artifacts/remove-bash-qa-report.md

              ```markdown
              # QA Report: remove-bash

              ## Summary
              - Gherkin Scenarios: [N] total, [N] passed, [N] failed
              - Gherkin Score: [X]/[N] = [percentage]%
              - Unit Tests: [N] total, [N] passed, [N] failed

              ## Unit Test Results
              \`\`\`
              [test output]
              \`\`\`

              ## Gherkin Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output] |
              | 2 | [Name] | PASS/FAIL | [output] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              \`\`\`
              [actual output]
              \`\`\`
              **Result**: PASS / FAIL

              [Continue for all scenarios]

              ## TDD Cycle Summary
              | Phase | Status |
              |-------|--------|
              | RED (tests) | ✓ Completed |
              | GREEN (implement) | ✓ Completed |
              | REFACTOR | ✓ Completed |
              | QA (verify) | PASS/FAIL |

              ## Issues Found
              [If any failures, describe each issue]

              ## Status: PASS / FAIL
              ```

              ## Step 5: Handle Outcome

              ### If ALL pass (Score = 100%):
              ```bash
              git add artifacts/remove-bash-qa-report.md
              git commit -m "qa(remove-bash): all scenarios passed"
              ```

              ### If ANY fail (Score < 100%):
              Inject fix phases:

              ```bash
              PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)

              yq -i '
                (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                [
                  {
                    "id": "fix",
                    "status": "pending",
                    "prompt": "Fix failing scenarios for remove-bash.\n\nRead: artifacts/remove-bash-qa-report.md\n\n1. Review each FAIL scenario\n2. Fix implementation to pass\n3. Run verification to confirm\n4. Run unit tests to ensure no regression\n5. Commit fixes"
                  },
                  {
                    "id": "reverify",
                    "status": "pending",
                    "prompt": "Re-verify all scenarios after fixes.\n\nRun ALL verifications from artifacts/remove-bash-gherkin.md\nRun ALL unit tests.\n\nIf ALL pass: Update QA report with PASS status.\nIf ANY fail: Inject another fix phase."
                  }
                ]
              ' "$PROGRESS_FILE"

              yq -i '
                (.. | select(.id == "qa" and .status == "in-progress")) |=
                (.status = "failed" | .error = "QA failed - fix phase injected")
              ' "$PROGRESS_FILE"
              ```
            started-at: "2026-01-20T01:45:36Z"
            completed-at: "2026-01-20T01:49:44Z"
            elapsed: 00:04:08
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              GIVEN the working TypeScript runtime
              WHEN integrating with commands and cleaning up
              THEN remove replaced bash scripts and update all references

              ## Scope
              - Update slash commands to use TypeScript runtime
              - Remove replaced bash scripts
              - Update documentation

              ## Acceptance Criteria

              ### Command Updates
              - [ ] Update /run-sprint command to call TypeScript runtime
              - [ ] Update /sprint-status to use TypeScript if applicable
              - [ ] Verify /pause-sprint, /resume-sprint, /stop-sprint work

              ### Bash Script Removal
              - [ ] Delete: plugins/m42-sprint/scripts/sprint-loop.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - [ ] Delete: plugins/m42-sprint/scripts/preflight-check.sh
              - [ ] KEEP: plugins/m42-sprint/scripts/test-*.sh (integration tests)

              ### Documentation Updates
              - [ ] Update plugins/m42-sprint/README.md
              - [ ] Update any docs referencing bash scripts
              - [ ] Document new TypeScript architecture

              ### Verification
              - [ ] grep -r "sprint-loop.sh" → no results
              - [ ] grep -r "build-sprint-prompt" → no results
              - [ ] /run-sprint executes successfully
              - [ ] Full sprint execution works end-to-end
              - [ ] All existing integration tests pass

              ## Files to Delete
              - plugins/m42-sprint/scripts/sprint-loop.sh
              - plugins/m42-sprint/scripts/build-sprint-prompt.sh
              - plugins/m42-sprint/scripts/build-parallel-prompt.sh
              - plugins/m42-sprint/scripts/preflight-check.sh

              ## Files to Modify
              - plugins/m42-sprint/commands/run-sprint.md
              - plugins/m42-sprint/README.md


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/remove-bash-qa-report.md (should show PASS)

              ## Step 1: Full Test Suite
              Run all tests (not just this step's tests):
              ```bash
              npm test
              ```

              Verify no regressions in other tests.

              ## Step 2: Build Verification
              ```bash
              npm run build
              npm run typecheck
              npm run lint
              ```

              ## Step 3: Integration Check
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 4: Final Commit
              ```bash
              git add -A
              git status
              git diff --cached --quiet || git commit -m "verify(remove-bash): integration verified"
              ```

              ## Step Complete
              The TDD cycle for this step is complete:
              - ✓ RED: Tests written first
              - ✓ GREEN: Minimal implementation
              - ✓ REFACTOR: Code cleaned up
              - ✓ QA: All scenarios pass
              - ✓ VERIFY: Integration confirmed
            started-at: "2026-01-20T01:49:52Z"
            completed-at: "2026-01-20T01:52:31Z"
            elapsed: 00:02:39
  - id: doc-analyze
    status: completed
    prompt: |
      Analyze code changes and plan documentation updates.

      ## Context
      Read: context/_shared-context.md (documentation structure)
      Read: context/sprint-plan.md (documentation update plan)

      ## Step 1: Review All Code Changes
      ```bash
      # See all changes in this sprint
      git diff main..HEAD --name-only

      # Get detailed diff
      git diff main..HEAD -- "*.ts" "*.tsx" "*.js"
      ```

      ## Step 2: Identify Documentation Impact

      For each change, determine:
      - New features that need documenting
      - Changed behavior that needs updating
      - Removed features that need removing from docs
      - New/changed CLI commands
      - New/changed configuration options
      - New/changed API endpoints or functions

      ## Step 3: Audit Existing Documentation
      ```bash
      # Find all documentation files
      find . -name "*.md" -path "*/docs/*" -o -name "README.md" | head -30
      ```

      Review each relevant doc file and note:
      - What's accurate and complete
      - What's outdated
      - What's missing

      ## Step 4: Generate Documentation Plan
      Create: artifacts/docs-update-plan.md

      ```markdown
      # Documentation Update Plan: 2026-01-20_typescript-runtime-migration

      ## Code Changes Summary
      | File | Change Type | Description |
      |------|-------------|-------------|
      | [path] | Added/Modified | [what changed] |

      ## Documentation Impact

      ### User Guide Updates
      | Section | Action | Reason |
      |---------|--------|--------|
      | [section] | Update/Add/Remove | [why] |

      ### Getting Started Updates
      | Section | Action | Reason |
      |---------|--------|--------|
      | [section] | Update/Add | [why] |

      ### Reference Updates
      | Item | Action | Details |
      |------|--------|---------|
      | [command/function] | Update/Add | [changes] |

      ## New Documentation Needed
      - [ ] [New doc 1]: [purpose]
      - [ ] [New doc 2]: [purpose]

      ## Files to Update
      | File | Updates Needed |
      |------|----------------|
      | [path] | [specific updates] |

      ## Verification Plan
      - [ ] All code examples tested
      - [ ] All commands verified
      - [ ] All links checked
      ```

      ## Commit
      ```bash
      git add artifacts/docs-update-plan.md
      git commit -m "docs(plan): documentation update analysis"
      ```
    started-at: "2026-01-20T01:52:39Z"
    completed-at: "2026-01-20T01:55:14Z"
    elapsed: 00:02:35
  - id: doc-user-guide
    status: completed
    prompt: |
      Update user-facing documentation based on analysis.

      ## Context
      Read: artifacts/docs-update-plan.md (what needs updating)
      Read: context/_shared-context.md (documentation structure)

      ## User Guide Principles
      1. **Task-oriented**: Organize by what users want to DO
      2. **Progressive**: Simple → Advanced
      3. **Example-rich**: Every feature needs an example
      4. **Scannable**: Use headers, lists, tables

      ## Step 1: Locate or Create User Guide
      The user guide should be at: `docs/USER-GUIDE.md` or `docs/user-guide/`

      If it doesn't exist, create it using the template below.

      ## Step 2: Update Each Section

      For each item in docs-update-plan.md's "User Guide Updates":

      ### Adding New Features
      ```markdown
      ## [Feature Name]

      [One paragraph explaining WHAT it does and WHY you'd use it]

      ### Quick Example
      \`\`\`bash
      # Show the simplest possible example
      [command or code]
      \`\`\`

      ### How It Works
      [Explain the feature in more detail]

      ### Examples

      #### Basic Usage
      \`\`\`bash
      [example]
      \`\`\`

      #### Advanced Usage
      \`\`\`bash
      [example with options]
      \`\`\`

      ### Tips
      - [Helpful tip 1]
      - [Helpful tip 2]
      ```

      ### Updating Existing Features
      - Locate the existing section
      - Update examples if behavior changed
      - Update descriptions if functionality changed
      - Add new subsections for new capabilities

      ### Removing Features
      - Remove the section entirely
      - Or add deprecation notice if replacing

      ## Step 3: Verify Examples Work
      Run each code example in the documentation to ensure it works:
      ```bash
      # Test each example manually
      [example command from docs]
      ```

      ## Step 4: Commit Updates
      ```bash
      git add docs/
      git commit -m "docs(user-guide): update for 2026-01-20_typescript-runtime-migration changes"
      ```
    started-at: "2026-01-20T01:55:22Z"
    completed-at: "2026-01-20T01:58:44Z"
    elapsed: 00:03:22
  - id: doc-getting-started
    status: completed
    prompt: |
      Update getting started and quickstart documentation.

      ## Context
      Read: artifacts/docs-update-plan.md (what needs updating)
      Read: context/_shared-context.md (documentation structure)

      ## Getting Started Principles
      1. **Fast**: Get to "Hello World" in < 5 steps
      2. **Complete**: All prerequisites clearly listed
      3. **Copy-paste**: Every command should work as written
      4. **No assumptions**: Don't assume prior knowledge

      ## Step 1: Locate or Create Getting Started
      Should be at: `docs/getting-started/` or `docs/QUICKSTART.md` or in README.md

      ## Step 2: Update Prerequisites
      List everything needed before starting:
      ```markdown
      ## Prerequisites

      - [Requirement 1] - [how to check/install]
      - [Requirement 2] - [how to check/install]

      ### Version Requirements
      | Tool | Minimum Version | Check Command |
      |------|-----------------|---------------|
      | [tool] | [version] | `[command]` |
      ```

      ## Step 3: Update Installation
      ```markdown
      ## Installation

      ### Option 1: [Primary method]
      \`\`\`bash
      [installation commands]
      \`\`\`

      ### Option 2: [Alternative method]
      \`\`\`bash
      [alternative commands]
      \`\`\`

      ### Verify Installation
      \`\`\`bash
      [verification command]
      # Expected output: [what they should see]
      \`\`\`
      ```

      ## Step 4: Update First Steps
      ```markdown
      ## Your First [Thing]

      ### Step 1: [Action]
      \`\`\`bash
      [command]
      \`\`\`

      You should see:
      \`\`\`
      [expected output]
      \`\`\`

      ### Step 2: [Action]
      [Continue with clear steps]

      ### Step 3: [Action]
      [Each step should be verifiable]

      ## Success!
      You've now [accomplished goal]. Next steps:
      - [Link to User Guide]
      - [Link to next tutorial]
      ```

      ## Step 5: Update README Quick Example
      If README.md has a quick example section, ensure it's current:
      - Examples should work with latest code
      - Version numbers should be accurate
      - Links should be valid

      ## Step 6: Test the Flow
      Follow the getting started guide yourself:
      1. Start from a fresh state
      2. Run each command exactly as written
      3. Verify expected outputs match
      4. Fix any issues found

      ## Step 7: Commit Updates
      ```bash
      git add docs/ README.md
      git commit -m "docs(getting-started): update onboarding for 2026-01-20_typescript-runtime-migration"
      ```
    started-at: "2026-01-20T01:58:52Z"
    completed-at: "2026-01-20T02:00:05Z"
    elapsed: 00:01:13
  - id: doc-reference
    status: completed
    prompt: |
      Update technical reference and API documentation.

      ## Context
      Read: artifacts/docs-update-plan.md (what needs updating)
      Read: context/_shared-context.md (documentation structure)

      ## Reference Documentation Principles
      1. **Complete**: Document ALL public APIs
      2. **Accurate**: Generated from code when possible
      3. **Structured**: Consistent format for all items
      4. **Searchable**: Easy to find specific items

      ## Step 1: Locate or Create Reference Docs
      Should be at: `docs/reference/` or `docs/api/`

      ## Step 2: Update Command Reference
      For CLI commands, use this format:

      ```markdown
      ## Commands Reference

      ### [command-name]

      [One-line description]

      #### Synopsis
      \`\`\`
      [command] [options] [arguments]
      \`\`\`

      #### Description
      [Detailed description of what the command does]

      #### Options
      | Option | Type | Default | Description |
      |--------|------|---------|-------------|
      | `--option` | string | none | [description] |
      | `-f, --flag` | boolean | false | [description] |

      #### Arguments
      | Argument | Required | Description |
      |----------|----------|-------------|
      | `<name>` | Yes | [description] |
      | `[path]` | No | [description] |

      #### Examples
      \`\`\`bash
      # Basic usage
      [command] [basic-args]

      # With options
      [command] --option value

      # Advanced usage
      [command] --flag -o value
      \`\`\`

      #### See Also
      - [Related command 1]
      - [Related command 2]
      ```

      ## Step 3: Update API Reference
      For functions/classes, use this format:

      ```markdown
      ## API Reference

      ### [FunctionName]

      \`\`\`typescript
      function name(param: Type): ReturnType
      \`\`\`

      [Description of what the function does]

      #### Parameters
      | Parameter | Type | Required | Description |
      |-----------|------|----------|-------------|
      | `param` | `Type` | Yes | [description] |

      #### Returns
      `ReturnType` - [description of return value]

      #### Throws
      - `ErrorType` - [when this error is thrown]

      #### Example
      \`\`\`typescript
      const result = name(value);
      console.log(result); // [expected output]
      \`\`\`
      ```

      ## Step 4: Update Configuration Reference
      For config options:

      ```markdown
      ## Configuration Reference

      ### [config-file-name]

      #### Schema
      \`\`\`yaml
      # Full schema with comments
      option: value  # description
      nested:
        key: value   # description
      \`\`\`

      #### Options

      ##### `option`
      - **Type**: string
      - **Required**: Yes/No
      - **Default**: `value`
      - **Description**: [what this option does]
      - **Example**: `option: "example"`
      ```

      ## Step 5: Update Type Definitions
      If there are TypeScript types that users need to know:

      ```markdown
      ## Type Definitions

      ### [TypeName]
      \`\`\`typescript
      interface TypeName {
        property: string;
        optional?: number;
      }
      \`\`\`

      | Property | Type | Required | Description |
      |----------|------|----------|-------------|
      | `property` | `string` | Yes | [description] |
      ```

      ## Step 6: Verify Reference Accuracy
      - Check that all documented APIs actually exist
      - Verify parameter names and types match code
      - Test example code snippets

      ## Step 7: Commit Updates
      ```bash
      git add docs/reference/
      git commit -m "docs(reference): update API and command reference for 2026-01-20_typescript-runtime-migration"
      ```
    started-at: "2026-01-20T02:00:13Z"
    completed-at: "2026-01-20T02:01:40Z"
    elapsed: 00:01:27
  - id: doc-validate
    status: completed
    prompt: |
      Validate all documentation updates.

      ## Context
      Read: artifacts/docs-update-plan.md (original plan)

      ## Step 1: Completeness Check
      Verify all planned updates were made:
      ```bash
      # Show all doc changes in this sprint
      git diff main..HEAD -- "*.md" --stat
      ```

      Cross-reference with docs-update-plan.md:
      - [ ] All User Guide updates complete
      - [ ] All Getting Started updates complete
      - [ ] All Reference updates complete
      - [ ] All new docs created

      ## Step 2: Link Validation
      Check all internal links work:
      ```bash
      # Find all markdown links
      grep -rh "\[.*\](.*\.md)" docs/ | head -30
      ```

      Verify each linked file exists.

      ## Step 3: Code Example Validation
      Test each code example in the documentation:
      - Run CLI examples
      - Compile TypeScript examples
      - Execute JavaScript examples

      Document any failures.

      ## Step 4: Consistency Check
      - Consistent formatting across all docs
      - Consistent terminology
      - Consistent example style
      - Version numbers match

      ## Step 5: Generate Validation Report
      Create: artifacts/docs-validation-report.md

      ```markdown
      # Documentation Validation Report: 2026-01-20_typescript-runtime-migration

      ## Completeness
      | Planned Update | Status | Notes |
      |----------------|--------|-------|
      | [update 1] | DONE/MISSING | [notes] |

      ## Link Validation
      | Link | Target | Status |
      |------|--------|--------|
      | [link text] | [file] | OK/BROKEN |

      ## Code Example Validation
      | File | Example | Status | Output |
      |------|---------|--------|--------|
      | [path] | Line [N] | PASS/FAIL | [output] |

      ## Consistency Check
      - [ ] Formatting consistent
      - [ ] Terminology consistent
      - [ ] Examples consistent
      - [ ] Versions accurate

      ## Issues Found
      [List any issues, or "None"]

      ## Documentation Files Updated
      | File | Lines Changed | Summary |
      |------|---------------|---------|
      | [path] | +[N]/-[N] | [summary] |

      ## Overall Status: PASS / FAIL
      ```

      ## Step 6: Fix Any Issues
      If validation found issues:
      - Fix broken links
      - Update failed examples
      - Correct inconsistencies

      ## Step 7: Final Commit
      ```bash
      git add artifacts/docs-validation-report.md
      git add docs/  # Any fixes
      git commit -m "docs(validate): documentation verified for 2026-01-20_typescript-runtime-migration"
      ```

      ## Important
      Documentation must pass validation before sprint can complete.
      All code examples must work with the actual code.
    started-at: "2026-01-20T02:01:47Z"
    completed-at: "2026-01-20T02:05:02Z"
    elapsed: 00:03:15
  - id: final-qa
    status: completed
    prompt: |
      Comprehensive Quality Assurance for the entire sprint.

      ## Context
      Read: context/_shared-context.md for build/test commands
      Read: context/sprint-plan.md for success criteria

      ## Step 1: Full Build Verification
      Run ALL build checks:
      ```bash
      npm run build
      npm run typecheck
      npm run lint
      ```

      Record each result in the QA report.

      ## Step 2: Complete Test Suite
      Run the full test suite:
      ```bash
      npm test
      ```

      Record test results, coverage, and any failures.

      ## Step 3: Review All Step QA Reports
      Read all artifacts/step-*-qa-report.md files:
      - Verify all steps show PASS status
      - Calculate total gherkin score
      - Consolidate warnings or notes

      ## Step 4: Documentation Verification
      Verify documentation was updated:
      ```bash
      # Check for documentation changes
      git diff main..HEAD -- "*.md" --stat
      ```

      Verify:
      - User guide reflects new features
      - Getting started is accurate
      - Reference material is complete
      - Examples work correctly

      ## Step 5: Integration Verification
      - Check modules properly import each other
      - Verify no circular dependencies
      - Test end-to-end flow if applicable

      ## Step 6: Regression Check
      ```bash
      git diff main...HEAD --stat
      ```

      Verify:
      - No unintended changes
      - All modified files are expected
      - No debug code left in

      ## Step 7: Generate Sprint QA Report
      Create: artifacts/sprint-qa-report.md

      ```markdown
      # Sprint QA Report: 2026-01-20_typescript-runtime-migration

      ## Build Verification
      | Check | Result | Output |
      |-------|--------|--------|
      | Build | PASS/FAIL | [summary] |
      | TypeCheck | PASS/FAIL | [summary] |
      | Lint | PASS/FAIL | [summary] |

      ## Test Suite
      | Metric | Value |
      |--------|-------|
      | Tests Run | [count] |
      | Passed | [count] |
      | Failed | [count] |
      | Coverage | [percentage] |

      ## Gherkin Scenario Summary
      | Step | Total | Passed | Score |
      |------|-------|--------|-------|
      | step-0 | [N] | [N] | 100% |
      | step-1 | [N] | [N] | 100% |
      | **Total** | [N] | [N] | **100%** |

      ## Documentation Status
      | Document | Status | Changes |
      |----------|--------|---------|
      | User Guide | PASS/FAIL | [summary] |
      | Getting Started | PASS/FAIL | [summary] |
      | Reference | PASS/FAIL | [summary] |

      ## Integration Verification
      - [ ] Modules import correctly
      - [ ] No circular dependencies
      - [ ] End-to-end flow works

      ## Overall Status: PASS / FAIL
      ```

      ## Step 8: Handle Outcome

      ### If PASS:
      ```bash
      git add artifacts/sprint-qa-report.md
      git commit -m "qa: sprint-level verification passed"
      ```

      ### If FAIL:
      - Document specific failures
      - Set status to needs-human with details
    started-at: "2026-01-20T02:05:10Z"
    completed-at: "2026-01-20T02:08:56Z"
    elapsed: 00:03:46
  - id: summary
    status: completed
    prompt: |
      Generate sprint summary with TDD and documentation highlights.

      ## Context
      Read: context/sprint-plan.md for original goals
      Read: artifacts/sprint-qa-report.md for verification results
      Read: All artifacts/step-*-qa-report.md for step details

      ## Step 1: Collect Commit History
      ```bash
      git log main..HEAD --oneline --no-decorate
      ```

      ## Step 2: Collect File Changes
      ```bash
      git diff main..HEAD --stat
      ```

      ## Step 3: Generate Sprint Summary
      Create: artifacts/sprint-summary.md

      ```markdown
      # Sprint Summary: 2026-01-20_typescript-runtime-migration

      ## What Was Accomplished

      ### Step 0: [Step title]
      **TDD Cycle**:
      - Tests written: [count]
      - Gherkin scenarios: [count], all passing

      **Implementation**:
      - [Key accomplishment 1]
      - [Key accomplishment 2]

      **Files**: [list]

      [Continue for each step]

      ## Test Coverage Summary
      | Metric | Before | After | Delta |
      |--------|--------|-------|-------|
      | Tests | [N] | [N] | +[N] |
      | Gherkin | [N] | [N] | +[N] |
      | Coverage | [%] | [%] | +[%] |

      ## Documentation Updates
      | Document | Change |
      |----------|--------|
      | [path] | [what changed] |

      ## Files Changed
      | File | Change Type | Description |
      |------|-------------|-------------|
      | [path] | Created/Modified | [description] |

      ## Commits Made
      | Hash | Type | Message |
      |------|------|---------|
      | [hash] | test | [message] |
      | [hash] | feat | [message] |
      | [hash] | docs | [message] |

      ## Verification Status
      - Build: PASS
      - TypeCheck: PASS
      - Lint: PASS
      - Tests: [X/Y passed]
      - Gherkin: [X/Y scenarios, 100%]
      - Documentation: Updated

      ## Sprint Statistics
      - Steps completed: [X/Y]
      - Total commits: [count]
      - Tests added: [count]
      - Gherkin scenarios: [count]
      - Files changed: [count]
      ```

      ## Step 4: Commit Summary
      ```bash
      git add artifacts/sprint-summary.md
      git commit -m "docs: add sprint summary"
      ```
    started-at: "2026-01-20T02:09:04Z"
    completed-at: "2026-01-20T02:11:03Z"
    elapsed: 00:01:59
  - id: pr-create
    status: completed
    prompt: "Push the sprint branch and create a pull request.\n\n## Context\nRead: artifacts/sprint-summary.md for PR body content\nRead: artifacts/sprint-qa-report.md for verification checklist\n\n## Step 1: Ensure All Changes Committed\n```bash\ngit status\n```\n\n## Step 2: Push Branch\n```bash\ngit push -u origin sprint/2026-01-20_typescript-runtime-migration\n```\n\n## Step 3: Create Pull Request\n```bash\ngh pr create \\\n  --title \"Sprint: 2026-01-20_typescript-runtime-migration\" \\\n  --body \"$(cat <<'EOF'\n## Summary\n[Extract key points from sprint-summary.md]\n\n## TDD Approach\n- Tests written first for each step\n- All gherkin scenarios pass\n- [X] new tests added\n\n## Changes\n[List major changes]\n\n## Documentation\n- [ ] User Guide updated\n- [ ] Getting Started updated\n- [ ] Reference updated\n\n## Verification Checklist\n- [x] Build passes\n- [x] TypeCheck passes\n- [x] Lint passes\n- [x] All tests pass\n- [x] Gherkin scenarios: 100%\n- [x] Documentation updated\n- [x] No regressions\n\n---\nFull details in `artifacts/sprint-summary.md`\n\n\U0001F9EA TDD Sprint with Documentation\nEOF\n)\"\n```\n\n## Step 4: Output PR URL\n```bash\ngh pr view --json url -q '.url'\n```\n"
    started-at: "2026-01-20T02:11:11Z"
    completed-at: "2026-01-20T02:12:00Z"
    elapsed: 00:00:49
current:
  phase: 10
  step: 0
  sub-phase: 0
stats:
  started-at: "2026-01-19T22:53:44Z"
  total-phases: 64
  completed-phases: 0
  total-steps: 9
  completed-steps: 0
  max-iterations: 1000000
  current-iteration: 5
  completed-at: "2026-01-20T02:12:00Z"
parallel-tasks: []
