# SPRINT.yaml - Workflow QA Improvements
# Address the per-iteration-hooks gap and improve skill discoverability
#
# Steps 1-2: QA/Testing improvements (behavioral gherkin, integration tests)
# Step 3: Implement per-iteration-hooks in TypeScript runtime
# Steps 4-6: Discoverability improvements (inline schema, versioning, validation)

workflow: plugin-development

collections:
  step:
    # ========================================================================
    # Step 1: Create Gherkin Best Practices Skill
    # ========================================================================
    - prompt: |
        /m42-meta-toolkit:create-skill creating-gherkin-scenarios

        ## Context
        Root cause: The ralph-mode-implementation sprint tested that
        `spawn_per_iteration_hooks()` EXISTED (via grep) but not that it WORKED.
        This structural verification gave false confidence.

        ## Requirements

        ### 1. Skill File Structure
        Create: .claude/skills/creating-gherkin-scenarios/SKILL.md
        Note: This is not part of a plugin itself, but our project to create plugins!

        ### 2. Core Principle
        **Behavioral Testing > Structural Testing**

        Document this anti-pattern:
        ❌ WRONG - Tests existence, not behavior:
        - "Function X exists" (grep verification)
        - "File Y contains pattern Z"
        - "Module exports function"
        - "Code compiles without errors"

        ✅ CORRECT - Tests observable behavior:
        - "When I invoke X with Y, then Z happens"
        - "Given config A, when event B occurs, then output C"
        - "After action X, state Y is observable in the file system"
        - "End-to-end: setup → action → verify outcome"

        ### 3. Gherkin Guidelines

        #### For New Features
        ```gherkin
        Scenario: Feature works end-to-end
          Given [precondition - setup test environment]
          When [action - invoke the feature]
          Then [outcome - verify observable result]
          And [additional verifications]
        ```

        #### For External Process Interactions
        Features that spawn processes (hooks, subagents, parallel tasks):
        ```gherkin
        Scenario: Hook spawns and executes
          Given a sprint with learning hook enabled
          When the sprint completes an iteration
          Then the hook process is spawned
          And the hook transcript file exists
          And the hook output is captured
        ```

        #### For State Changes
        ```gherkin
        Scenario: State persists correctly
          Given a sprint in progress
          When I modify the PROGRESS.yaml externally
          And the sprint continues execution
          Then the external changes are preserved
        ```

        ### 4. Integration Test Requirements

        When to require integration tests:
        - External process spawning (Claude CLI, bash scripts)
        - File system state changes
        - Inter-process communication
        - Async/parallel operations
        - Transaction/recovery scenarios

        ### 5. Examples Section

        Include real examples from the codebase:
        - Good: compile.test.ts tests that compilation produces valid PROGRESS.yaml
        - Bad: "grep for function existence" from ralph-mode-implementation
        - Good: loop.test.ts with mocked Claude runner
        - Bad: Any verification that only checks code structure

        ### 6. Triggers

        This skill should trigger on:
        - "write gherkin"
        - "create scenarios"
        - "write acceptance criteria"
        - "test strategy"
        - "verification approach"

        ### 7. Integration with Existing Workflows

        Add guidance for each TDD phase:
        - RED: Write behavioral gherkin BEFORE tests
        - GREEN: Verify gherkin scenarios pass
        - REFACTOR: Ensure scenarios still pass

    # ========================================================================
    # Step 2: Add Integration Test Requirements to plugin-development Workflow
    # ========================================================================
    - prompt: |
        Update plugin-development workflow to enforce integration testing.

        ## Context
        The per-iteration-hooks feature was implemented without integration tests.
        Unit tests existed for individual modules but not for the end-to-end hook
        execution flow.

        ## Requirements

        ### 1. Update Development Phase

        File: .claude/workflows/plugin-development.yaml
        Phase: development (for-each: step)

        Add to the TDD OPERATOR prompt (after REFACTOR phase):

        ```markdown
        ### 4. INTEGRATION TEST Phase (if needed)

        Determine if this feature requires integration testing:
        - ✅ YES if: spawns external processes, modifies file system state,
          involves async/parallel operations, or inter-process communication
        - ❌ NO if: pure function, simple data transformation, isolated logic

        If YES, spawn an integration test subagent:

        ```
        Task: INTEGRATION - Create end-to-end test for {{item.id}}

        Requirements:
        {{item.prompt}}

        Instructions:
        1. Identify the end-to-end flow to test
        2. Create integration test file: {{item.id}}.integration.test.ts
        3. Test with real dependencies where safe, mocked where necessary
        4. Verify observable outcomes (files created, processes spawned, state changed)
        5. Include teardown to clean up test artifacts
        6. Commit: git commit -m "test({{item.id}}): add integration tests"

        Examples of what to verify:
        - If feature spawns Claude: verify it's invoked with correct args
        - If feature writes files: verify files exist with correct content
        - If feature modifies state: verify state changes are observable
        - If feature runs in parallel: verify non-blocking behavior

        Common Integration Test Patterns:
        - Use test fixtures for file system state
        - Mock external APIs but test real process spawning
        - Verify error handling with real failure scenarios
        - Test transaction/recovery with simulated crashes
        ```

        **Verify INTEGRATION**: Run integration tests, confirm end-to-end flow works.
        ```

        ### 2. Update Verification Criteria

        Add to the "Final Output" section:

        ```markdown
        ## Files Changed
        [List]

        ## Test Coverage
        - Unit tests: [count]
        - Integration tests: [count if applicable]

        ## Status: COMPLETE
        ```

        ### 3. Add to QA Phase Checklist

        File: .claude/workflows/plugin-development.yaml
        Phase: final-qa

        Add to Step 2:

        ```markdown
        ## Step 2: Full Test Suite
        ```bash
        npm test
        ```

        All tests must pass. Record coverage if available.

        **Integration Test Verification:**
        - [ ] If feature spawns processes: integration test verifies spawning
        - [ ] If feature modifies state: integration test verifies persistence
        - [ ] If feature has async/parallel: integration test verifies timing
        ```

    # ========================================================================
    # Step 3: Implement per-iteration-hooks in TypeScript runtime
    # ========================================================================
    - prompt: |
        Implement per-iteration-hooks execution in the TypeScript sprint runtime.

        ## Problem

        The `per-iteration-hooks` feature is defined in the schema and compiled into
        PROGRESS.yaml, but the TypeScript runtime (loop.ts) never executes them.

        **Current state:**
        - ✅ Schema defined in workflow-schema.md
        - ✅ Types defined in types.ts
        - ✅ Validation in validate.ts
        - ✅ Compilation in compile.ts
        - ❌ **Runtime execution missing in loop.ts**

        The bash implementation (sprint-loop.sh) had `spawn_per_iteration_hooks()`
        but this was lost during TypeScript migration.

        ## Expected Behavior

        When a sprint has enabled per-iteration hooks:

        ```yaml
        per-iteration-hooks:
          - id: learning
            prompt: /m42-signs:extract $ITERATION_TRANSCRIPT --auto-apply-high
            parallel: true
            enabled: true
        ```

        After each iteration, the runtime should:
        1. Check if any hooks are enabled
        2. For each enabled hook, spawn a Claude process with the hook's prompt
        3. Replace template variables ($ITERATION_TRANSCRIPT)
        4. If `parallel: true`, run in background without blocking next iteration
        5. Track hook execution in hook-tasks array

        ## Implementation Checklist

        ### 1. Add Hook Execution to Loop

        File: `plugins/m42-sprint/runtime/src/loop.ts`

        In the main loop, after each iteration completes:
        - [ ] Read `progress['per-iteration-hooks']`
        - [ ] Filter to enabled hooks
        - [ ] For each enabled hook:
          - [ ] Build hook prompt (replace $ITERATION_TRANSCRIPT)
          - [ ] Spawn Claude via `deps.runClaude()`
          - [ ] If `parallel: true`, use background execution
          - [ ] Track in `progress['hook-tasks']`

        ### 2. Add Template Variable Support

        Support these variables in hook prompts:
        - [ ] `$ITERATION_TRANSCRIPT` → path to current iteration's transcript
        - [ ] `$SPRINT_ID` → sprint identifier
        - [ ] `$ITERATION` → iteration number
        - [ ] `$PHASE_ID` → current phase identifier

        ### 3. Add Hook Task Tracking

        Track hook executions:
        ```typescript
        interface HookTask {
          id: string;
          hookId: string;
          iteration: number;
          status: 'running' | 'completed' | 'failed';
          startedAt: string;
          completedAt?: string;
          output?: string;
        }
        ```

        ### 4. Integration Tests

        File: `plugins/m42-sprint/runtime/src/hooks.test.ts`

        - [ ] Test: enabled hook executes after iteration
        - [ ] Test: disabled hook is skipped
        - [ ] Test: parallel hook runs non-blocking
        - [ ] Test: sequential hook blocks next iteration
        - [ ] Test: template variables are replaced
        - [ ] Test: hook task is tracked in progress

        ### 5. Documentation Updates

        - [ ] Update docs/concepts/ralph-mode.md with hook execution details
        - [ ] Update workflow-schema.md with runtime behavior
        - [ ] Add example workflow demonstrating hook usage

        ## Reference Implementation

        The bash version was in `sprint-loop.sh` (deleted in commit 882922d):

        ```bash
        spawn_per_iteration_hooks() {
          local iteration=$1
          local hooks_count=$(yq -r '.per-iteration-hooks // [] | map(select(.enabled == true)) | length' "$PROGRESS_FILE")

          for ((h=0; h<hooks_count; h++)); do
            local hook_id=$(yq -r ".per-iteration-hooks | map(select(.enabled == true))[$h].id" "$PROGRESS_FILE")
            local prompt=$(yq -r ".per-iteration-hooks | map(select(.enabled == true))[$h].prompt // \"\"" "$PROGRESS_FILE")
            local parallel=$(yq -r ".per-iteration-hooks | map(select(.enabled == true))[$h].parallel // false" "$PROGRESS_FILE")

            # Spawn hook process (with or without background)
            # ...
          done
        }
        ```

        ## Acceptance Criteria

        - [ ] Integration tests pass
        - [ ] Real sprint with learning hook enabled works
        - [ ] Hook transcripts are created in correct location
        - [ ] Parallel hooks don't block next iteration
        - [ ] Hook failures don't crash the sprint
        - [ ] Documentation updated

    # ========================================================================
    # Step 4: Improve creating-workflows Skill Discoverability
    # ========================================================================
    - prompt: |
        /m42-meta-toolkit:create-skill Improve the creating-workflows skill with inline schema and patterns.

        ## Context
        Feedback from agent: When invoking creating-workflows, the agent got the
        SKILL.md but didn't automatically see critical reference files. Had to dig
        through multiple files to understand current patterns.

        Read context file: context/skill-discoverability-feedback.md

        ## Requirements

        ### 1. Add Quick Reference Section

        File: plugins/m42-sprint/skills/creating-workflows/SKILL.md

        Add a "Quick Reference" section with condensed, copy-paste ready syntax:

        ```markdown
        ## Quick Reference (Cheat Sheet)

        ### Workflow Structure
        ```yaml
        name: <string>           # Required
        description: <string>    # Optional
        phases:                  # Required - list of phases
          - id: <string>         # Required, unique identifier
            prompt: <string>     # For simple phases (direct execution)
            # OR
            for-each: <string>   # Collection name to iterate
            workflow: <string>   # Workflow to run per item
        ```

        ### Phase Types
        | Type | Required Fields | Use Case |
        |------|-----------------|----------|
        | Simple | `id`, `prompt` | Direct execution of instructions |
        | For-Each | `id`, `for-each`, `workflow` | Iterate over collection items |

        ### Template Variables
        | Variable | Description |
        |----------|-------------|
        | `{{item.prompt}}` | Current item's prompt |
        | `{{item.id}}` | Current item's ID |
        | `{{sprint.id}}` | Sprint identifier |
        | `{{sprint.name}}` | Sprint name |

        ### Optional Phase Fields
        | Field | Type | Description |
        |-------|------|-------------|
        | `parallel` | boolean | Run in background (item workflows only) |
        | `wait-for-parallel` | boolean | Sync point for parallel tasks |
        | `break` | boolean | Pause for human review after completion |
        | `gate` | object | Quality gate script + on-fail handling |
        ```

        ### 2. Add Current Patterns Section

        Add a section showing available workflow patterns:

        ```markdown
        ## Current Workflow Patterns

        ### sprint-default.yaml
        **Phases**: prepare → development (for-each) → qa → deploy
        **Use for**: Standard sprint execution with QA gates

        ### plugin-development.yaml
        **Phases**: preflight → development (TDD) → docs → tooling → version → qa → summary → pr
        **Use for**: Plugin development with TDD and documentation

        ### feature-standard.yaml
        **Phases**: planning → implement → test → document
        **Use for**: Single feature implementation

        ### bugfix-workflow.yaml
        **Phases**: diagnose → fix → verify
        **Use for**: Bug investigation and fixing

        ### ralph.yaml
        **Type**: Goal-driven autonomous mode
        **Use for**: Complex, research-heavy, open-ended goals
        ```

        ### 3. Add "Read These First" Guidance

        At the top of the skill, add explicit guidance:

        ```markdown
        ## Before You Start

        For complete reference, read these files:
        1. **Schema**: `references/workflow-schema.md` - Full field definitions
        2. **Examples**: `.claude/workflows/` - Working workflow files

        The Quick Reference below covers common cases. For edge cases, consult the schema.
        ```

        ### 4. Verify Integration

        - Reference files should still be the authoritative source
        - Quick reference is a convenience, not a replacement
        - Patterns section helps agents choose the right workflow

    # ========================================================================
    # Step 5: Add Schema Version Field + Compiler Warnings
    # ========================================================================
    - prompt: |
        Add schema versioning to workflows with compiler warnings.

        ## Context
        Feedback: No way to know if local workflows are current or outdated.
        Workflows created months ago may use deprecated patterns.

        ## Requirements

        ### 1. Add Schema Version Constant

        File: plugins/m42-sprint/compiler/src/types.ts

        Add:
        ```typescript
        /** Current workflow schema version */
        export const CURRENT_SCHEMA_VERSION = '2.0';

        /** Minimum supported schema version */
        export const MIN_SCHEMA_VERSION = '1.0';
        ```

        ### 2. Update WorkflowDefinition Type

        File: plugins/m42-sprint/compiler/src/types.ts

        Add optional field:
        ```typescript
        interface WorkflowDefinition {
          name: string;
          description?: string;
          'schema-version'?: string;  // Add this field
          phases?: WorkflowPhase[];
          // ... rest of fields
        }
        ```

        ### 3. Add Version Validation

        File: plugins/m42-sprint/compiler/src/validate.ts

        Add validation function:
        ```typescript
        function validateSchemaVersion(
          workflow: WorkflowDefinition,
          workflowName: string,
          warnings: string[]
        ): void {
          const version = workflow['schema-version'];

          if (!version) {
            warnings.push(
              `Workflow '${workflowName}' has no schema-version field. ` +
              `Consider adding: schema-version: "${CURRENT_SCHEMA_VERSION}"`
            );
            return;
          }

          if (version !== CURRENT_SCHEMA_VERSION) {
            warnings.push(
              `Workflow '${workflowName}' uses schema-version ${version}. ` +
              `Current version is ${CURRENT_SCHEMA_VERSION}. Consider updating.`
            );
          }
        }
        ```

        Call this function in the workflow validation.

        ### 4. Update Workflow Templates

        Update all workflow files in .claude/workflows/ to include:
        ```yaml
        schema-version: "2.0"
        name: ...
        ```

        ### 5. Update Documentation

        File: plugins/m42-sprint/skills/creating-workflows/references/workflow-schema.md

        Add schema-version field documentation:
        ```markdown
        | Field | Type | Required | Description |
        |-------|------|----------|-------------|
        | `schema-version` | string | Recommended | Schema version (current: "2.0") |
        ```

        ### 6. Add Tests

        File: plugins/m42-sprint/compiler/src/validate.test.ts

        Add tests:
        - Test: missing schema-version produces warning
        - Test: outdated schema-version produces warning
        - Test: current schema-version produces no warning

    # ========================================================================
    # Step 6: Create validating-workflows Skill
    # ========================================================================
    - prompt: |
        /m42-meta-toolkit:create-skill validating-workflows

        Create a skill for validating workflow files that Claude can invoke on demand.

        ## Context
        Users and Claude should be able to validate workflows before running sprints.
        This skill provides validation with helpful output and can be triggered
        automatically when Claude detects workflow issues.

        ## Requirements

        ### 1. Skill File Structure

        Create: plugins/m42-sprint/skills/validating-workflows/SKILL.md

        ### 2. Triggers

        This skill should trigger on:
        - "validate workflow"
        - "check workflow"
        - "workflow validation"
        - "is this workflow valid"
        - "workflow errors"

        ### 3. Skill Content

        The skill should guide the agent to:

        #### Step 1: Identify Workflow File
        - Accept workflow path as argument or find from context
        - Support both relative and absolute paths

        #### Step 2: Run Compiler Validation

        Use the compiler's validation:

        ```bash
        node "plugins/m42-sprint/compiler/dist/index.js" validate "$WORKFLOW_PATH"
        ```

        The compiler should output JSON with:
        ```json
        {
          "valid": true|false,
          "errors": [...],
          "warnings": [...]
        }
        ```

        #### Step 3: Format Output

        Display results in user-friendly format:

        ```
        Validating: my-workflow.yaml

        ✓ Schema structure valid
        ✓ Phase IDs unique
        ✓ Workflow references resolve
        ⚠ Schema version 1.0 (current: 2.0)
        ⚠ Consider adding description field

        Validation: PASS (2 warnings)
        ```

        Or on errors:
        ```
        Validating: my-workflow.yaml

        ✗ Missing required field: name
        ✗ Phase 'dev' has both prompt and for-each
        ⚠ Schema version not specified

        Validation: FAIL (2 errors, 1 warning)
        ```

        ### 4. Add Validate Subcommand to Compiler CLI

        File: plugins/m42-sprint/compiler/src/index.ts

        Add a `validate` subcommand that:
        - Takes a workflow path as argument
        - Runs validation only (no compilation)
        - Outputs JSON result

        ```typescript
        if (args[0] === 'validate') {
          const workflowPath = args[1];
          const result = validateWorkflowFile(workflowPath);
          console.log(JSON.stringify(result, null, 2));
          process.exit(result.valid ? 0 : 1);
        }
        ```

        ### 5. Test the Skill

        Verify with test workflow files:
        - valid-workflow.yaml (should pass)
        - invalid-workflow.yaml (should fail)
        - outdated-workflow.yaml (should warn)

    # ========================================================================
    # Step 7: Refactor run-sprint Command
    # ========================================================================
    - prompt: |
        /m42-meta-toolkit:create-command run-sprint

        Refactor the existing run-sprint command.

        ## Issue
        The preflight checks are documented but not directly invoked as executable
        validation steps. The agent has to interpret the documentation rather than
        execute structured checks.

        ## Goal
        Make preflight checks directly executable with clear error messages.
        Follow creating-commands best practices for the improvement.

        ## Existing Command
        File: plugins/m42-sprint/commands/run-sprint.md

    # ========================================================================
    # Step 8: Refactor init-sprint Command
    # ========================================================================
    - prompt: |
        /m42-meta-toolkit:create-command init-sprint

        Refactor the existing init-sprint command.

        ## Issue
        The preflight checks are documented but not directly invoked as executable
        validation steps. The agent has to interpret the documentation rather than
        execute structured checks.

        ## Goal
        Make preflight checks directly executable with clear error messages.
        Follow creating-commands best practices for the improvement.

        ## Existing Command
        File: plugins/m42-sprint/commands/init-sprint.md

    # ========================================================================
    # Step 9: Fix Worktree Continuation Bug in run-sprint
    # ========================================================================
    - prompt: |
        Fix the worktree continuation bug in the run-sprint command.

        ## Bug Description

        When run-sprint creates a worktree for a sprint, it currently:
        1. Creates the worktree
        2. Copies sprint files to the worktree
        3. **EXITS** with a message telling user to manually cd and re-run

        This is wrong. The command should:
        1. Create the worktree
        2. Copy sprint files to the worktree
        3. **CONTINUE** execution with the worktree path (no manual intervention)

        ## Location

        File: plugins/m42-sprint/commands/run-sprint.md
        Section: "Worktree Setup (Automatic)" (lines ~81-147)

        ## Current Buggy Code

        ```bash
        # Copy sprint files to worktree
        WORKTREE_SPRINT_DIR="${WORKTREE_PATH}/.claude/sprints/${SPRINT_ID}"
        mkdir -p "$WORKTREE_SPRINT_DIR"
        cp -r "${SPRINT_DIR}"/* "$WORKTREE_SPRINT_DIR/"

        echo ""
        echo "Worktree created successfully!"
        echo "Sprint directory: $WORKTREE_SPRINT_DIR"
        echo ""
        echo "To run the sprint in the worktree:"
        echo "  cd $WORKTREE_PATH && /run-sprint .claude/sprints/${SPRINT_ID}"
        echo ""

        # Exit here - user should run from worktree
        exit 0
        ```

        ## Expected Fix

        After creating the worktree and copying files:
        1. Update SPRINT_DIR to point to the worktree's sprint directory
        2. Update WORKFLOWS_DIR to point to the worktree's workflows
        3. Continue with the "Workflow Compilation" section
        4. Launch runtime with `cd "$WORKTREE_PATH" && ...`

        ```bash
        # Copy sprint files to worktree
        WORKTREE_SPRINT_DIR="${WORKTREE_PATH}/.claude/sprints/${SPRINT_ID}"
        mkdir -p "$WORKTREE_SPRINT_DIR"
        cp -r "${SPRINT_DIR}"/* "$WORKTREE_SPRINT_DIR/"

        echo "Worktree created: $WORKTREE_PATH"
        echo "Sprint directory: $WORKTREE_SPRINT_DIR"

        # Update paths to use worktree - CONTINUE execution, don't exit
        SPRINT_DIR="$WORKTREE_SPRINT_DIR"
        WORKFLOWS_DIR="${WORKTREE_PATH}/.claude/workflows"
        WORKTREE_CWD="$WORKTREE_PATH"  # Use this for runtime launch
        ```

        Then in the "Launch Sprint Loop" section, use:
        ```bash
        cd "$WORKTREE_CWD" && node "${CLAUDE_PLUGIN_ROOT}/runtime/dist/cli.js" run "$SPRINT_DIR" ...
        ```

        ## Acceptance Criteria

        - [ ] Worktree is created automatically when workflow enables it
        - [ ] Sprint files are copied to worktree
        - [ ] Execution continues without manual cd/re-run
        - [ ] Runtime runs from within the worktree directory
        - [ ] Status server runs from within the worktree directory
        - [ ] User sees worktree path in status output
        - [ ] Remove the "exit 0" and manual instructions

# Sprint metadata
sprint-id: 2026-01-29_workflow-qa-improvements
name: workflow-qa-improvements
created: 2026-01-29T14:00:00Z
