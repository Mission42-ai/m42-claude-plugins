# Auto-generated Bug Fixing Sprint
# Generated from: 2026-01-20_bughunt-m42-sprint

workflow: bughunt-fixing

steps:
  # Phase 1: High Priority (Security & Data Integrity)

  - prompt: |
      BUG-006 + BUG-012: Path Traversal Hardening

      **Severity**: high
      **Feature**: status-server

      **Files**:
      - `compiler/src/status-server/server.ts:1295-1299` (getLogFilePath)

      **Issue**: The `getLogFilePath` method sanitizes phaseId but lacks explicit path containment verification. While current regex sanitization prevents most traversal, defense-in-depth requires explicit validation.

      **Current Code**:
      ```typescript
      private getLogFilePath(phaseId: string): string {
        const sanitized = phaseId.replace(/ > /g, '-').replace(/[^a-zA-Z0-9-_]/g, '_');
        return path.join(this.config.sprintDir, 'logs', `${sanitized}.log`);
      }
      ```

      **Fix**: After constructing the path, verify it's within the expected logs directory:
      ```typescript
      const resolved = path.resolve(logPath);
      const logsDir = path.resolve(this.config.sprintDir, 'logs');
      if (!resolved.startsWith(logsDir + path.sep)) {
        throw new Error('Invalid log path');
      }
      ```

      **Notes**: Both BUG-006 and BUG-012 describe the same issue. Fix once with proper containment check.

  - prompt: |
      BUG-010: Signal Files Cleanup on Sprint Completion

      **Severity**: high
      **Feature**: status-server

      **File**: `compiler/src/status-server/server.ts:896-989`

      **Issue**: Signal files (.pause-requested, .resume-requested, .stop-requested, .force-retry-requested) are created by API calls but never cleaned up when sprint completes.

      **Repro Steps**:
      1. Start a sprint with status server
      2. Pause the sprint via API
      3. Sprint completes or is stopped
      4. Signal file remains in sprint directory
      5. Restart sprint - may behave unexpectedly due to leftover signal

      **Expected**: Signal files cleaned up when sprint reaches terminal state
      **Actual**: Signal files persist indefinitely

      **Fix**: Add cleanup method and call it when sprint transitions to completed/failed/stopped state:
      ```typescript
      private cleanupSignalFiles(): void {
        const signals = ['.pause-requested', '.resume-requested', '.stop-requested', '.force-retry-requested'];
        for (const signal of signals) {
          const signalPath = path.join(this.config.sprintDir, signal);
          try { fs.unlinkSync(signalPath); } catch {}
        }
      }
      ```

      **Notes**: Also consider cleanup at sprint start to handle leftover files from crashed sprints.

  - prompt: |
      BUG-002: Race Condition on PROGRESS.yaml

      **Severity**: high
      **Feature**: runtime/loop

      **File**: `runtime/src/loop.ts:361-417`

      **Issue**: The loop performs backup → Claude execution → write cycle without holding a lock on PROGRESS.yaml. If the status server modifies the file via /api/skip or /api/retry during Claude execution, those changes are lost when the loop writes its version.

      **Repro Steps**:
      1. Start a sprint with long-running Claude task
      2. While Claude is executing, call /api/skip via status server
      3. Status server writes skip action to PROGRESS.yaml
      4. Claude completes and loop writes its PROGRESS.yaml
      5. Skip action is lost

      **Expected**: Skip action persists after Claude completes
      **Actual**: Skip action overwritten by loop's write

      **Fix Options**:
      1. File locking using `proper-lockfile` or similar
      2. Compare-and-swap: read file before write, merge changes, write
      3. Event-based: status server signals loop via IPC instead of file modification

      **Recommended**: Option 2 (compare-and-swap) with checksum verification:
      - Store file hash before Claude execution
      - Before writing, check if hash changed
      - If changed, read current file, merge changes, write

      **Notes**: This is the most complex fix. Design carefully to avoid introducing new race conditions. May need to defer modifications like skip/retry until between step executions.

  # Phase 2: Medium Priority (Reliability)

  - prompt: |
      BUG-004 + BUG-008 + BUG-009: Null/Undefined Access Safety

      **Severity**: medium
      **Feature**: runtime/transition, compiler/expand-foreach

      **Files**:
      - `runtime/src/transition.ts:330-339` (createPointerForPhase)
      - `runtime/src/transition.ts:346-416` (advancePointer)
      - `compiler/src/expand-foreach.ts:103`

      **BUG-004**: `createPointerForPhase` doesn't check if phases array is empty before accessing `phases[phaseIndex]`.

      **BUG-008**: `advancePointer` sets `sub-phase: 0` when advancing to next step, even if that step has no sub-phases.

      **BUG-009**: Non-null assertion `phase.steps!` used after truthiness check, but could fail if value changes between check and use.

      **Fix Pattern**: Replace non-null assertions with optional chaining and add explicit bounds checks:
      ```typescript
      // Instead of: phase.steps![0].phases
      // Use: phase.steps?.[0]?.phases

      // Add bounds checking:
      if (!phases || phases.length === 0) return null;
      if (phaseIndex >= phases.length) return null;
      ```

      **Notes**: Fix all three together for consistency. Add unit tests for edge cases.

  - prompt: |
      BUG-001: Workflow Cache Staleness

      **Severity**: medium
      **Feature**: compiler

      **File**: `compiler/src/resolve-workflows.ts:20-38`

      **Issue**: Module-level workflow cache persists across compilations. In watch mode or long-running processes, modified workflow files use stale cached versions.

      **Current Code**:
      ```typescript
      const workflowCache = new Map<string, LoadedWorkflow>();

      export function loadWorkflow(name: string, workflowsDir: string, errors?: CompilerError[]): LoadedWorkflow | null {
        const cacheKey = `${workflowsDir}:${name}`;
        if (workflowCache.has(cacheKey)) {
          return workflowCache.get(cacheKey)!;
        }
        // ... loads and caches
      }
      ```

      **Fix Options**:
      1. Export `clearWorkflowCache()` and call at compilation start
      2. Add file mtime checking before returning cached value
      3. Remove caching entirely (simplest, minor perf impact)

      **Recommended**: Option 1 - add cache clear function:
      ```typescript
      export function clearWorkflowCache(): void {
        workflowCache.clear();
      }
      ```
      Call from compile() entry point.

      **Notes**: Simple fix with low risk. Affects watch mode workflows.

  - prompt: |
      BUG-011 + BUG-014 + BUG-015 + BUG-016: Pagination Parameter Validation

      **Severity**: medium
      **Feature**: status-server

      **File**: `compiler/src/status-server/server.ts:516-537`

      **Issues**:
      - BUG-011: Negative page returns empty results with `hasMore: true`
      - BUG-014: Page=0 returns empty results with misleading metadata
      - BUG-015: Non-numeric page returns `page: null`
      - BUG-016: Negative limit causes unexpected slice behavior

      **Current Code**:
      ```typescript
      const page = parseInt(params.get('page') || '1', 10);
      const limit = parseInt(params.get('limit') || '20', 10);
      const offset = (page - 1) * limit;
      const sprints = allSprints.slice(offset, offset + limit);
      ```

      **Fix**: Add validation utility and apply to all pagination endpoints:
      ```typescript
      function validatePagination(params: URLSearchParams): { page: number; limit: number } | { error: string } {
        const pageStr = params.get('page') || '1';
        const limitStr = params.get('limit') || '20';

        const page = parseInt(pageStr, 10);
        const limit = parseInt(limitStr, 10);

        if (isNaN(page) || page < 1) return { error: 'page must be a positive integer' };
        if (isNaN(limit) || limit < 1 || limit > 100) return { error: 'limit must be between 1 and 100' };

        return { page, limit };
      }
      ```

      **Notes**: Apply same validation to all paginated endpoints for consistency.

  # Phase 3: Low Priority (Polish)

  - prompt: |
      BUG-003 + BUG-013: CLI Numeric Parameter Validation

      **Severity**: low
      **Feature**: runtime/cli

      **File**: `runtime/src/cli.ts:101-109`

      **BUG-003**: `--max-iterations` accepts non-numeric values, resulting in NaN
      **BUG-013**: `--delay` accepts negative values

      **Current Code**:
      ```typescript
      if (arg === '--max-iterations' || arg === '-n') {
        const value = cliArgs[++i];
        if (value !== undefined) {
          result.options.maxIterations = parseInt(value, 10);
          // No NaN check
        }
      }
      ```

      **Fix**: Add validation helper and use for all numeric params:
      ```typescript
      function parsePositiveInt(value: string, paramName: string): number | string {
        const parsed = parseInt(value, 10);
        if (isNaN(parsed)) return `Invalid number for ${paramName}`;
        if (parsed < 0) return `${paramName} must be non-negative`;
        return parsed;
      }
      ```

      **Notes**: Simple validation fixes. Low impact since invalid args are uncommon.

  - prompt: |
      BUG-007: Async/Sync API Consistency

      **Severity**: low
      **Feature**: runtime/yaml-ops

      **File**: `runtime/src/yaml-ops.ts:106-139`

      **Issue**: `writeProgressAtomic` is declared async but uses `fs.writeFileSync` and `fs.renameSync`, blocking the event loop.

      **Current Code**:
      ```typescript
      export async function writeProgressAtomic(filePath: string, progress: CompiledProgress): Promise<void> {
        fs.writeFileSync(tempPath, content, 'utf8');
        fs.renameSync(tempPath, filePath);
      }
      ```

      **Fix Options**:
      1. Make truly async using `fs.promises.writeFile` and `fs.promises.rename`
      2. Remove async/Promise and rename to `writeProgressAtomicSync`

      **Recommended**: Option 1 - make truly async for better event loop behavior:
      ```typescript
      await fs.promises.writeFile(tempPath, content, 'utf8');
      await fs.promises.rename(tempPath, filePath);
      ```

      **Notes**: Cosmetic fix. Current code works but misleads callers about blocking behavior.

  - prompt: |
      BUG-005: Error Classifier Pattern Ordering

      **Severity**: low
      **Feature**: compiler/error-classifier

      **File**: `compiler/src/error-classifier.ts:83-89, 126-144`

      **Issue**: The 'logic' category has overly broad patterns (`/error/i`, `/failed/i`) that could match before more specific patterns due to loop structure.

      **Current Code**:
      ```typescript
      const categoryPriority: ErrorCategory[] = [
        'network', 'rate-limit', 'timeout', 'validation',
        'logic', // Intended as fallback
      ];
      ```

      **Issue**: The loop iterates categories in priority order, but 'logic' patterns are so broad they might match strings intended for other categories.

      **Fix Options**:
      1. Restructure to check all specific patterns first, then logic
      2. Make logic patterns more specific
      3. Add explicit fallback handling after all categories checked

      **Recommended**: Check if current behavior is actually causing issues. The priority order *should* work correctly since logic is last. Review the skip logic at line 132 for clarity.

      **Notes**: Lower priority - may be a code clarity issue rather than a functional bug. Add unit tests to verify current behavior is correct.

# Sprint metadata
sprint-id: 2026-01-20_bughunt-m42-sprint-fixing
name: Bug Fixes for m42-sprint Plugin
created: 2026-01-20T12:00:00Z
parent-sprint: 2026-01-20_bughunt-m42-sprint
total-bugs: 16
priority-breakdown:
  high: 3
  medium: 6
  low: 7
