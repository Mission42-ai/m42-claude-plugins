sprint-id: 2026-01-17_plugin-enhancements
status: in-progress
phases:
  - id: preflight
    status: completed
    prompt: >
      Create comprehensive sprint context that ALL subsequent phases will reference.


      ## Your Task

      Analyze the entire sprint scope and generate shared context documents.


      ## Step 1: Create Sprint Branch

      ```bash

      git checkout -b sprint/2026-01-17_plugin-enhancements 2>/dev/null || git checkout sprint/2026-01-17_plugin-enhancements

      ```


      ## Step 2: Analyze Sprint Scope

      Read SPRINT.yaml to understand:

      - All steps and their relationships

      - Overall sprint goal

      - Technical requirements across all steps

      - Potential dependencies between steps


      ## Step 3: Research Project Context

      Investigate the codebase to understand:

      - Project architecture and structure

      - Key patterns and conventions used

      - Relevant types and interfaces

      - Build/test/lint commands

      - Dependencies (internal modules, external packages)


      ## Step 4: Generate Shared Context

      Create: context/_shared-context.md


      ```markdown

      # Shared Sprint Context


      ## Project Architecture

      [High-level architecture overview relevant to this sprint]


      ## Key Patterns

      - [Pattern 1]: [Where and how it's used]

      - [Pattern 2]: [Where and how it's used]

      ...


      ## Conventions

      - Naming: [Naming conventions]

      - File structure: [File organization patterns]

      - Testing: [Testing patterns and frameworks]

      - Error handling: [Error handling patterns]


      ## Commands

      - Build: `[build command]`

      - Test: `[test command]`

      - Lint: `[lint command]`

      - TypeCheck: `[typecheck command]`


      ## Dependencies

      ### Internal Modules

      - [Module]: [Purpose]


      ### External Packages

      - [Package]: [Usage]


      ## Types and Interfaces

      [Key types relevant to this sprint]

      ```


      ## Step 5: Generate Sprint Plan

      Create: context/sprint-plan.md


      ```markdown

      # Sprint Plan: 2026-01-17_plugin-enhancements


      ## Goal

      [One paragraph describing what this sprint accomplishes]


      ## Success Criteria

      - [ ] [Measurable criterion 1]

      - [ ] [Measurable criterion 2]

      ...


      ## Step Breakdown


      ### Step 0: [Step title from prompt]

      **Scope**: [What this step does]

      **Files**: [Expected files to create/modify]

      **Dependencies**: [What it depends on]

      **Risk**: Low/Medium/High - [reason]


      ### Step 1: ...

      [Continue for all steps]


      ## Step Dependency Graph

      ```

      step-0 → step-1 → step-2


























































































































































































































































































































































































































































































                ↓
              step-3
      ```

      [Or describe dependencies textually]


      ## Risk Assessment

      | Risk | Impact | Mitigation |

      |------|--------|------------|

      | [Risk 1] | [Impact] | [How to mitigate] |


      ## Estimated Complexity

      | Step | Complexity | Reason |

      |------|------------|--------|

      | step-0 | Low/Medium/High | [Brief reason] |

      ```


      ## Output

      - Sprint branch created/checked out

      - context/_shared-context.md with project patterns

      - context/sprint-plan.md with step analysis

      - Commit preflight artifacts:


























































































































































































































































































































































































































































































        ```bash
        git add context/
        git commit -m "preflight: add shared context and sprint plan"
        ```
    started-at: "2026-01-17T00:35:52Z"
    completed-at: "2026-01-17T00:35:52Z"
    elapsed: 00:00:00
  - id: development
    status: in-progress
    steps:
      - id: step-0
        prompt: |
          Phase 1 - Step 1: Fix Elapsed Timer Running Indefinitely

          The elapsed time timer continues updating after sprint completes/pauses/fails.

          Requirements:
          - Modify `updateElapsedTimes()` function in page.ts
          - Check sprint status before updating timers
          - Stop updating for terminal statuses: 'completed', 'failed', 'stopped', 'blocked'
          - Also handle 'paused' status (freeze timer, don't stop)
          - Ensure timer resumes correctly when sprint is resumed from pause

          Verification:
          - Complete a sprint, verify timer stops at completion time
          - Pause a sprint, verify timer freezes
          - Resume a sprint, verify timer continues from paused value

          File to modify:
          - plugins/m42-sprint/compiler/src/status-server/page.ts (~line 2989, updateElapsedTimes function)
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 1 - Step 1: Fix Elapsed Timer Running Indefinitely

              The elapsed time timer continues updating after sprint completes/pauses/fails.

              Requirements:
              - Modify `updateElapsedTimes()` function in page.ts
              - Check sprint status before updating timers
              - Stop updating for terminal statuses: 'completed', 'failed', 'stopped', 'blocked'
              - Also handle 'paused' status (freeze timer, don't stop)
              - Ensure timer resumes correctly when sprint is resumed from pause

              Verification:
              - Complete a sprint, verify timer stops at completion time
              - Pause a sprint, verify timer freezes
              - Resume a sprint, verify timer continues from paused value

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (~line 2989, updateElapsedTimes function)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-0-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-0

              ## Step Task
              Phase 1 - Step 1: Fix Elapsed Timer Running Indefinitely

              The elapsed time timer continues updating after sprint completes/pauses/fails.

              Requirements:
              - Modify `updateElapsedTimes()` function in page.ts
              - Check sprint status before updating timers
              - Stop updating for terminal statuses: 'completed', 'failed', 'stopped', 'blocked'
              - Also handle 'paused' status (freeze timer, don't stop)
              - Ensure timer resumes correctly when sprint is resumed from pause

              Verification:
              - Complete a sprint, verify timer stops at completion time
              - Pause a sprint, verify timer freezes
              - Resume a sprint, verify timer continues from paused value

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (~line 2989, updateElapsedTimes function)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-0-gherkin.md
              git commit -m "plan(step-0): define gherkin scenarios"
              ```
            started-at: "2026-01-17T00:38:43Z"
            completed-at: "2026-01-17T00:38:43Z"
            elapsed: 00:00:00
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 1 - Step 1: Fix Elapsed Timer Running Indefinitely

              The elapsed time timer continues updating after sprint completes/pauses/fails.

              Requirements:
              - Modify `updateElapsedTimes()` function in page.ts
              - Check sprint status before updating timers
              - Stop updating for terminal statuses: 'completed', 'failed', 'stopped', 'blocked'
              - Also handle 'paused' status (freeze timer, don't stop)
              - Ensure timer resumes correctly when sprint is resumed from pause

              Verification:
              - Complete a sprint, verify timer stops at completion time
              - Pause a sprint, verify timer freezes
              - Resume a sprint, verify timer continues from paused value

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (~line 2989, updateElapsedTimes function)


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-0-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-0-context.md

              ```markdown
              # Step Context: step-0

              ## Task
              Phase 1 - Step 1: Fix Elapsed Timer Running Indefinitely

              The elapsed time timer continues updating after sprint completes/pauses/fails.

              Requirements:
              - Modify `updateElapsedTimes()` function in page.ts
              - Check sprint status before updating timers
              - Stop updating for terminal statuses: 'completed', 'failed', 'stopped', 'blocked'
              - Also handle 'paused' status (freeze timer, don't stop)
              - Ensure timer resumes correctly when sprint is resumed from pause

              Verification:
              - Complete a sprint, verify timer stops at completion time
              - Pause a sprint, verify timer freezes
              - Resume a sprint, verify timer continues from paused value

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (~line 2989, updateElapsedTimes function)


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-0-context.md
              git commit -m "context(step-0): gather implementation context"
              ```
            started-at: "2026-01-17T00:40:42Z"
            completed-at: "2026-01-17T00:40:42Z"
            elapsed: 00:00:00
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 1 - Step 1: Fix Elapsed Timer Running Indefinitely

              The elapsed time timer continues updating after sprint completes/pauses/fails.

              Requirements:
              - Modify `updateElapsedTimes()` function in page.ts
              - Check sprint status before updating timers
              - Stop updating for terminal statuses: 'completed', 'failed', 'stopped', 'blocked'
              - Also handle 'paused' status (freeze timer, don't stop)
              - Ensure timer resumes correctly when sprint is resumed from pause

              Verification:
              - Complete a sprint, verify timer stops at completion time
              - Pause a sprint, verify timer freezes
              - Resume a sprint, verify timer continues from paused value

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (~line 2989, updateElapsedTimes function)


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-0-gherkin.md (scenarios to satisfy)
              4. context/step-0-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-0): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-17T00:42:05Z"
            completed-at: "2026-01-17T00:42:06Z"
            elapsed: 00:00:01
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-0-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-0-qa-report.md

              ```markdown
              # QA Report: step-0

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-0-qa-report.md
                 git commit -m "qa(step-0): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-0.\n\n## Context\nRead: artifacts/step-0-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-0-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-0-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-0 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-17T00:43:34Z"
            completed-at: "2026-01-17T00:45:07Z"
            elapsed: 00:01:33
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 1 - Step 1: Fix Elapsed Timer Running Indefinitely

              The elapsed time timer continues updating after sprint completes/pauses/fails.

              Requirements:
              - Modify `updateElapsedTimes()` function in page.ts
              - Check sprint status before updating timers
              - Stop updating for terminal statuses: 'completed', 'failed', 'stopped', 'blocked'
              - Also handle 'paused' status (freeze timer, don't stop)
              - Ensure timer resumes correctly when sprint is resumed from pause

              Verification:
              - Complete a sprint, verify timer stops at completion time
              - Pause a sprint, verify timer freezes
              - Resume a sprint, verify timer continues from paused value

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (~line 2989, updateElapsedTimes function)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-0-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-0): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-17T00:45:19Z"
            completed-at: "2026-01-17T00:45:19Z"
            elapsed: 00:00:00
        started-at: "2026-01-17T00:38:43Z"
      - id: step-1
        prompt: |
          Phase 1 - Step 2: Update Default Max Iterations (30 → 60)

          The default of 30 iterations is insufficient for larger sprints.

          Requirements:
          - Update default value in run-sprint.md command documentation
          - Update reference documentation in docs/reference/commands.md
          - Update USER-GUIDE.md with new default
          - Ensure all mentions of "default: 30" are changed to "default: 60"

          Verification:
          - Search for all occurrences of max-iterations default value
          - Verify consistency across all documentation

          Files to modify:
          - plugins/m42-sprint/commands/run-sprint.md
          - plugins/m42-sprint/docs/reference/commands.md
          - plugins/m42-sprint/docs/USER-GUIDE.md
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 1 - Step 2: Update Default Max Iterations (30 → 60)

              The default of 30 iterations is insufficient for larger sprints.

              Requirements:
              - Update default value in run-sprint.md command documentation
              - Update reference documentation in docs/reference/commands.md
              - Update USER-GUIDE.md with new default
              - Ensure all mentions of "default: 30" are changed to "default: 60"

              Verification:
              - Search for all occurrences of max-iterations default value
              - Verify consistency across all documentation

              Files to modify:
              - plugins/m42-sprint/commands/run-sprint.md
              - plugins/m42-sprint/docs/reference/commands.md
              - plugins/m42-sprint/docs/USER-GUIDE.md


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-1-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-1

              ## Step Task
              Phase 1 - Step 2: Update Default Max Iterations (30 → 60)

              The default of 30 iterations is insufficient for larger sprints.

              Requirements:
              - Update default value in run-sprint.md command documentation
              - Update reference documentation in docs/reference/commands.md
              - Update USER-GUIDE.md with new default
              - Ensure all mentions of "default: 30" are changed to "default: 60"

              Verification:
              - Search for all occurrences of max-iterations default value
              - Verify consistency across all documentation

              Files to modify:
              - plugins/m42-sprint/commands/run-sprint.md
              - plugins/m42-sprint/docs/reference/commands.md
              - plugins/m42-sprint/docs/USER-GUIDE.md


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-1-gherkin.md
              git commit -m "plan(step-1): define gherkin scenarios"
              ```
            started-at: "2026-01-17T00:46:40Z"
            completed-at: "2026-01-17T00:46:40Z"
            elapsed: 00:00:00
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 1 - Step 2: Update Default Max Iterations (30 → 60)

              The default of 30 iterations is insufficient for larger sprints.

              Requirements:
              - Update default value in run-sprint.md command documentation
              - Update reference documentation in docs/reference/commands.md
              - Update USER-GUIDE.md with new default
              - Ensure all mentions of "default: 30" are changed to "default: 60"

              Verification:
              - Search for all occurrences of max-iterations default value
              - Verify consistency across all documentation

              Files to modify:
              - plugins/m42-sprint/commands/run-sprint.md
              - plugins/m42-sprint/docs/reference/commands.md
              - plugins/m42-sprint/docs/USER-GUIDE.md


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-1-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-1-context.md

              ```markdown
              # Step Context: step-1

              ## Task
              Phase 1 - Step 2: Update Default Max Iterations (30 → 60)

              The default of 30 iterations is insufficient for larger sprints.

              Requirements:
              - Update default value in run-sprint.md command documentation
              - Update reference documentation in docs/reference/commands.md
              - Update USER-GUIDE.md with new default
              - Ensure all mentions of "default: 30" are changed to "default: 60"

              Verification:
              - Search for all occurrences of max-iterations default value
              - Verify consistency across all documentation

              Files to modify:
              - plugins/m42-sprint/commands/run-sprint.md
              - plugins/m42-sprint/docs/reference/commands.md
              - plugins/m42-sprint/docs/USER-GUIDE.md


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-1-context.md
              git commit -m "context(step-1): gather implementation context"
              ```
            started-at: "2026-01-17T00:47:51Z"
            completed-at: "2026-01-17T00:48:30Z"
            elapsed: 00:00:39
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 1 - Step 2: Update Default Max Iterations (30 → 60)

              The default of 30 iterations is insufficient for larger sprints.

              Requirements:
              - Update default value in run-sprint.md command documentation
              - Update reference documentation in docs/reference/commands.md
              - Update USER-GUIDE.md with new default
              - Ensure all mentions of "default: 30" are changed to "default: 60"

              Verification:
              - Search for all occurrences of max-iterations default value
              - Verify consistency across all documentation

              Files to modify:
              - plugins/m42-sprint/commands/run-sprint.md
              - plugins/m42-sprint/docs/reference/commands.md
              - plugins/m42-sprint/docs/USER-GUIDE.md


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-1-gherkin.md (scenarios to satisfy)
              4. context/step-1-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-1): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-17T00:48:48Z"
            completed-at: "2026-01-17T00:48:49Z"
            elapsed: 00:00:01
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-1-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-1-qa-report.md

              ```markdown
              # QA Report: step-1

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-1-qa-report.md
                 git commit -m "qa(step-1): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-1.\n\n## Context\nRead: artifacts/step-1-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-1-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-1-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-1 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-17T00:50:17Z"
            completed-at: "2026-01-17T00:51:22Z"
            elapsed: 00:01:05
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 1 - Step 2: Update Default Max Iterations (30 → 60)

              The default of 30 iterations is insufficient for larger sprints.

              Requirements:
              - Update default value in run-sprint.md command documentation
              - Update reference documentation in docs/reference/commands.md
              - Update USER-GUIDE.md with new default
              - Ensure all mentions of "default: 30" are changed to "default: 60"

              Verification:
              - Search for all occurrences of max-iterations default value
              - Verify consistency across all documentation

              Files to modify:
              - plugins/m42-sprint/commands/run-sprint.md
              - plugins/m42-sprint/docs/reference/commands.md
              - plugins/m42-sprint/docs/USER-GUIDE.md


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-1-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-1): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-17T00:51:38Z"
            completed-at: "2026-01-17T00:51:38Z"
            elapsed: 00:00:00
        started-at: "2026-01-17T00:46:40Z"
      - id: step-2
        prompt: |
          Phase 1 - Step 3: Fix Desktop Notifications Not Working

          Notifications are enabled but not appearing due to browser autoplay policy and missing error handling.

          Requirements:
          - Add try-catch error handling to `showNotification()` function
          - Pre-initialize AudioContext on first user interaction (click handler)
          - Add "Test Notification" button in the notification settings panel
          - Show toast fallback when notification permission denied or fails
          - Log notification errors to console for debugging
          - Handle case where Notification API is not available

          Verification:
          - Enable notifications in settings
          - Click "Test Notification" button, verify notification appears
          - Verify toast fallback shows when notifications are blocked

          File to modify:
          - plugins/m42-sprint/compiler/src/status-server/page.ts (~lines 1948-2169, notification section)
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 1 - Step 3: Fix Desktop Notifications Not Working

              Notifications are enabled but not appearing due to browser autoplay policy and missing error handling.

              Requirements:
              - Add try-catch error handling to `showNotification()` function
              - Pre-initialize AudioContext on first user interaction (click handler)
              - Add "Test Notification" button in the notification settings panel
              - Show toast fallback when notification permission denied or fails
              - Log notification errors to console for debugging
              - Handle case where Notification API is not available

              Verification:
              - Enable notifications in settings
              - Click "Test Notification" button, verify notification appears
              - Verify toast fallback shows when notifications are blocked

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (~lines 1948-2169, notification section)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-2-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-2

              ## Step Task
              Phase 1 - Step 3: Fix Desktop Notifications Not Working

              Notifications are enabled but not appearing due to browser autoplay policy and missing error handling.

              Requirements:
              - Add try-catch error handling to `showNotification()` function
              - Pre-initialize AudioContext on first user interaction (click handler)
              - Add "Test Notification" button in the notification settings panel
              - Show toast fallback when notification permission denied or fails
              - Log notification errors to console for debugging
              - Handle case where Notification API is not available

              Verification:
              - Enable notifications in settings
              - Click "Test Notification" button, verify notification appears
              - Verify toast fallback shows when notifications are blocked

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (~lines 1948-2169, notification section)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-2-gherkin.md
              git commit -m "plan(step-2): define gherkin scenarios"
              ```
            started-at: "2026-01-17T00:53:04Z"
            completed-at: "2026-01-17T00:53:04Z"
            elapsed: 00:00:00
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 1 - Step 3: Fix Desktop Notifications Not Working

              Notifications are enabled but not appearing due to browser autoplay policy and missing error handling.

              Requirements:
              - Add try-catch error handling to `showNotification()` function
              - Pre-initialize AudioContext on first user interaction (click handler)
              - Add "Test Notification" button in the notification settings panel
              - Show toast fallback when notification permission denied or fails
              - Log notification errors to console for debugging
              - Handle case where Notification API is not available

              Verification:
              - Enable notifications in settings
              - Click "Test Notification" button, verify notification appears
              - Verify toast fallback shows when notifications are blocked

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (~lines 1948-2169, notification section)


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-2-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-2-context.md

              ```markdown
              # Step Context: step-2

              ## Task
              Phase 1 - Step 3: Fix Desktop Notifications Not Working

              Notifications are enabled but not appearing due to browser autoplay policy and missing error handling.

              Requirements:
              - Add try-catch error handling to `showNotification()` function
              - Pre-initialize AudioContext on first user interaction (click handler)
              - Add "Test Notification" button in the notification settings panel
              - Show toast fallback when notification permission denied or fails
              - Log notification errors to console for debugging
              - Handle case where Notification API is not available

              Verification:
              - Enable notifications in settings
              - Click "Test Notification" button, verify notification appears
              - Verify toast fallback shows when notifications are blocked

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (~lines 1948-2169, notification section)


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-2-context.md
              git commit -m "context(step-2): gather implementation context"
              ```
            started-at: "2026-01-17T00:54:01Z"
            completed-at: "2026-01-17T00:54:02Z"
            elapsed: 00:00:01
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 1 - Step 3: Fix Desktop Notifications Not Working

              Notifications are enabled but not appearing due to browser autoplay policy and missing error handling.

              Requirements:
              - Add try-catch error handling to `showNotification()` function
              - Pre-initialize AudioContext on first user interaction (click handler)
              - Add "Test Notification" button in the notification settings panel
              - Show toast fallback when notification permission denied or fails
              - Log notification errors to console for debugging
              - Handle case where Notification API is not available

              Verification:
              - Enable notifications in settings
              - Click "Test Notification" button, verify notification appears
              - Verify toast fallback shows when notifications are blocked

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (~lines 1948-2169, notification section)


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-2-gherkin.md (scenarios to satisfy)
              4. context/step-2-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-2): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-17T00:56:01Z"
            completed-at: "2026-01-17T00:56:01Z"
            elapsed: 00:00:00
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-2-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-2-qa-report.md

              ```markdown
              # QA Report: step-2

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-2-qa-report.md
                 git commit -m "qa(step-2): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-2.\n\n## Context\nRead: artifacts/step-2-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-2-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-2-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-2 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-17T00:59:08Z"
            completed-at: "2026-01-17T00:59:08Z"
            elapsed: 00:00:00
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 1 - Step 3: Fix Desktop Notifications Not Working

              Notifications are enabled but not appearing due to browser autoplay policy and missing error handling.

              Requirements:
              - Add try-catch error handling to `showNotification()` function
              - Pre-initialize AudioContext on first user interaction (click handler)
              - Add "Test Notification" button in the notification settings panel
              - Show toast fallback when notification permission denied or fails
              - Log notification errors to console for debugging
              - Handle case where Notification API is not available

              Verification:
              - Enable notifications in settings
              - Click "Test Notification" button, verify notification appears
              - Verify toast fallback shows when notifications are blocked

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (~lines 1948-2169, notification section)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-2-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-2): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-17T01:00:52Z"
            completed-at: "2026-01-17T01:00:52Z"
            elapsed: 00:00:00
        started-at: "2026-01-17T00:53:04Z"
      - id: step-3
        prompt: |
          Phase 2 - Step 1: Create Cross-Platform Browser Opener Utility

          Create a new utility module for opening browsers across different platforms.

          Requirements:
          - Create browser.ts with `openBrowser(url: string): Promise<void>` function
          - Detect platform: darwin (macOS), win32 (Windows), linux
          - Use appropriate command: `open` (macOS), `start` (Windows), `xdg-open` (Linux)
          - Handle errors gracefully (browser not found, etc.)
          - Export function for use in index.ts
          - Add fallback message to console if browser fails to open

          Verification:
          - Import and call openBrowser() with a URL
          - Verify browser opens on current platform

          New file to create:
          - plugins/m42-sprint/compiler/src/status-server/browser.ts
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 2 - Step 1: Create Cross-Platform Browser Opener Utility

              Create a new utility module for opening browsers across different platforms.

              Requirements:
              - Create browser.ts with `openBrowser(url: string): Promise<void>` function
              - Detect platform: darwin (macOS), win32 (Windows), linux
              - Use appropriate command: `open` (macOS), `start` (Windows), `xdg-open` (Linux)
              - Handle errors gracefully (browser not found, etc.)
              - Export function for use in index.ts
              - Add fallback message to console if browser fails to open

              Verification:
              - Import and call openBrowser() with a URL
              - Verify browser opens on current platform

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/browser.ts


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-3-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-3

              ## Step Task
              Phase 2 - Step 1: Create Cross-Platform Browser Opener Utility

              Create a new utility module for opening browsers across different platforms.

              Requirements:
              - Create browser.ts with `openBrowser(url: string): Promise<void>` function
              - Detect platform: darwin (macOS), win32 (Windows), linux
              - Use appropriate command: `open` (macOS), `start` (Windows), `xdg-open` (Linux)
              - Handle errors gracefully (browser not found, etc.)
              - Export function for use in index.ts
              - Add fallback message to console if browser fails to open

              Verification:
              - Import and call openBrowser() with a URL
              - Verify browser opens on current platform

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/browser.ts


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-3-gherkin.md
              git commit -m "plan(step-3): define gherkin scenarios"
              ```
            started-at: "2026-01-17T01:02:06Z"
            completed-at: "2026-01-17T01:02:06Z"
            elapsed: 00:00:00
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 2 - Step 1: Create Cross-Platform Browser Opener Utility

              Create a new utility module for opening browsers across different platforms.

              Requirements:
              - Create browser.ts with `openBrowser(url: string): Promise<void>` function
              - Detect platform: darwin (macOS), win32 (Windows), linux
              - Use appropriate command: `open` (macOS), `start` (Windows), `xdg-open` (Linux)
              - Handle errors gracefully (browser not found, etc.)
              - Export function for use in index.ts
              - Add fallback message to console if browser fails to open

              Verification:
              - Import and call openBrowser() with a URL
              - Verify browser opens on current platform

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/browser.ts


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-3-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-3-context.md

              ```markdown
              # Step Context: step-3

              ## Task
              Phase 2 - Step 1: Create Cross-Platform Browser Opener Utility

              Create a new utility module for opening browsers across different platforms.

              Requirements:
              - Create browser.ts with `openBrowser(url: string): Promise<void>` function
              - Detect platform: darwin (macOS), win32 (Windows), linux
              - Use appropriate command: `open` (macOS), `start` (Windows), `xdg-open` (Linux)
              - Handle errors gracefully (browser not found, etc.)
              - Export function for use in index.ts
              - Add fallback message to console if browser fails to open

              Verification:
              - Import and call openBrowser() with a URL
              - Verify browser opens on current platform

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/browser.ts


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-3-context.md
              git commit -m "context(step-3): gather implementation context"
              ```
            started-at: "2026-01-17T01:11:49Z"
            completed-at: "2026-01-17T01:11:50Z"
            elapsed: 00:00:01
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 2 - Step 1: Create Cross-Platform Browser Opener Utility

              Create a new utility module for opening browsers across different platforms.

              Requirements:
              - Create browser.ts with `openBrowser(url: string): Promise<void>` function
              - Detect platform: darwin (macOS), win32 (Windows), linux
              - Use appropriate command: `open` (macOS), `start` (Windows), `xdg-open` (Linux)
              - Handle errors gracefully (browser not found, etc.)
              - Export function for use in index.ts
              - Add fallback message to console if browser fails to open

              Verification:
              - Import and call openBrowser() with a URL
              - Verify browser opens on current platform

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/browser.ts


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-3-gherkin.md (scenarios to satisfy)
              4. context/step-3-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-3): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-17T01:13:08Z"
            completed-at: "2026-01-17T01:15:00Z"
            elapsed: 00:01:52
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-3-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-3-qa-report.md

              ```markdown
              # QA Report: step-3

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-3-qa-report.md
                 git commit -m "qa(step-3): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-3.\n\n## Context\nRead: artifacts/step-3-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-3-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-3-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-3 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-17T01:14:23Z"
            completed-at: "2026-01-17T01:14:23Z"
            elapsed: 00:00:00
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 2 - Step 1: Create Cross-Platform Browser Opener Utility

              Create a new utility module for opening browsers across different platforms.

              Requirements:
              - Create browser.ts with `openBrowser(url: string): Promise<void>` function
              - Detect platform: darwin (macOS), win32 (Windows), linux
              - Use appropriate command: `open` (macOS), `start` (Windows), `xdg-open` (Linux)
              - Handle errors gracefully (browser not found, etc.)
              - Export function for use in index.ts
              - Add fallback message to console if browser fails to open

              Verification:
              - Import and call openBrowser() with a URL
              - Verify browser opens on current platform

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/browser.ts


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-3-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-3): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-17T01:15:39Z"
            completed-at: "2026-01-17T02:16:00Z"
            elapsed: 01:00:21
        started-at: "2026-01-17T01:02:06Z"
      - id: step-4
        prompt: |
          Phase 2 - Step 2: Add EventEmitter Pattern to StatusServer

          Implement ready signal using EventEmitter pattern to eliminate race condition.

          Requirements:
          - Import EventEmitter from 'events' in server.ts
          - Make StatusServer extend EventEmitter (or add as property)
          - Emit 'ready' event AFTER server.listen() callback fires
          - Add `waitForReady(): Promise<void>` method that resolves on 'ready' event
          - Write port file ONLY after server is confirmed listening
          - Add timeout handling (fail after 10 seconds if server doesn't start)

          Verification:
          - Call waitForReady() before sprint loop starts
          - Verify port file exists only after server is ready
          - Verify timeout triggers if server fails to start

          File to modify:
          - plugins/m42-sprint/compiler/src/status-server/server.ts
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 2 - Step 2: Add EventEmitter Pattern to StatusServer

              Implement ready signal using EventEmitter pattern to eliminate race condition.

              Requirements:
              - Import EventEmitter from 'events' in server.ts
              - Make StatusServer extend EventEmitter (or add as property)
              - Emit 'ready' event AFTER server.listen() callback fires
              - Add `waitForReady(): Promise<void>` method that resolves on 'ready' event
              - Write port file ONLY after server is confirmed listening
              - Add timeout handling (fail after 10 seconds if server doesn't start)

              Verification:
              - Call waitForReady() before sprint loop starts
              - Verify port file exists only after server is ready
              - Verify timeout triggers if server fails to start

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/server.ts


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-4-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-4

              ## Step Task
              Phase 2 - Step 2: Add EventEmitter Pattern to StatusServer

              Implement ready signal using EventEmitter pattern to eliminate race condition.

              Requirements:
              - Import EventEmitter from 'events' in server.ts
              - Make StatusServer extend EventEmitter (or add as property)
              - Emit 'ready' event AFTER server.listen() callback fires
              - Add `waitForReady(): Promise<void>` method that resolves on 'ready' event
              - Write port file ONLY after server is confirmed listening
              - Add timeout handling (fail after 10 seconds if server doesn't start)

              Verification:
              - Call waitForReady() before sprint loop starts
              - Verify port file exists only after server is ready
              - Verify timeout triggers if server fails to start

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/server.ts


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-4-gherkin.md
              git commit -m "plan(step-4): define gherkin scenarios"
              ```
            started-at: "2026-01-17T01:16:44Z"
            completed-at: "2026-01-17T01:16:45Z"
            elapsed: 00:00:01
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 2 - Step 2: Add EventEmitter Pattern to StatusServer

              Implement ready signal using EventEmitter pattern to eliminate race condition.

              Requirements:
              - Import EventEmitter from 'events' in server.ts
              - Make StatusServer extend EventEmitter (or add as property)
              - Emit 'ready' event AFTER server.listen() callback fires
              - Add `waitForReady(): Promise<void>` method that resolves on 'ready' event
              - Write port file ONLY after server is confirmed listening
              - Add timeout handling (fail after 10 seconds if server doesn't start)

              Verification:
              - Call waitForReady() before sprint loop starts
              - Verify port file exists only after server is ready
              - Verify timeout triggers if server fails to start

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/server.ts


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-4-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-4-context.md

              ```markdown
              # Step Context: step-4

              ## Task
              Phase 2 - Step 2: Add EventEmitter Pattern to StatusServer

              Implement ready signal using EventEmitter pattern to eliminate race condition.

              Requirements:
              - Import EventEmitter from 'events' in server.ts
              - Make StatusServer extend EventEmitter (or add as property)
              - Emit 'ready' event AFTER server.listen() callback fires
              - Add `waitForReady(): Promise<void>` method that resolves on 'ready' event
              - Write port file ONLY after server is confirmed listening
              - Add timeout handling (fail after 10 seconds if server doesn't start)

              Verification:
              - Call waitForReady() before sprint loop starts
              - Verify port file exists only after server is ready
              - Verify timeout triggers if server fails to start

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/server.ts


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-4-context.md
              git commit -m "context(step-4): gather implementation context"
              ```
            started-at: "2026-01-17T01:17:51Z"
            completed-at: "2026-01-17T01:17:52Z"
            elapsed: 00:00:01
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 2 - Step 2: Add EventEmitter Pattern to StatusServer

              Implement ready signal using EventEmitter pattern to eliminate race condition.

              Requirements:
              - Import EventEmitter from 'events' in server.ts
              - Make StatusServer extend EventEmitter (or add as property)
              - Emit 'ready' event AFTER server.listen() callback fires
              - Add `waitForReady(): Promise<void>` method that resolves on 'ready' event
              - Write port file ONLY after server is confirmed listening
              - Add timeout handling (fail after 10 seconds if server doesn't start)

              Verification:
              - Call waitForReady() before sprint loop starts
              - Verify port file exists only after server is ready
              - Verify timeout triggers if server fails to start

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/server.ts


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-4-gherkin.md (scenarios to satisfy)
              4. context/step-4-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-4): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-17T01:19:02Z"
            completed-at: "2026-01-17T01:21:46Z"
            elapsed: 00:02:44
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-4-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-4-qa-report.md

              ```markdown
              # QA Report: step-4

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-4-qa-report.md
                 git commit -m "qa(step-4): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-4.\n\n## Context\nRead: artifacts/step-4-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-4-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-4-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-4 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-17T01:22:01Z"
            completed-at: "2026-01-17T01:22:01Z"
            elapsed: 00:00:00
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 2 - Step 2: Add EventEmitter Pattern to StatusServer

              Implement ready signal using EventEmitter pattern to eliminate race condition.

              Requirements:
              - Import EventEmitter from 'events' in server.ts
              - Make StatusServer extend EventEmitter (or add as property)
              - Emit 'ready' event AFTER server.listen() callback fires
              - Add `waitForReady(): Promise<void>` method that resolves on 'ready' event
              - Write port file ONLY after server is confirmed listening
              - Add timeout handling (fail after 10 seconds if server doesn't start)

              Verification:
              - Call waitForReady() before sprint loop starts
              - Verify port file exists only after server is ready
              - Verify timeout triggers if server fails to start

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/server.ts


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-4-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-4): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-17T01:23:44Z"
            completed-at: "2026-01-17T01:23:44Z"
            elapsed: 00:00:00
        started-at: "2026-01-17T01:16:44Z"
      - id: step-5
        prompt: |
          Phase 2 - Step 3: Integrate Browser Auto-Open in Status Server Startup

          Make browser auto-open the default behavior when starting status server.

          Requirements:
          - Import openBrowser from browser.ts in index.ts
          - Call waitForReady() before proceeding (blocking startup)
          - Auto-open browser after server is ready (use openBrowser utility)
          - Add `--no-browser` flag support to disable auto-open
          - Pass browser preference through function parameters
          - Log status server URL to console regardless of browser open

          Verification:
          - Start sprint, verify browser opens automatically within 3 seconds
          - Start with --no-browser flag, verify browser does NOT open
          - Verify sprint loop only starts after server is ready

          Files to modify:
          - plugins/m42-sprint/compiler/src/status-server/index.ts
          - plugins/m42-sprint/commands/run-sprint.md (add --no-browser flag documentation)
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 2 - Step 3: Integrate Browser Auto-Open in Status Server Startup

              Make browser auto-open the default behavior when starting status server.

              Requirements:
              - Import openBrowser from browser.ts in index.ts
              - Call waitForReady() before proceeding (blocking startup)
              - Auto-open browser after server is ready (use openBrowser utility)
              - Add `--no-browser` flag support to disable auto-open
              - Pass browser preference through function parameters
              - Log status server URL to console regardless of browser open

              Verification:
              - Start sprint, verify browser opens automatically within 3 seconds
              - Start with --no-browser flag, verify browser does NOT open
              - Verify sprint loop only starts after server is ready

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/index.ts
              - plugins/m42-sprint/commands/run-sprint.md (add --no-browser flag documentation)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-5-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-5

              ## Step Task
              Phase 2 - Step 3: Integrate Browser Auto-Open in Status Server Startup

              Make browser auto-open the default behavior when starting status server.

              Requirements:
              - Import openBrowser from browser.ts in index.ts
              - Call waitForReady() before proceeding (blocking startup)
              - Auto-open browser after server is ready (use openBrowser utility)
              - Add `--no-browser` flag support to disable auto-open
              - Pass browser preference through function parameters
              - Log status server URL to console regardless of browser open

              Verification:
              - Start sprint, verify browser opens automatically within 3 seconds
              - Start with --no-browser flag, verify browser does NOT open
              - Verify sprint loop only starts after server is ready

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/index.ts
              - plugins/m42-sprint/commands/run-sprint.md (add --no-browser flag documentation)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-5-gherkin.md
              git commit -m "plan(step-5): define gherkin scenarios"
              ```
            started-at: "2026-01-17T01:26:14Z"
            completed-at: "2026-01-17T01:26:15Z"
            elapsed: 00:00:01
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 2 - Step 3: Integrate Browser Auto-Open in Status Server Startup

              Make browser auto-open the default behavior when starting status server.

              Requirements:
              - Import openBrowser from browser.ts in index.ts
              - Call waitForReady() before proceeding (blocking startup)
              - Auto-open browser after server is ready (use openBrowser utility)
              - Add `--no-browser` flag support to disable auto-open
              - Pass browser preference through function parameters
              - Log status server URL to console regardless of browser open

              Verification:
              - Start sprint, verify browser opens automatically within 3 seconds
              - Start with --no-browser flag, verify browser does NOT open
              - Verify sprint loop only starts after server is ready

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/index.ts
              - plugins/m42-sprint/commands/run-sprint.md (add --no-browser flag documentation)


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-5-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-5-context.md

              ```markdown
              # Step Context: step-5

              ## Task
              Phase 2 - Step 3: Integrate Browser Auto-Open in Status Server Startup

              Make browser auto-open the default behavior when starting status server.

              Requirements:
              - Import openBrowser from browser.ts in index.ts
              - Call waitForReady() before proceeding (blocking startup)
              - Auto-open browser after server is ready (use openBrowser utility)
              - Add `--no-browser` flag support to disable auto-open
              - Pass browser preference through function parameters
              - Log status server URL to console regardless of browser open

              Verification:
              - Start sprint, verify browser opens automatically within 3 seconds
              - Start with --no-browser flag, verify browser does NOT open
              - Verify sprint loop only starts after server is ready

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/index.ts
              - plugins/m42-sprint/commands/run-sprint.md (add --no-browser flag documentation)


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-5-context.md
              git commit -m "context(step-5): gather implementation context"
              ```
            started-at: "2026-01-17T01:27:34Z"
            completed-at: "2026-01-17T01:28:00Z"
            elapsed: 00:00:26
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 2 - Step 3: Integrate Browser Auto-Open in Status Server Startup

              Make browser auto-open the default behavior when starting status server.

              Requirements:
              - Import openBrowser from browser.ts in index.ts
              - Call waitForReady() before proceeding (blocking startup)
              - Auto-open browser after server is ready (use openBrowser utility)
              - Add `--no-browser` flag support to disable auto-open
              - Pass browser preference through function parameters
              - Log status server URL to console regardless of browser open

              Verification:
              - Start sprint, verify browser opens automatically within 3 seconds
              - Start with --no-browser flag, verify browser does NOT open
              - Verify sprint loop only starts after server is ready

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/index.ts
              - plugins/m42-sprint/commands/run-sprint.md (add --no-browser flag documentation)


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-5-gherkin.md (scenarios to satisfy)
              4. context/step-5-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-5): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-17T01:28:54Z"
            completed-at: "2026-01-17T01:30:49Z"
            elapsed: 00:01:55
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-5-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-5-qa-report.md

              ```markdown
              # QA Report: step-5

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-5-qa-report.md
                 git commit -m "qa(step-5): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-5.\n\n## Context\nRead: artifacts/step-5-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-5-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-5-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-5 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-17T01:31:06Z"
            completed-at: "2026-01-17T01:31:06Z"
            elapsed: 00:00:00
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 2 - Step 3: Integrate Browser Auto-Open in Status Server Startup

              Make browser auto-open the default behavior when starting status server.

              Requirements:
              - Import openBrowser from browser.ts in index.ts
              - Call waitForReady() before proceeding (blocking startup)
              - Auto-open browser after server is ready (use openBrowser utility)
              - Add `--no-browser` flag support to disable auto-open
              - Pass browser preference through function parameters
              - Log status server URL to console regardless of browser open

              Verification:
              - Start sprint, verify browser opens automatically within 3 seconds
              - Start with --no-browser flag, verify browser does NOT open
              - Verify sprint loop only starts after server is ready

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/index.ts
              - plugins/m42-sprint/commands/run-sprint.md (add --no-browser flag documentation)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-5-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-5): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-17T01:32:34Z"
            completed-at: "2026-01-17T02:33:15Z"
            elapsed: 01:00:41
        started-at: "2026-01-17T01:26:14Z"
      - id: step-6
        prompt: |
          Phase 3 - Step 1: Implement Keyboard Shortcuts

          Add keyboard navigation for common actions in the status page.

          Requirements:
          - Add global keydown event listener
          - Implement shortcuts:
            - `P` - Pause/Resume sprint (toggle based on current state)
            - `L` - Toggle live activity panel visibility
            - `N` - Open notification settings modal
            - `D` - Download all logs (trigger download-all-logs action)
            - `Esc` - Close any open modals
            - `?` - Show keyboard shortcuts help modal
          - Create shortcuts help modal with list of all shortcuts
          - Ignore shortcuts when typing in input fields
          - Add visual hints in UI (e.g., underline P in Pause button)

          Verification:
          - Press `?` to see shortcuts help modal
          - Test each shortcut works correctly
          - Verify shortcuts are ignored when typing in search/input

          File to modify:
          - plugins/m42-sprint/compiler/src/status-server/page.ts
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 3 - Step 1: Implement Keyboard Shortcuts

              Add keyboard navigation for common actions in the status page.

              Requirements:
              - Add global keydown event listener
              - Implement shortcuts:
                - `P` - Pause/Resume sprint (toggle based on current state)
                - `L` - Toggle live activity panel visibility
                - `N` - Open notification settings modal
                - `D` - Download all logs (trigger download-all-logs action)
                - `Esc` - Close any open modals
                - `?` - Show keyboard shortcuts help modal
              - Create shortcuts help modal with list of all shortcuts
              - Ignore shortcuts when typing in input fields
              - Add visual hints in UI (e.g., underline P in Pause button)

              Verification:
              - Press `?` to see shortcuts help modal
              - Test each shortcut works correctly
              - Verify shortcuts are ignored when typing in search/input

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-6-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-6

              ## Step Task
              Phase 3 - Step 1: Implement Keyboard Shortcuts

              Add keyboard navigation for common actions in the status page.

              Requirements:
              - Add global keydown event listener
              - Implement shortcuts:
                - `P` - Pause/Resume sprint (toggle based on current state)
                - `L` - Toggle live activity panel visibility
                - `N` - Open notification settings modal
                - `D` - Download all logs (trigger download-all-logs action)
                - `Esc` - Close any open modals
                - `?` - Show keyboard shortcuts help modal
              - Create shortcuts help modal with list of all shortcuts
              - Ignore shortcuts when typing in input fields
              - Add visual hints in UI (e.g., underline P in Pause button)

              Verification:
              - Press `?` to see shortcuts help modal
              - Test each shortcut works correctly
              - Verify shortcuts are ignored when typing in search/input

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-6-gherkin.md
              git commit -m "plan(step-6): define gherkin scenarios"
              ```
            started-at: "2026-01-17T01:33:56Z"
            completed-at: "2026-01-17T01:33:57Z"
            elapsed: 00:00:01
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 3 - Step 1: Implement Keyboard Shortcuts

              Add keyboard navigation for common actions in the status page.

              Requirements:
              - Add global keydown event listener
              - Implement shortcuts:
                - `P` - Pause/Resume sprint (toggle based on current state)
                - `L` - Toggle live activity panel visibility
                - `N` - Open notification settings modal
                - `D` - Download all logs (trigger download-all-logs action)
                - `Esc` - Close any open modals
                - `?` - Show keyboard shortcuts help modal
              - Create shortcuts help modal with list of all shortcuts
              - Ignore shortcuts when typing in input fields
              - Add visual hints in UI (e.g., underline P in Pause button)

              Verification:
              - Press `?` to see shortcuts help modal
              - Test each shortcut works correctly
              - Verify shortcuts are ignored when typing in search/input

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-6-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-6-context.md

              ```markdown
              # Step Context: step-6

              ## Task
              Phase 3 - Step 1: Implement Keyboard Shortcuts

              Add keyboard navigation for common actions in the status page.

              Requirements:
              - Add global keydown event listener
              - Implement shortcuts:
                - `P` - Pause/Resume sprint (toggle based on current state)
                - `L` - Toggle live activity panel visibility
                - `N` - Open notification settings modal
                - `D` - Download all logs (trigger download-all-logs action)
                - `Esc` - Close any open modals
                - `?` - Show keyboard shortcuts help modal
              - Create shortcuts help modal with list of all shortcuts
              - Ignore shortcuts when typing in input fields
              - Add visual hints in UI (e.g., underline P in Pause button)

              Verification:
              - Press `?` to see shortcuts help modal
              - Test each shortcut works correctly
              - Verify shortcuts are ignored when typing in search/input

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-6-context.md
              git commit -m "context(step-6): gather implementation context"
              ```
            started-at: "2026-01-17T01:35:44Z"
            completed-at: "2026-01-17T01:36:00Z"
            elapsed: 00:00:16
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 3 - Step 1: Implement Keyboard Shortcuts

              Add keyboard navigation for common actions in the status page.

              Requirements:
              - Add global keydown event listener
              - Implement shortcuts:
                - `P` - Pause/Resume sprint (toggle based on current state)
                - `L` - Toggle live activity panel visibility
                - `N` - Open notification settings modal
                - `D` - Download all logs (trigger download-all-logs action)
                - `Esc` - Close any open modals
                - `?` - Show keyboard shortcuts help modal
              - Create shortcuts help modal with list of all shortcuts
              - Ignore shortcuts when typing in input fields
              - Add visual hints in UI (e.g., underline P in Pause button)

              Verification:
              - Press `?` to see shortcuts help modal
              - Test each shortcut works correctly
              - Verify shortcuts are ignored when typing in search/input

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-6-gherkin.md (scenarios to satisfy)
              4. context/step-6-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-6): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-17T01:37:47Z"
            completed-at: "2026-01-17T01:37:47Z"
            elapsed: 00:00:00
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-6-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-6-qa-report.md

              ```markdown
              # QA Report: step-6

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-6-qa-report.md
                 git commit -m "qa(step-6): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-6.\n\n## Context\nRead: artifacts/step-6-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-6-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-6-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-6 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-17T01:42:42Z"
            completed-at: "2026-01-17T01:42:42Z"
            elapsed: 00:00:00
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 3 - Step 1: Implement Keyboard Shortcuts

              Add keyboard navigation for common actions in the status page.

              Requirements:
              - Add global keydown event listener
              - Implement shortcuts:
                - `P` - Pause/Resume sprint (toggle based on current state)
                - `L` - Toggle live activity panel visibility
                - `N` - Open notification settings modal
                - `D` - Download all logs (trigger download-all-logs action)
                - `Esc` - Close any open modals
                - `?` - Show keyboard shortcuts help modal
              - Create shortcuts help modal with list of all shortcuts
              - Ignore shortcuts when typing in input fields
              - Add visual hints in UI (e.g., underline P in Pause button)

              Verification:
              - Press `?` to see shortcuts help modal
              - Test each shortcut works correctly
              - Verify shortcuts are ignored when typing in search/input

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-6-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-6): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-17T01:44:21Z"
            completed-at: "2026-01-17T01:44:21Z"
            elapsed: 00:00:00
        started-at: "2026-01-17T01:33:57Z"
      - id: step-7
        prompt: |
          Phase 3 - Step 2: Add Enhanced Error Messages with Recovery Actions

          Show contextual error details with actionable recovery guidance.

          Requirements:
          - Create error classification system for phase failures
          - Categories: network, rate-limit, timeout, validation, logic
          - Display error category badge in failed phase cards
          - Show recovery suggestions based on error type:
            - network: "Check internet connection and retry"
            - rate-limit: "Wait a few minutes before retrying"
            - timeout: "Phase took too long - try breaking into smaller steps"
            - validation: "Review input/output requirements"
            - logic: "Review Claude's reasoning in the log"
          - Add "View Error Details" expandable section in phase cards
          - Include stack trace or relevant error message

          Verification:
          - Trigger a phase failure (e.g., network timeout)
          - Verify error category is displayed
          - Verify recovery suggestion is relevant to error type

          File to modify:
          - plugins/m42-sprint/compiler/src/status-server/page.ts
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 3 - Step 2: Add Enhanced Error Messages with Recovery Actions

              Show contextual error details with actionable recovery guidance.

              Requirements:
              - Create error classification system for phase failures
              - Categories: network, rate-limit, timeout, validation, logic
              - Display error category badge in failed phase cards
              - Show recovery suggestions based on error type:
                - network: "Check internet connection and retry"
                - rate-limit: "Wait a few minutes before retrying"
                - timeout: "Phase took too long - try breaking into smaller steps"
                - validation: "Review input/output requirements"
                - logic: "Review Claude's reasoning in the log"
              - Add "View Error Details" expandable section in phase cards
              - Include stack trace or relevant error message

              Verification:
              - Trigger a phase failure (e.g., network timeout)
              - Verify error category is displayed
              - Verify recovery suggestion is relevant to error type

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-7-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-7

              ## Step Task
              Phase 3 - Step 2: Add Enhanced Error Messages with Recovery Actions

              Show contextual error details with actionable recovery guidance.

              Requirements:
              - Create error classification system for phase failures
              - Categories: network, rate-limit, timeout, validation, logic
              - Display error category badge in failed phase cards
              - Show recovery suggestions based on error type:
                - network: "Check internet connection and retry"
                - rate-limit: "Wait a few minutes before retrying"
                - timeout: "Phase took too long - try breaking into smaller steps"
                - validation: "Review input/output requirements"
                - logic: "Review Claude's reasoning in the log"
              - Add "View Error Details" expandable section in phase cards
              - Include stack trace or relevant error message

              Verification:
              - Trigger a phase failure (e.g., network timeout)
              - Verify error category is displayed
              - Verify recovery suggestion is relevant to error type

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-7-gherkin.md
              git commit -m "plan(step-7): define gherkin scenarios"
              ```
            started-at: "2026-01-17T01:46:23Z"
            completed-at: "2026-01-17T01:47:48Z"
            elapsed: 00:01:25
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 3 - Step 2: Add Enhanced Error Messages with Recovery Actions

              Show contextual error details with actionable recovery guidance.

              Requirements:
              - Create error classification system for phase failures
              - Categories: network, rate-limit, timeout, validation, logic
              - Display error category badge in failed phase cards
              - Show recovery suggestions based on error type:
                - network: "Check internet connection and retry"
                - rate-limit: "Wait a few minutes before retrying"
                - timeout: "Phase took too long - try breaking into smaller steps"
                - validation: "Review input/output requirements"
                - logic: "Review Claude's reasoning in the log"
              - Add "View Error Details" expandable section in phase cards
              - Include stack trace or relevant error message

              Verification:
              - Trigger a phase failure (e.g., network timeout)
              - Verify error category is displayed
              - Verify recovery suggestion is relevant to error type

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-7-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-7-context.md

              ```markdown
              # Step Context: step-7

              ## Task
              Phase 3 - Step 2: Add Enhanced Error Messages with Recovery Actions

              Show contextual error details with actionable recovery guidance.

              Requirements:
              - Create error classification system for phase failures
              - Categories: network, rate-limit, timeout, validation, logic
              - Display error category badge in failed phase cards
              - Show recovery suggestions based on error type:
                - network: "Check internet connection and retry"
                - rate-limit: "Wait a few minutes before retrying"
                - timeout: "Phase took too long - try breaking into smaller steps"
                - validation: "Review input/output requirements"
                - logic: "Review Claude's reasoning in the log"
              - Add "View Error Details" expandable section in phase cards
              - Include stack trace or relevant error message

              Verification:
              - Trigger a phase failure (e.g., network timeout)
              - Verify error category is displayed
              - Verify recovery suggestion is relevant to error type

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-7-context.md
              git commit -m "context(step-7): gather implementation context"
              ```
            started-at: "2026-01-17T01:48:07Z"
            completed-at: "2026-01-17T01:49:35Z"
            elapsed: 00:01:28
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 3 - Step 2: Add Enhanced Error Messages with Recovery Actions

              Show contextual error details with actionable recovery guidance.

              Requirements:
              - Create error classification system for phase failures
              - Categories: network, rate-limit, timeout, validation, logic
              - Display error category badge in failed phase cards
              - Show recovery suggestions based on error type:
                - network: "Check internet connection and retry"
                - rate-limit: "Wait a few minutes before retrying"
                - timeout: "Phase took too long - try breaking into smaller steps"
                - validation: "Review input/output requirements"
                - logic: "Review Claude's reasoning in the log"
              - Add "View Error Details" expandable section in phase cards
              - Include stack trace or relevant error message

              Verification:
              - Trigger a phase failure (e.g., network timeout)
              - Verify error category is displayed
              - Verify recovery suggestion is relevant to error type

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-7-gherkin.md (scenarios to satisfy)
              4. context/step-7-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-7): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-17T01:49:51Z"
            completed-at: "2026-01-17T01:49:52Z"
            elapsed: 00:00:01
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-7-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-7-qa-report.md

              ```markdown
              # QA Report: step-7

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-7-qa-report.md
                 git commit -m "qa(step-7): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-7.\n\n## Context\nRead: artifacts/step-7-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-7-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-7-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-7 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-17T01:53:56Z"
            completed-at: "2026-01-17T01:53:56Z"
            elapsed: 00:00:00
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 3 - Step 2: Add Enhanced Error Messages with Recovery Actions

              Show contextual error details with actionable recovery guidance.

              Requirements:
              - Create error classification system for phase failures
              - Categories: network, rate-limit, timeout, validation, logic
              - Display error category badge in failed phase cards
              - Show recovery suggestions based on error type:
                - network: "Check internet connection and retry"
                - rate-limit: "Wait a few minutes before retrying"
                - timeout: "Phase took too long - try breaking into smaller steps"
                - validation: "Review input/output requirements"
                - logic: "Review Claude's reasoning in the log"
              - Add "View Error Details" expandable section in phase cards
              - Include stack trace or relevant error message

              Verification:
              - Trigger a phase failure (e.g., network timeout)
              - Verify error category is displayed
              - Verify recovery suggestion is relevant to error type

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-7-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-7): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-17T01:55:41Z"
            completed-at: "2026-01-17T02:58:00Z"
            elapsed: 01:02:19
        started-at: "2026-01-17T01:46:23Z"
      - id: step-8
        prompt: |
          Phase 3 - Step 3: Enhance Log Viewer

          Improve the log viewer with line numbers, search navigation, and jump to error.

          Requirements:
          - Add line numbers column to log display (fixed width, right-aligned)
          - Implement search within logs:
            - Search input field at top of log viewer
            - Highlight all matches in log content
            - "Next" and "Previous" buttons to navigate between matches
            - Show match count (e.g., "3 of 12 matches")
          - Add "Jump to Error" button that scrolls to first error/failure line
          - Error lines should be highlighted with red background
          - Preserve line number visibility when scrolling horizontally

          Verification:
          - Open a log with errors, verify line numbers display
          - Search for a term, verify highlighting and navigation
          - Click "Jump to Error", verify scroll to error line

          File to modify:
          - plugins/m42-sprint/compiler/src/status-server/page.ts
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 3 - Step 3: Enhance Log Viewer

              Improve the log viewer with line numbers, search navigation, and jump to error.

              Requirements:
              - Add line numbers column to log display (fixed width, right-aligned)
              - Implement search within logs:
                - Search input field at top of log viewer
                - Highlight all matches in log content
                - "Next" and "Previous" buttons to navigate between matches
                - Show match count (e.g., "3 of 12 matches")
              - Add "Jump to Error" button that scrolls to first error/failure line
              - Error lines should be highlighted with red background
              - Preserve line number visibility when scrolling horizontally

              Verification:
              - Open a log with errors, verify line numbers display
              - Search for a term, verify highlighting and navigation
              - Click "Jump to Error", verify scroll to error line

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-8-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-8

              ## Step Task
              Phase 3 - Step 3: Enhance Log Viewer

              Improve the log viewer with line numbers, search navigation, and jump to error.

              Requirements:
              - Add line numbers column to log display (fixed width, right-aligned)
              - Implement search within logs:
                - Search input field at top of log viewer
                - Highlight all matches in log content
                - "Next" and "Previous" buttons to navigate between matches
                - Show match count (e.g., "3 of 12 matches")
              - Add "Jump to Error" button that scrolls to first error/failure line
              - Error lines should be highlighted with red background
              - Preserve line number visibility when scrolling horizontally

              Verification:
              - Open a log with errors, verify line numbers display
              - Search for a term, verify highlighting and navigation
              - Click "Jump to Error", verify scroll to error line

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-8-gherkin.md
              git commit -m "plan(step-8): define gherkin scenarios"
              ```
            started-at: "2026-01-17T01:58:18Z"
            completed-at: "2026-01-17T01:59:28Z"
            elapsed: 00:01:10
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 3 - Step 3: Enhance Log Viewer

              Improve the log viewer with line numbers, search navigation, and jump to error.

              Requirements:
              - Add line numbers column to log display (fixed width, right-aligned)
              - Implement search within logs:
                - Search input field at top of log viewer
                - Highlight all matches in log content
                - "Next" and "Previous" buttons to navigate between matches
                - Show match count (e.g., "3 of 12 matches")
              - Add "Jump to Error" button that scrolls to first error/failure line
              - Error lines should be highlighted with red background
              - Preserve line number visibility when scrolling horizontally

              Verification:
              - Open a log with errors, verify line numbers display
              - Search for a term, verify highlighting and navigation
              - Click "Jump to Error", verify scroll to error line

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-8-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-8-context.md

              ```markdown
              # Step Context: step-8

              ## Task
              Phase 3 - Step 3: Enhance Log Viewer

              Improve the log viewer with line numbers, search navigation, and jump to error.

              Requirements:
              - Add line numbers column to log display (fixed width, right-aligned)
              - Implement search within logs:
                - Search input field at top of log viewer
                - Highlight all matches in log content
                - "Next" and "Previous" buttons to navigate between matches
                - Show match count (e.g., "3 of 12 matches")
              - Add "Jump to Error" button that scrolls to first error/failure line
              - Error lines should be highlighted with red background
              - Preserve line number visibility when scrolling horizontally

              Verification:
              - Open a log with errors, verify line numbers display
              - Search for a term, verify highlighting and navigation
              - Click "Jump to Error", verify scroll to error line

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-8-context.md
              git commit -m "context(step-8): gather implementation context"
              ```
            started-at: "2026-01-17T20:54:28Z"
            completed-at: "2026-01-17T20:54:28Z"
            elapsed: 00:00:00
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 3 - Step 3: Enhance Log Viewer

              Improve the log viewer with line numbers, search navigation, and jump to error.

              Requirements:
              - Add line numbers column to log display (fixed width, right-aligned)
              - Implement search within logs:
                - Search input field at top of log viewer
                - Highlight all matches in log content
                - "Next" and "Previous" buttons to navigate between matches
                - Show match count (e.g., "3 of 12 matches")
              - Add "Jump to Error" button that scrolls to first error/failure line
              - Error lines should be highlighted with red background
              - Preserve line number visibility when scrolling horizontally

              Verification:
              - Open a log with errors, verify line numbers display
              - Search for a term, verify highlighting and navigation
              - Click "Jump to Error", verify scroll to error line

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-8-gherkin.md (scenarios to satisfy)
              4. context/step-8-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-8): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-17T20:56:03Z"
            completed-at: "2026-01-17T21:15:00Z"
            elapsed: 00:18:57
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-8-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-8-qa-report.md

              ```markdown
              # QA Report: step-8

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-8-qa-report.md
                 git commit -m "qa(step-8): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-8.\n\n## Context\nRead: artifacts/step-8-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-8-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-8-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-8 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-17T21:02:10Z"
            completed-at: "2026-01-17T21:02:10Z"
            elapsed: 00:00:00
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 3 - Step 3: Enhance Log Viewer

              Improve the log viewer with line numbers, search navigation, and jump to error.

              Requirements:
              - Add line numbers column to log display (fixed width, right-aligned)
              - Implement search within logs:
                - Search input field at top of log viewer
                - Highlight all matches in log content
                - "Next" and "Previous" buttons to navigate between matches
                - Show match count (e.g., "3 of 12 matches")
              - Add "Jump to Error" button that scrolls to first error/failure line
              - Error lines should be highlighted with red background
              - Preserve line number visibility when scrolling horizontally

              Verification:
              - Open a log with errors, verify line numbers display
              - Search for a term, verify highlighting and navigation
              - Click "Jump to Error", verify scroll to error line

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-8-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-8): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-17T21:05:37Z"
            completed-at: "2026-01-17T21:05:37Z"
            elapsed: 00:00:00
        started-at: "2026-01-17T01:58:18Z"
      - id: step-9
        prompt: |
          Phase 4 - Step 1: Create SprintScanner Module

          Create module to enumerate and parse all sprints in .claude/sprints/ directory.

          Requirements:
          - Create sprint-scanner.ts with SprintScanner class
          - Scan .claude/sprints/ directory for sprint folders
          - Parse PROGRESS.yaml from each sprint to extract:
            - Sprint ID, name, status
            - Start time, end time, duration
            - Step count, completed count
            - Workflow used
          - Sort sprints by date (newest first)
          - Limit to last 50 sprints for performance
          - Handle missing/corrupted PROGRESS.yaml gracefully
          - Export SprintSummary type and SprintScanner class

          Verification:
          - Call SprintScanner.scan() and verify list of sprints returned
          - Verify sprints are sorted correctly
          - Verify corrupted sprint folders don't crash scanner

          New file to create:
          - plugins/m42-sprint/compiler/src/status-server/sprint-scanner.ts
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 4 - Step 1: Create SprintScanner Module

              Create module to enumerate and parse all sprints in .claude/sprints/ directory.

              Requirements:
              - Create sprint-scanner.ts with SprintScanner class
              - Scan .claude/sprints/ directory for sprint folders
              - Parse PROGRESS.yaml from each sprint to extract:
                - Sprint ID, name, status
                - Start time, end time, duration
                - Step count, completed count
                - Workflow used
              - Sort sprints by date (newest first)
              - Limit to last 50 sprints for performance
              - Handle missing/corrupted PROGRESS.yaml gracefully
              - Export SprintSummary type and SprintScanner class

              Verification:
              - Call SprintScanner.scan() and verify list of sprints returned
              - Verify sprints are sorted correctly
              - Verify corrupted sprint folders don't crash scanner

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/sprint-scanner.ts


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-9-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-9

              ## Step Task
              Phase 4 - Step 1: Create SprintScanner Module

              Create module to enumerate and parse all sprints in .claude/sprints/ directory.

              Requirements:
              - Create sprint-scanner.ts with SprintScanner class
              - Scan .claude/sprints/ directory for sprint folders
              - Parse PROGRESS.yaml from each sprint to extract:
                - Sprint ID, name, status
                - Start time, end time, duration
                - Step count, completed count
                - Workflow used
              - Sort sprints by date (newest first)
              - Limit to last 50 sprints for performance
              - Handle missing/corrupted PROGRESS.yaml gracefully
              - Export SprintSummary type and SprintScanner class

              Verification:
              - Call SprintScanner.scan() and verify list of sprints returned
              - Verify sprints are sorted correctly
              - Verify corrupted sprint folders don't crash scanner

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/sprint-scanner.ts


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-9-gherkin.md
              git commit -m "plan(step-9): define gherkin scenarios"
              ```
            started-at: "2026-01-17T21:07:14Z"
            completed-at: "2026-01-17T21:07:15Z"
            elapsed: 00:00:01
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 4 - Step 1: Create SprintScanner Module

              Create module to enumerate and parse all sprints in .claude/sprints/ directory.

              Requirements:
              - Create sprint-scanner.ts with SprintScanner class
              - Scan .claude/sprints/ directory for sprint folders
              - Parse PROGRESS.yaml from each sprint to extract:
                - Sprint ID, name, status
                - Start time, end time, duration
                - Step count, completed count
                - Workflow used
              - Sort sprints by date (newest first)
              - Limit to last 50 sprints for performance
              - Handle missing/corrupted PROGRESS.yaml gracefully
              - Export SprintSummary type and SprintScanner class

              Verification:
              - Call SprintScanner.scan() and verify list of sprints returned
              - Verify sprints are sorted correctly
              - Verify corrupted sprint folders don't crash scanner

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/sprint-scanner.ts


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-9-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-9-context.md

              ```markdown
              # Step Context: step-9

              ## Task
              Phase 4 - Step 1: Create SprintScanner Module

              Create module to enumerate and parse all sprints in .claude/sprints/ directory.

              Requirements:
              - Create sprint-scanner.ts with SprintScanner class
              - Scan .claude/sprints/ directory for sprint folders
              - Parse PROGRESS.yaml from each sprint to extract:
                - Sprint ID, name, status
                - Start time, end time, duration
                - Step count, completed count
                - Workflow used
              - Sort sprints by date (newest first)
              - Limit to last 50 sprints for performance
              - Handle missing/corrupted PROGRESS.yaml gracefully
              - Export SprintSummary type and SprintScanner class

              Verification:
              - Call SprintScanner.scan() and verify list of sprints returned
              - Verify sprints are sorted correctly
              - Verify corrupted sprint folders don't crash scanner

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/sprint-scanner.ts


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-9-context.md
              git commit -m "context(step-9): gather implementation context"
              ```
            started-at: "2026-01-17T21:08:37Z"
            completed-at: "2026-01-17T22:12:45Z"
            elapsed: 01:04:08
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 4 - Step 1: Create SprintScanner Module

              Create module to enumerate and parse all sprints in .claude/sprints/ directory.

              Requirements:
              - Create sprint-scanner.ts with SprintScanner class
              - Scan .claude/sprints/ directory for sprint folders
              - Parse PROGRESS.yaml from each sprint to extract:
                - Sprint ID, name, status
                - Start time, end time, duration
                - Step count, completed count
                - Workflow used
              - Sort sprints by date (newest first)
              - Limit to last 50 sprints for performance
              - Handle missing/corrupted PROGRESS.yaml gracefully
              - Export SprintSummary type and SprintScanner class

              Verification:
              - Call SprintScanner.scan() and verify list of sprints returned
              - Verify sprints are sorted correctly
              - Verify corrupted sprint folders don't crash scanner

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/sprint-scanner.ts


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-9-gherkin.md (scenarios to satisfy)
              4. context/step-9-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-9): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-17T21:10:06Z"
            completed-at: "2026-01-17T21:10:06Z"
            elapsed: 00:00:00
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-9-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-9-qa-report.md

              ```markdown
              # QA Report: step-9

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-9-qa-report.md
                 git commit -m "qa(step-9): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-9.\n\n## Context\nRead: artifacts/step-9-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-9-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-9-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-9 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-17T21:12:11Z"
            completed-at: "2026-01-17T21:12:11Z"
            elapsed: 00:00:00
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 4 - Step 1: Create SprintScanner Module

              Create module to enumerate and parse all sprints in .claude/sprints/ directory.

              Requirements:
              - Create sprint-scanner.ts with SprintScanner class
              - Scan .claude/sprints/ directory for sprint folders
              - Parse PROGRESS.yaml from each sprint to extract:
                - Sprint ID, name, status
                - Start time, end time, duration
                - Step count, completed count
                - Workflow used
              - Sort sprints by date (newest first)
              - Limit to last 50 sprints for performance
              - Handle missing/corrupted PROGRESS.yaml gracefully
              - Export SprintSummary type and SprintScanner class

              Verification:
              - Call SprintScanner.scan() and verify list of sprints returned
              - Verify sprints are sorted correctly
              - Verify corrupted sprint folders don't crash scanner

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/sprint-scanner.ts


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-9-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-9): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-17T21:13:41Z"
            completed-at: "2026-01-17T21:14:36Z"
            elapsed: 00:00:55
        started-at: "2026-01-17T21:07:14Z"
      - id: step-10
        prompt: |
          Phase 4 - Step 2: Create MetricsAggregator Module

          Create module to aggregate statistics across multiple sprints.

          Requirements:
          - Create metrics-aggregator.ts with MetricsAggregator class
          - Accept array of SprintSummary objects
          - Calculate aggregate metrics:
            - Total sprints (completed, failed, in-progress)
            - Average sprint duration
            - Average steps per sprint
            - Success rate percentage
            - Most common workflows used
            - Sprints per day/week trend
          - Export AggregateMetrics type and MetricsAggregator class

          Verification:
          - Pass sprint summaries to aggregator
          - Verify all metrics are calculated correctly
          - Verify edge cases (empty array, single sprint)

          New file to create:
          - plugins/m42-sprint/compiler/src/status-server/metrics-aggregator.ts
        status: completed
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 4 - Step 2: Create MetricsAggregator Module

              Create module to aggregate statistics across multiple sprints.

              Requirements:
              - Create metrics-aggregator.ts with MetricsAggregator class
              - Accept array of SprintSummary objects
              - Calculate aggregate metrics:
                - Total sprints (completed, failed, in-progress)
                - Average sprint duration
                - Average steps per sprint
                - Success rate percentage
                - Most common workflows used
                - Sprints per day/week trend
              - Export AggregateMetrics type and MetricsAggregator class

              Verification:
              - Pass sprint summaries to aggregator
              - Verify all metrics are calculated correctly
              - Verify edge cases (empty array, single sprint)

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/metrics-aggregator.ts


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-10-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-10

              ## Step Task
              Phase 4 - Step 2: Create MetricsAggregator Module

              Create module to aggregate statistics across multiple sprints.

              Requirements:
              - Create metrics-aggregator.ts with MetricsAggregator class
              - Accept array of SprintSummary objects
              - Calculate aggregate metrics:
                - Total sprints (completed, failed, in-progress)
                - Average sprint duration
                - Average steps per sprint
                - Success rate percentage
                - Most common workflows used
                - Sprints per day/week trend
              - Export AggregateMetrics type and MetricsAggregator class

              Verification:
              - Pass sprint summaries to aggregator
              - Verify all metrics are calculated correctly
              - Verify edge cases (empty array, single sprint)

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/metrics-aggregator.ts


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-10-gherkin.md
              git commit -m "plan(step-10): define gherkin scenarios"
              ```
            started-at: "2026-01-17T21:14:54Z"
            completed-at: "2026-01-17T21:14:54Z"
            elapsed: 00:00:00
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 4 - Step 2: Create MetricsAggregator Module

              Create module to aggregate statistics across multiple sprints.

              Requirements:
              - Create metrics-aggregator.ts with MetricsAggregator class
              - Accept array of SprintSummary objects
              - Calculate aggregate metrics:
                - Total sprints (completed, failed, in-progress)
                - Average sprint duration
                - Average steps per sprint
                - Success rate percentage
                - Most common workflows used
                - Sprints per day/week trend
              - Export AggregateMetrics type and MetricsAggregator class

              Verification:
              - Pass sprint summaries to aggregator
              - Verify all metrics are calculated correctly
              - Verify edge cases (empty array, single sprint)

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/metrics-aggregator.ts


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-10-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-10-context.md

              ```markdown
              # Step Context: step-10

              ## Task
              Phase 4 - Step 2: Create MetricsAggregator Module

              Create module to aggregate statistics across multiple sprints.

              Requirements:
              - Create metrics-aggregator.ts with MetricsAggregator class
              - Accept array of SprintSummary objects
              - Calculate aggregate metrics:
                - Total sprints (completed, failed, in-progress)
                - Average sprint duration
                - Average steps per sprint
                - Success rate percentage
                - Most common workflows used
                - Sprints per day/week trend
              - Export AggregateMetrics type and MetricsAggregator class

              Verification:
              - Pass sprint summaries to aggregator
              - Verify all metrics are calculated correctly
              - Verify edge cases (empty array, single sprint)

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/metrics-aggregator.ts


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-10-context.md
              git commit -m "context(step-10): gather implementation context"
              ```
            started-at: "2026-01-17T21:15:52Z"
            completed-at: "2026-01-17T21:15:52Z"
            elapsed: 00:00:00
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 4 - Step 2: Create MetricsAggregator Module

              Create module to aggregate statistics across multiple sprints.

              Requirements:
              - Create metrics-aggregator.ts with MetricsAggregator class
              - Accept array of SprintSummary objects
              - Calculate aggregate metrics:
                - Total sprints (completed, failed, in-progress)
                - Average sprint duration
                - Average steps per sprint
                - Success rate percentage
                - Most common workflows used
                - Sprints per day/week trend
              - Export AggregateMetrics type and MetricsAggregator class

              Verification:
              - Pass sprint summaries to aggregator
              - Verify all metrics are calculated correctly
              - Verify edge cases (empty array, single sprint)

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/metrics-aggregator.ts


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-10-gherkin.md (scenarios to satisfy)
              4. context/step-10-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-10): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-17T21:17:08Z"
            completed-at: "2026-01-17T21:17:08Z"
            elapsed: 00:00:00
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-10-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-10-qa-report.md

              ```markdown
              # QA Report: step-10

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-10-qa-report.md
                 git commit -m "qa(step-10): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-10.\n\n## Context\nRead: artifacts/step-10-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-10-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-10-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-10 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-17T21:19:13Z"
            completed-at: "2026-01-17T21:19:13Z"
            elapsed: 00:00:00
          - id: verify
            status: completed
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 4 - Step 2: Create MetricsAggregator Module

              Create module to aggregate statistics across multiple sprints.

              Requirements:
              - Create metrics-aggregator.ts with MetricsAggregator class
              - Accept array of SprintSummary objects
              - Calculate aggregate metrics:
                - Total sprints (completed, failed, in-progress)
                - Average sprint duration
                - Average steps per sprint
                - Success rate percentage
                - Most common workflows used
                - Sprints per day/week trend
              - Export AggregateMetrics type and MetricsAggregator class

              Verification:
              - Pass sprint summaries to aggregator
              - Verify all metrics are calculated correctly
              - Verify edge cases (empty array, single sprint)

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/metrics-aggregator.ts


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-10-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-10): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
            started-at: "2026-01-17T21:20:47Z"
            completed-at: "2026-01-17T21:21:59Z"
            elapsed: 00:01:12
        started-at: "2026-01-17T21:14:54Z"
      - id: step-11
        prompt: |
          Phase 4 - Step 3: Create Dashboard Page HTML

          Create the dashboard page showing sprint history and metrics.

          Requirements:
          - Create dashboard-page.ts with generateDashboardPage() function
          - Header with "Sprint Dashboard" title and link to docs
          - Metrics summary cards at top:
            - Total sprints, Success rate, Avg duration, Active sprint
          - Sprint list table with columns:
            - Sprint ID (link to detail view)
            - Status (with colored badge)
            - Started, Duration, Steps (completed/total)
          - Pagination or "Load more" for >20 sprints
          - Style consistent with existing page.ts GitHub dark theme
          - Include navigation link to current sprint (if active)

          Verification:
          - Generate dashboard HTML with sample data
          - Verify all sections render correctly
          - Verify links work correctly

          New file to create:
          - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts
        status: in-progress
        phases:
          - id: plan
            status: completed
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 4 - Step 3: Create Dashboard Page HTML

              Create the dashboard page showing sprint history and metrics.

              Requirements:
              - Create dashboard-page.ts with generateDashboardPage() function
              - Header with "Sprint Dashboard" title and link to docs
              - Metrics summary cards at top:
                - Total sprints, Success rate, Avg duration, Active sprint
              - Sprint list table with columns:
                - Sprint ID (link to detail view)
                - Status (with colored badge)
                - Started, Duration, Steps (completed/total)
              - Pagination or "Load more" for >20 sprints
              - Style consistent with existing page.ts GitHub dark theme
              - Include navigation link to current sprint (if active)

              Verification:
              - Generate dashboard HTML with sample data
              - Verify all sections render correctly
              - Verify links work correctly

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-11-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-11

              ## Step Task
              Phase 4 - Step 3: Create Dashboard Page HTML

              Create the dashboard page showing sprint history and metrics.

              Requirements:
              - Create dashboard-page.ts with generateDashboardPage() function
              - Header with "Sprint Dashboard" title and link to docs
              - Metrics summary cards at top:
                - Total sprints, Success rate, Avg duration, Active sprint
              - Sprint list table with columns:
                - Sprint ID (link to detail view)
                - Status (with colored badge)
                - Started, Duration, Steps (completed/total)
              - Pagination or "Load more" for >20 sprints
              - Style consistent with existing page.ts GitHub dark theme
              - Include navigation link to current sprint (if active)

              Verification:
              - Generate dashboard HTML with sample data
              - Verify all sections render correctly
              - Verify links work correctly

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-11-gherkin.md
              git commit -m "plan(step-11): define gherkin scenarios"
              ```
            started-at: "2026-01-17T21:22:18Z"
            completed-at: "2026-01-17T21:22:18Z"
            elapsed: 00:00:00
          - id: context
            status: completed
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 4 - Step 3: Create Dashboard Page HTML

              Create the dashboard page showing sprint history and metrics.

              Requirements:
              - Create dashboard-page.ts with generateDashboardPage() function
              - Header with "Sprint Dashboard" title and link to docs
              - Metrics summary cards at top:
                - Total sprints, Success rate, Avg duration, Active sprint
              - Sprint list table with columns:
                - Sprint ID (link to detail view)
                - Status (with colored badge)
                - Started, Duration, Steps (completed/total)
              - Pagination or "Load more" for >20 sprints
              - Style consistent with existing page.ts GitHub dark theme
              - Include navigation link to current sprint (if active)

              Verification:
              - Generate dashboard HTML with sample data
              - Verify all sections render correctly
              - Verify links work correctly

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-11-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-11-context.md

              ```markdown
              # Step Context: step-11

              ## Task
              Phase 4 - Step 3: Create Dashboard Page HTML

              Create the dashboard page showing sprint history and metrics.

              Requirements:
              - Create dashboard-page.ts with generateDashboardPage() function
              - Header with "Sprint Dashboard" title and link to docs
              - Metrics summary cards at top:
                - Total sprints, Success rate, Avg duration, Active sprint
              - Sprint list table with columns:
                - Sprint ID (link to detail view)
                - Status (with colored badge)
                - Started, Duration, Steps (completed/total)
              - Pagination or "Load more" for >20 sprints
              - Style consistent with existing page.ts GitHub dark theme
              - Include navigation link to current sprint (if active)

              Verification:
              - Generate dashboard HTML with sample data
              - Verify all sections render correctly
              - Verify links work correctly

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-11-context.md
              git commit -m "context(step-11): gather implementation context"
              ```
            started-at: "2026-01-17T21:23:36Z"
            completed-at: "2026-01-17T21:23:36Z"
            elapsed: 00:00:00
          - id: execute
            status: completed
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 4 - Step 3: Create Dashboard Page HTML

              Create the dashboard page showing sprint history and metrics.

              Requirements:
              - Create dashboard-page.ts with generateDashboardPage() function
              - Header with "Sprint Dashboard" title and link to docs
              - Metrics summary cards at top:
                - Total sprints, Success rate, Avg duration, Active sprint
              - Sprint list table with columns:
                - Sprint ID (link to detail view)
                - Status (with colored badge)
                - Started, Duration, Steps (completed/total)
              - Pagination or "Load more" for >20 sprints
              - Style consistent with existing page.ts GitHub dark theme
              - Include navigation link to current sprint (if active)

              Verification:
              - Generate dashboard HTML with sample data
              - Verify all sections render correctly
              - Verify links work correctly

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-11-gherkin.md (scenarios to satisfy)
              4. context/step-11-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-11): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
            started-at: "2026-01-17T21:24:56Z"
            completed-at: "2026-01-17T21:26:30Z"
            elapsed: 00:01:34
          - id: qa
            status: completed
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-11-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-11-qa-report.md

              ```markdown
              # QA Report: step-11

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-11-qa-report.md
                 git commit -m "qa(step-11): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-11.\n\n## Context\nRead: artifacts/step-11-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-11-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-11-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-11 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
            started-at: "2026-01-17T21:27:35Z"
            completed-at: "2026-01-17T21:27:35Z"
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 4 - Step 3: Create Dashboard Page HTML

              Create the dashboard page showing sprint history and metrics.

              Requirements:
              - Create dashboard-page.ts with generateDashboardPage() function
              - Header with "Sprint Dashboard" title and link to docs
              - Metrics summary cards at top:
                - Total sprints, Success rate, Avg duration, Active sprint
              - Sprint list table with columns:
                - Sprint ID (link to detail view)
                - Status (with colored badge)
                - Started, Duration, Steps (completed/total)
              - Pagination or "Load more" for >20 sprints
              - Style consistent with existing page.ts GitHub dark theme
              - Include navigation link to current sprint (if active)

              Verification:
              - Generate dashboard HTML with sample data
              - Verify all sections render correctly
              - Verify links work correctly

              New file to create:
              - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-11-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-11): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
        started-at: "2026-01-17T21:22:18Z"
      - id: step-12
        prompt: |
          Phase 4 - Step 4: Add URL Routing to Status Server

          Implement routing to serve dashboard and individual sprint views.

          Requirements:
          - Add URL routing in server.ts:
            - `/` or `/dashboard` - Serve dashboard page
            - `/sprint/:id` - Serve sprint detail page (existing page.ts)
            - `/api/sprints` - Return sprint list JSON
            - `/api/metrics` - Return aggregate metrics JSON
          - Parse URL path to determine which page to serve
          - Pass sprint ID to existing page generation when on detail view
          - Update existing SSE endpoint to include sprint ID context
          - Handle 404 for unknown sprint IDs

          Verification:
          - Navigate to `/`, verify dashboard loads
          - Navigate to `/sprint/<id>`, verify detail page loads
          - Call `/api/sprints`, verify JSON response

          File to modify:
          - plugins/m42-sprint/compiler/src/status-server/server.ts
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 4 - Step 4: Add URL Routing to Status Server

              Implement routing to serve dashboard and individual sprint views.

              Requirements:
              - Add URL routing in server.ts:
                - `/` or `/dashboard` - Serve dashboard page
                - `/sprint/:id` - Serve sprint detail page (existing page.ts)
                - `/api/sprints` - Return sprint list JSON
                - `/api/metrics` - Return aggregate metrics JSON
              - Parse URL path to determine which page to serve
              - Pass sprint ID to existing page generation when on detail view
              - Update existing SSE endpoint to include sprint ID context
              - Handle 404 for unknown sprint IDs

              Verification:
              - Navigate to `/`, verify dashboard loads
              - Navigate to `/sprint/<id>`, verify detail page loads
              - Call `/api/sprints`, verify JSON response

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/server.ts


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-12-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-12

              ## Step Task
              Phase 4 - Step 4: Add URL Routing to Status Server

              Implement routing to serve dashboard and individual sprint views.

              Requirements:
              - Add URL routing in server.ts:
                - `/` or `/dashboard` - Serve dashboard page
                - `/sprint/:id` - Serve sprint detail page (existing page.ts)
                - `/api/sprints` - Return sprint list JSON
                - `/api/metrics` - Return aggregate metrics JSON
              - Parse URL path to determine which page to serve
              - Pass sprint ID to existing page generation when on detail view
              - Update existing SSE endpoint to include sprint ID context
              - Handle 404 for unknown sprint IDs

              Verification:
              - Navigate to `/`, verify dashboard loads
              - Navigate to `/sprint/<id>`, verify detail page loads
              - Call `/api/sprints`, verify JSON response

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/server.ts


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-12-gherkin.md
              git commit -m "plan(step-12): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 4 - Step 4: Add URL Routing to Status Server

              Implement routing to serve dashboard and individual sprint views.

              Requirements:
              - Add URL routing in server.ts:
                - `/` or `/dashboard` - Serve dashboard page
                - `/sprint/:id` - Serve sprint detail page (existing page.ts)
                - `/api/sprints` - Return sprint list JSON
                - `/api/metrics` - Return aggregate metrics JSON
              - Parse URL path to determine which page to serve
              - Pass sprint ID to existing page generation when on detail view
              - Update existing SSE endpoint to include sprint ID context
              - Handle 404 for unknown sprint IDs

              Verification:
              - Navigate to `/`, verify dashboard loads
              - Navigate to `/sprint/<id>`, verify detail page loads
              - Call `/api/sprints`, verify JSON response

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/server.ts


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-12-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-12-context.md

              ```markdown
              # Step Context: step-12

              ## Task
              Phase 4 - Step 4: Add URL Routing to Status Server

              Implement routing to serve dashboard and individual sprint views.

              Requirements:
              - Add URL routing in server.ts:
                - `/` or `/dashboard` - Serve dashboard page
                - `/sprint/:id` - Serve sprint detail page (existing page.ts)
                - `/api/sprints` - Return sprint list JSON
                - `/api/metrics` - Return aggregate metrics JSON
              - Parse URL path to determine which page to serve
              - Pass sprint ID to existing page generation when on detail view
              - Update existing SSE endpoint to include sprint ID context
              - Handle 404 for unknown sprint IDs

              Verification:
              - Navigate to `/`, verify dashboard loads
              - Navigate to `/sprint/<id>`, verify detail page loads
              - Call `/api/sprints`, verify JSON response

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/server.ts


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-12-context.md
              git commit -m "context(step-12): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 4 - Step 4: Add URL Routing to Status Server

              Implement routing to serve dashboard and individual sprint views.

              Requirements:
              - Add URL routing in server.ts:
                - `/` or `/dashboard` - Serve dashboard page
                - `/sprint/:id` - Serve sprint detail page (existing page.ts)
                - `/api/sprints` - Return sprint list JSON
                - `/api/metrics` - Return aggregate metrics JSON
              - Parse URL path to determine which page to serve
              - Pass sprint ID to existing page generation when on detail view
              - Update existing SSE endpoint to include sprint ID context
              - Handle 404 for unknown sprint IDs

              Verification:
              - Navigate to `/`, verify dashboard loads
              - Navigate to `/sprint/<id>`, verify detail page loads
              - Call `/api/sprints`, verify JSON response

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/server.ts


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-12-gherkin.md (scenarios to satisfy)
              4. context/step-12-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-12): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-12-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-12-qa-report.md

              ```markdown
              # QA Report: step-12

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-12-qa-report.md
                 git commit -m "qa(step-12): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-12.\n\n## Context\nRead: artifacts/step-12-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-12-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-12-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-12 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 4 - Step 4: Add URL Routing to Status Server

              Implement routing to serve dashboard and individual sprint views.

              Requirements:
              - Add URL routing in server.ts:
                - `/` or `/dashboard` - Serve dashboard page
                - `/sprint/:id` - Serve sprint detail page (existing page.ts)
                - `/api/sprints` - Return sprint list JSON
                - `/api/metrics` - Return aggregate metrics JSON
              - Parse URL path to determine which page to serve
              - Pass sprint ID to existing page generation when on detail view
              - Update existing SSE endpoint to include sprint ID context
              - Handle 404 for unknown sprint IDs

              Verification:
              - Navigate to `/`, verify dashboard loads
              - Navigate to `/sprint/<id>`, verify detail page loads
              - Call `/api/sprints`, verify JSON response

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/server.ts


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-12-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-12): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-13
        prompt: |
          Phase 4 - Step 5: Add Navigation Header to Sprint Detail Page

          Add navigation between dashboard and sprint detail views.

          Requirements:
          - Add navigation bar at top of sprint detail page
          - Include "← Back to Dashboard" link
          - Show breadcrumb: Dashboard > Sprint: <sprint-id>
          - Add sprint switcher dropdown (last 10 sprints)
          - Style navigation consistent with existing header
          - Update dashboard page with same navigation pattern

          Verification:
          - Navigate from dashboard to sprint detail
          - Click "Back to Dashboard", verify navigation
          - Use sprint switcher, verify correct sprint loads

          Files to modify:
          - plugins/m42-sprint/compiler/src/status-server/page.ts
          - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 4 - Step 5: Add Navigation Header to Sprint Detail Page

              Add navigation between dashboard and sprint detail views.

              Requirements:
              - Add navigation bar at top of sprint detail page
              - Include "← Back to Dashboard" link
              - Show breadcrumb: Dashboard > Sprint: <sprint-id>
              - Add sprint switcher dropdown (last 10 sprints)
              - Style navigation consistent with existing header
              - Update dashboard page with same navigation pattern

              Verification:
              - Navigate from dashboard to sprint detail
              - Click "Back to Dashboard", verify navigation
              - Use sprint switcher, verify correct sprint loads

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-13-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-13

              ## Step Task
              Phase 4 - Step 5: Add Navigation Header to Sprint Detail Page

              Add navigation between dashboard and sprint detail views.

              Requirements:
              - Add navigation bar at top of sprint detail page
              - Include "← Back to Dashboard" link
              - Show breadcrumb: Dashboard > Sprint: <sprint-id>
              - Add sprint switcher dropdown (last 10 sprints)
              - Style navigation consistent with existing header
              - Update dashboard page with same navigation pattern

              Verification:
              - Navigate from dashboard to sprint detail
              - Click "Back to Dashboard", verify navigation
              - Use sprint switcher, verify correct sprint loads

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-13-gherkin.md
              git commit -m "plan(step-13): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 4 - Step 5: Add Navigation Header to Sprint Detail Page

              Add navigation between dashboard and sprint detail views.

              Requirements:
              - Add navigation bar at top of sprint detail page
              - Include "← Back to Dashboard" link
              - Show breadcrumb: Dashboard > Sprint: <sprint-id>
              - Add sprint switcher dropdown (last 10 sprints)
              - Style navigation consistent with existing header
              - Update dashboard page with same navigation pattern

              Verification:
              - Navigate from dashboard to sprint detail
              - Click "Back to Dashboard", verify navigation
              - Use sprint switcher, verify correct sprint loads

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-13-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-13-context.md

              ```markdown
              # Step Context: step-13

              ## Task
              Phase 4 - Step 5: Add Navigation Header to Sprint Detail Page

              Add navigation between dashboard and sprint detail views.

              Requirements:
              - Add navigation bar at top of sprint detail page
              - Include "← Back to Dashboard" link
              - Show breadcrumb: Dashboard > Sprint: <sprint-id>
              - Add sprint switcher dropdown (last 10 sprints)
              - Style navigation consistent with existing header
              - Update dashboard page with same navigation pattern

              Verification:
              - Navigate from dashboard to sprint detail
              - Click "Back to Dashboard", verify navigation
              - Use sprint switcher, verify correct sprint loads

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-13-context.md
              git commit -m "context(step-13): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 4 - Step 5: Add Navigation Header to Sprint Detail Page

              Add navigation between dashboard and sprint detail views.

              Requirements:
              - Add navigation bar at top of sprint detail page
              - Include "← Back to Dashboard" link
              - Show breadcrumb: Dashboard > Sprint: <sprint-id>
              - Add sprint switcher dropdown (last 10 sprints)
              - Style navigation consistent with existing header
              - Update dashboard page with same navigation pattern

              Verification:
              - Navigate from dashboard to sprint detail
              - Click "Back to Dashboard", verify navigation
              - Use sprint switcher, verify correct sprint loads

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-13-gherkin.md (scenarios to satisfy)
              4. context/step-13-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-13): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-13-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-13-qa-report.md

              ```markdown
              # QA Report: step-13

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-13-qa-report.md
                 git commit -m "qa(step-13): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-13.\n\n## Context\nRead: artifacts/step-13-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-13-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-13-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-13 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 4 - Step 5: Add Navigation Header to Sprint Detail Page

              Add navigation between dashboard and sprint detail views.

              Requirements:
              - Add navigation bar at top of sprint detail page
              - Include "← Back to Dashboard" link
              - Show breadcrumb: Dashboard > Sprint: <sprint-id>
              - Add sprint switcher dropdown (last 10 sprints)
              - Style navigation consistent with existing header
              - Update dashboard page with same navigation pattern

              Verification:
              - Navigate from dashboard to sprint detail
              - Click "Back to Dashboard", verify navigation
              - Use sprint switcher, verify correct sprint loads

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/dashboard-page.ts


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-13-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-13): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-14
        prompt: |
          Phase 4 - Step 6: Update sprint-watch Command for Dashboard Mode

          Add --dashboard flag to sprint-watch command to open dashboard view.

          Requirements:
          - Add `--dashboard` flag to sprint-watch.md command
          - When --dashboard, open browser to `/` instead of `/sprint/<id>`
          - Update command help text with new flag
          - Allow running dashboard mode without active sprint

          Verification:
          - Run `/sprint-watch --dashboard`, verify dashboard opens
          - Run `/sprint-watch` normally, verify sprint detail opens

          File to modify:
          - plugins/m42-sprint/commands/sprint-watch.md
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 4 - Step 6: Update sprint-watch Command for Dashboard Mode

              Add --dashboard flag to sprint-watch command to open dashboard view.

              Requirements:
              - Add `--dashboard` flag to sprint-watch.md command
              - When --dashboard, open browser to `/` instead of `/sprint/<id>`
              - Update command help text with new flag
              - Allow running dashboard mode without active sprint

              Verification:
              - Run `/sprint-watch --dashboard`, verify dashboard opens
              - Run `/sprint-watch` normally, verify sprint detail opens

              File to modify:
              - plugins/m42-sprint/commands/sprint-watch.md


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-14-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-14

              ## Step Task
              Phase 4 - Step 6: Update sprint-watch Command for Dashboard Mode

              Add --dashboard flag to sprint-watch command to open dashboard view.

              Requirements:
              - Add `--dashboard` flag to sprint-watch.md command
              - When --dashboard, open browser to `/` instead of `/sprint/<id>`
              - Update command help text with new flag
              - Allow running dashboard mode without active sprint

              Verification:
              - Run `/sprint-watch --dashboard`, verify dashboard opens
              - Run `/sprint-watch` normally, verify sprint detail opens

              File to modify:
              - plugins/m42-sprint/commands/sprint-watch.md


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-14-gherkin.md
              git commit -m "plan(step-14): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 4 - Step 6: Update sprint-watch Command for Dashboard Mode

              Add --dashboard flag to sprint-watch command to open dashboard view.

              Requirements:
              - Add `--dashboard` flag to sprint-watch.md command
              - When --dashboard, open browser to `/` instead of `/sprint/<id>`
              - Update command help text with new flag
              - Allow running dashboard mode without active sprint

              Verification:
              - Run `/sprint-watch --dashboard`, verify dashboard opens
              - Run `/sprint-watch` normally, verify sprint detail opens

              File to modify:
              - plugins/m42-sprint/commands/sprint-watch.md


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-14-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-14-context.md

              ```markdown
              # Step Context: step-14

              ## Task
              Phase 4 - Step 6: Update sprint-watch Command for Dashboard Mode

              Add --dashboard flag to sprint-watch command to open dashboard view.

              Requirements:
              - Add `--dashboard` flag to sprint-watch.md command
              - When --dashboard, open browser to `/` instead of `/sprint/<id>`
              - Update command help text with new flag
              - Allow running dashboard mode without active sprint

              Verification:
              - Run `/sprint-watch --dashboard`, verify dashboard opens
              - Run `/sprint-watch` normally, verify sprint detail opens

              File to modify:
              - plugins/m42-sprint/commands/sprint-watch.md


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-14-context.md
              git commit -m "context(step-14): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 4 - Step 6: Update sprint-watch Command for Dashboard Mode

              Add --dashboard flag to sprint-watch command to open dashboard view.

              Requirements:
              - Add `--dashboard` flag to sprint-watch.md command
              - When --dashboard, open browser to `/` instead of `/sprint/<id>`
              - Update command help text with new flag
              - Allow running dashboard mode without active sprint

              Verification:
              - Run `/sprint-watch --dashboard`, verify dashboard opens
              - Run `/sprint-watch` normally, verify sprint detail opens

              File to modify:
              - plugins/m42-sprint/commands/sprint-watch.md


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-14-gherkin.md (scenarios to satisfy)
              4. context/step-14-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-14): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-14-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-14-qa-report.md

              ```markdown
              # QA Report: step-14

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-14-qa-report.md
                 git commit -m "qa(step-14): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-14.\n\n## Context\nRead: artifacts/step-14-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-14-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-14-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-14 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 4 - Step 6: Update sprint-watch Command for Dashboard Mode

              Add --dashboard flag to sprint-watch command to open dashboard view.

              Requirements:
              - Add `--dashboard` flag to sprint-watch.md command
              - When --dashboard, open browser to `/` instead of `/sprint/<id>`
              - Update command help text with new flag
              - Allow running dashboard mode without active sprint

              Verification:
              - Run `/sprint-watch --dashboard`, verify dashboard opens
              - Run `/sprint-watch` normally, verify sprint detail opens

              File to modify:
              - plugins/m42-sprint/commands/sprint-watch.md


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-14-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-14): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-15
        prompt: |
          Phase 5 - Step 1: Enhanced Connection Status with Reconnection Info

          Show reconnection attempt count and countdown timer when disconnected.

          Requirements:
          - Track reconnection attempt number
          - Show countdown timer to next reconnection attempt
          - Display format: "Reconnecting in 5s... (attempt 3/10)"
          - Add visual indicator (pulsing dot, color change) for connection state
          - Show toast when connection is restored
          - Max 10 reconnection attempts before showing "Connection lost" with manual retry

          Verification:
          - Disconnect server, verify countdown displays
          - Verify attempt counter increments
          - Reconnect server, verify "Connected" toast shows

          File to modify:
          - plugins/m42-sprint/compiler/src/status-server/page.ts
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 5 - Step 1: Enhanced Connection Status with Reconnection Info

              Show reconnection attempt count and countdown timer when disconnected.

              Requirements:
              - Track reconnection attempt number
              - Show countdown timer to next reconnection attempt
              - Display format: "Reconnecting in 5s... (attempt 3/10)"
              - Add visual indicator (pulsing dot, color change) for connection state
              - Show toast when connection is restored
              - Max 10 reconnection attempts before showing "Connection lost" with manual retry

              Verification:
              - Disconnect server, verify countdown displays
              - Verify attempt counter increments
              - Reconnect server, verify "Connected" toast shows

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-15-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-15

              ## Step Task
              Phase 5 - Step 1: Enhanced Connection Status with Reconnection Info

              Show reconnection attempt count and countdown timer when disconnected.

              Requirements:
              - Track reconnection attempt number
              - Show countdown timer to next reconnection attempt
              - Display format: "Reconnecting in 5s... (attempt 3/10)"
              - Add visual indicator (pulsing dot, color change) for connection state
              - Show toast when connection is restored
              - Max 10 reconnection attempts before showing "Connection lost" with manual retry

              Verification:
              - Disconnect server, verify countdown displays
              - Verify attempt counter increments
              - Reconnect server, verify "Connected" toast shows

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-15-gherkin.md
              git commit -m "plan(step-15): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 5 - Step 1: Enhanced Connection Status with Reconnection Info

              Show reconnection attempt count and countdown timer when disconnected.

              Requirements:
              - Track reconnection attempt number
              - Show countdown timer to next reconnection attempt
              - Display format: "Reconnecting in 5s... (attempt 3/10)"
              - Add visual indicator (pulsing dot, color change) for connection state
              - Show toast when connection is restored
              - Max 10 reconnection attempts before showing "Connection lost" with manual retry

              Verification:
              - Disconnect server, verify countdown displays
              - Verify attempt counter increments
              - Reconnect server, verify "Connected" toast shows

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-15-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-15-context.md

              ```markdown
              # Step Context: step-15

              ## Task
              Phase 5 - Step 1: Enhanced Connection Status with Reconnection Info

              Show reconnection attempt count and countdown timer when disconnected.

              Requirements:
              - Track reconnection attempt number
              - Show countdown timer to next reconnection attempt
              - Display format: "Reconnecting in 5s... (attempt 3/10)"
              - Add visual indicator (pulsing dot, color change) for connection state
              - Show toast when connection is restored
              - Max 10 reconnection attempts before showing "Connection lost" with manual retry

              Verification:
              - Disconnect server, verify countdown displays
              - Verify attempt counter increments
              - Reconnect server, verify "Connected" toast shows

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-15-context.md
              git commit -m "context(step-15): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 5 - Step 1: Enhanced Connection Status with Reconnection Info

              Show reconnection attempt count and countdown timer when disconnected.

              Requirements:
              - Track reconnection attempt number
              - Show countdown timer to next reconnection attempt
              - Display format: "Reconnecting in 5s... (attempt 3/10)"
              - Add visual indicator (pulsing dot, color change) for connection state
              - Show toast when connection is restored
              - Max 10 reconnection attempts before showing "Connection lost" with manual retry

              Verification:
              - Disconnect server, verify countdown displays
              - Verify attempt counter increments
              - Reconnect server, verify "Connected" toast shows

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-15-gherkin.md (scenarios to satisfy)
              4. context/step-15-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-15): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-15-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-15-qa-report.md

              ```markdown
              # QA Report: step-15

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-15-qa-report.md
                 git commit -m "qa(step-15): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-15.\n\n## Context\nRead: artifacts/step-15-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-15-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-15-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-15 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 5 - Step 1: Enhanced Connection Status with Reconnection Info

              Show reconnection attempt count and countdown timer when disconnected.

              Requirements:
              - Track reconnection attempt number
              - Show countdown timer to next reconnection attempt
              - Display format: "Reconnecting in 5s... (attempt 3/10)"
              - Add visual indicator (pulsing dot, color change) for connection state
              - Show toast when connection is restored
              - Max 10 reconnection attempts before showing "Connection lost" with manual retry

              Verification:
              - Disconnect server, verify countdown displays
              - Verify attempt counter increments
              - Reconnect server, verify "Connected" toast shows

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-15-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-15): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-16
        prompt: |
          Phase 5 - Step 2: Add Mobile Responsive CSS

          Make status page usable on mobile and tablet devices.

          Requirements:
          - Add media queries for mobile (<768px) and tablet (<1024px)
          - Stack layout elements vertically on mobile
          - Reduce font sizes and padding on smaller screens
          - Make buttons touch-friendly (min 44px tap target)
          - Hide non-essential elements on mobile (e.g., keyboard shortcut hints)
          - Ensure log viewer is scrollable horizontally
          - Test activity panel collapse/expand on mobile

          Verification:
          - Open status page on mobile device or Chrome DevTools mobile view
          - Verify all content is accessible and readable
          - Verify touch interactions work correctly

          File to modify:
          - plugins/m42-sprint/compiler/src/status-server/page.ts (CSS section)
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 5 - Step 2: Add Mobile Responsive CSS

              Make status page usable on mobile and tablet devices.

              Requirements:
              - Add media queries for mobile (<768px) and tablet (<1024px)
              - Stack layout elements vertically on mobile
              - Reduce font sizes and padding on smaller screens
              - Make buttons touch-friendly (min 44px tap target)
              - Hide non-essential elements on mobile (e.g., keyboard shortcut hints)
              - Ensure log viewer is scrollable horizontally
              - Test activity panel collapse/expand on mobile

              Verification:
              - Open status page on mobile device or Chrome DevTools mobile view
              - Verify all content is accessible and readable
              - Verify touch interactions work correctly

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (CSS section)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-16-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-16

              ## Step Task
              Phase 5 - Step 2: Add Mobile Responsive CSS

              Make status page usable on mobile and tablet devices.

              Requirements:
              - Add media queries for mobile (<768px) and tablet (<1024px)
              - Stack layout elements vertically on mobile
              - Reduce font sizes and padding on smaller screens
              - Make buttons touch-friendly (min 44px tap target)
              - Hide non-essential elements on mobile (e.g., keyboard shortcut hints)
              - Ensure log viewer is scrollable horizontally
              - Test activity panel collapse/expand on mobile

              Verification:
              - Open status page on mobile device or Chrome DevTools mobile view
              - Verify all content is accessible and readable
              - Verify touch interactions work correctly

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (CSS section)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-16-gherkin.md
              git commit -m "plan(step-16): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 5 - Step 2: Add Mobile Responsive CSS

              Make status page usable on mobile and tablet devices.

              Requirements:
              - Add media queries for mobile (<768px) and tablet (<1024px)
              - Stack layout elements vertically on mobile
              - Reduce font sizes and padding on smaller screens
              - Make buttons touch-friendly (min 44px tap target)
              - Hide non-essential elements on mobile (e.g., keyboard shortcut hints)
              - Ensure log viewer is scrollable horizontally
              - Test activity panel collapse/expand on mobile

              Verification:
              - Open status page on mobile device or Chrome DevTools mobile view
              - Verify all content is accessible and readable
              - Verify touch interactions work correctly

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (CSS section)


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-16-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-16-context.md

              ```markdown
              # Step Context: step-16

              ## Task
              Phase 5 - Step 2: Add Mobile Responsive CSS

              Make status page usable on mobile and tablet devices.

              Requirements:
              - Add media queries for mobile (<768px) and tablet (<1024px)
              - Stack layout elements vertically on mobile
              - Reduce font sizes and padding on smaller screens
              - Make buttons touch-friendly (min 44px tap target)
              - Hide non-essential elements on mobile (e.g., keyboard shortcut hints)
              - Ensure log viewer is scrollable horizontally
              - Test activity panel collapse/expand on mobile

              Verification:
              - Open status page on mobile device or Chrome DevTools mobile view
              - Verify all content is accessible and readable
              - Verify touch interactions work correctly

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (CSS section)


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-16-context.md
              git commit -m "context(step-16): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 5 - Step 2: Add Mobile Responsive CSS

              Make status page usable on mobile and tablet devices.

              Requirements:
              - Add media queries for mobile (<768px) and tablet (<1024px)
              - Stack layout elements vertically on mobile
              - Reduce font sizes and padding on smaller screens
              - Make buttons touch-friendly (min 44px tap target)
              - Hide non-essential elements on mobile (e.g., keyboard shortcut hints)
              - Ensure log viewer is scrollable horizontally
              - Test activity panel collapse/expand on mobile

              Verification:
              - Open status page on mobile device or Chrome DevTools mobile view
              - Verify all content is accessible and readable
              - Verify touch interactions work correctly

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (CSS section)


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-16-gherkin.md (scenarios to satisfy)
              4. context/step-16-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-16): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-16-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-16-qa-report.md

              ```markdown
              # QA Report: step-16

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-16-qa-report.md
                 git commit -m "qa(step-16): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-16.\n\n## Context\nRead: artifacts/step-16-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-16-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-16-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-16 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 5 - Step 2: Add Mobile Responsive CSS

              Make status page usable on mobile and tablet devices.

              Requirements:
              - Add media queries for mobile (<768px) and tablet (<1024px)
              - Stack layout elements vertically on mobile
              - Reduce font sizes and padding on smaller screens
              - Make buttons touch-friendly (min 44px tap target)
              - Hide non-essential elements on mobile (e.g., keyboard shortcut hints)
              - Ensure log viewer is scrollable horizontally
              - Test activity panel collapse/expand on mobile

              Verification:
              - Open status page on mobile device or Chrome DevTools mobile view
              - Verify all content is accessible and readable
              - Verify touch interactions work correctly

              File to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts (CSS section)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-16-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-16): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-17
        prompt: |
          Phase 5 - Step 3: Add Performance Metrics Section

          Add collapsible section showing phase timing statistics.

          Requirements:
          - Add collapsible "Performance Metrics" section below sprint progress
          - Display per-phase timing:
            - Phase name, start time, end time, duration
            - Bar chart visualization of relative durations
          - Show sprint totals:
            - Total execution time
            - Average phase duration
            - Longest/shortest phase
          - Fetch data from existing timing.jsonl or /api/timing endpoint
          - Auto-refresh metrics as phases complete

          Verification:
          - Run a sprint with multiple phases
          - Expand metrics section, verify timing data displays
          - Verify bar chart shows relative durations

          Files to modify:
          - plugins/m42-sprint/compiler/src/status-server/page.ts
          - plugins/m42-sprint/compiler/src/status-server/server.ts (add /api/timing if needed)
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Phase 5 - Step 3: Add Performance Metrics Section

              Add collapsible section showing phase timing statistics.

              Requirements:
              - Add collapsible "Performance Metrics" section below sprint progress
              - Display per-phase timing:
                - Phase name, start time, end time, duration
                - Bar chart visualization of relative durations
              - Show sprint totals:
                - Total execution time
                - Average phase duration
                - Longest/shortest phase
              - Fetch data from existing timing.jsonl or /api/timing endpoint
              - Auto-refresh metrics as phases complete

              Verification:
              - Run a sprint with multiple phases
              - Expand metrics section, verify timing data displays
              - Verify bar chart shows relative durations

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts (add /api/timing if needed)


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-17-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-17

              ## Step Task
              Phase 5 - Step 3: Add Performance Metrics Section

              Add collapsible section showing phase timing statistics.

              Requirements:
              - Add collapsible "Performance Metrics" section below sprint progress
              - Display per-phase timing:
                - Phase name, start time, end time, duration
                - Bar chart visualization of relative durations
              - Show sprint totals:
                - Total execution time
                - Average phase duration
                - Longest/shortest phase
              - Fetch data from existing timing.jsonl or /api/timing endpoint
              - Auto-refresh metrics as phases complete

              Verification:
              - Run a sprint with multiple phases
              - Expand metrics section, verify timing data displays
              - Verify bar chart shows relative durations

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts (add /api/timing if needed)


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-17-gherkin.md
              git commit -m "plan(step-17): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Phase 5 - Step 3: Add Performance Metrics Section

              Add collapsible section showing phase timing statistics.

              Requirements:
              - Add collapsible "Performance Metrics" section below sprint progress
              - Display per-phase timing:
                - Phase name, start time, end time, duration
                - Bar chart visualization of relative durations
              - Show sprint totals:
                - Total execution time
                - Average phase duration
                - Longest/shortest phase
              - Fetch data from existing timing.jsonl or /api/timing endpoint
              - Auto-refresh metrics as phases complete

              Verification:
              - Run a sprint with multiple phases
              - Expand metrics section, verify timing data displays
              - Verify bar chart shows relative durations

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts (add /api/timing if needed)


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-17-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-17-context.md

              ```markdown
              # Step Context: step-17

              ## Task
              Phase 5 - Step 3: Add Performance Metrics Section

              Add collapsible section showing phase timing statistics.

              Requirements:
              - Add collapsible "Performance Metrics" section below sprint progress
              - Display per-phase timing:
                - Phase name, start time, end time, duration
                - Bar chart visualization of relative durations
              - Show sprint totals:
                - Total execution time
                - Average phase duration
                - Longest/shortest phase
              - Fetch data from existing timing.jsonl or /api/timing endpoint
              - Auto-refresh metrics as phases complete

              Verification:
              - Run a sprint with multiple phases
              - Expand metrics section, verify timing data displays
              - Verify bar chart shows relative durations

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts (add /api/timing if needed)


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-17-context.md
              git commit -m "context(step-17): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Phase 5 - Step 3: Add Performance Metrics Section

              Add collapsible section showing phase timing statistics.

              Requirements:
              - Add collapsible "Performance Metrics" section below sprint progress
              - Display per-phase timing:
                - Phase name, start time, end time, duration
                - Bar chart visualization of relative durations
              - Show sprint totals:
                - Total execution time
                - Average phase duration
                - Longest/shortest phase
              - Fetch data from existing timing.jsonl or /api/timing endpoint
              - Auto-refresh metrics as phases complete

              Verification:
              - Run a sprint with multiple phases
              - Expand metrics section, verify timing data displays
              - Verify bar chart shows relative durations

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts (add /api/timing if needed)


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-17-gherkin.md (scenarios to satisfy)
              4. context/step-17-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-17): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-17-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-17-qa-report.md

              ```markdown
              # QA Report: step-17

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-17-qa-report.md
                 git commit -m "qa(step-17): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-17.\n\n## Context\nRead: artifacts/step-17-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-17-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-17-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-17 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Phase 5 - Step 3: Add Performance Metrics Section

              Add collapsible section showing phase timing statistics.

              Requirements:
              - Add collapsible "Performance Metrics" section below sprint progress
              - Display per-phase timing:
                - Phase name, start time, end time, duration
                - Bar chart visualization of relative durations
              - Show sprint totals:
                - Total execution time
                - Average phase duration
                - Longest/shortest phase
              - Fetch data from existing timing.jsonl or /api/timing endpoint
              - Auto-refresh metrics as phases complete

              Verification:
              - Run a sprint with multiple phases
              - Expand metrics section, verify timing data displays
              - Verify bar chart shows relative durations

              Files to modify:
              - plugins/m42-sprint/compiler/src/status-server/page.ts
              - plugins/m42-sprint/compiler/src/status-server/server.ts (add /api/timing if needed)


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-17-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-17): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
      - id: step-18
        prompt: |
          Final Step: Build Verification and Cleanup

          Verify all changes compile and pass quality checks.

          Requirements:
          - Run TypeScript compilation: `npm run build` in compiler directory
          - Run type checking: `npm run typecheck` in compiler directory
          - Fix any compilation errors
          - Fix any type errors
          - Ensure no unused imports or variables
          - Verify no console.log statements left in production code (except intentional logging)

          Verification:
          - `npm run build` exits with code 0
          - `npm run typecheck` exits with code 0
          - No warnings in build output

          Directory:
          - plugins/m42-sprint/compiler/
        status: pending
        phases:
          - id: plan
            status: pending
            prompt: |
              Generate binary-verifiable gherkin scenarios for this step.

              ## Your Task
              Final Step: Build Verification and Cleanup

              Verify all changes compile and pass quality checks.

              Requirements:
              - Run TypeScript compilation: `npm run build` in compiler directory
              - Run type checking: `npm run typecheck` in compiler directory
              - Fix any compilation errors
              - Fix any type errors
              - Ensure no unused imports or variables
              - Verify no console.log statements left in production code (except intentional logging)

              Verification:
              - `npm run build` exits with code 0
              - `npm run typecheck` exits with code 0
              - No warnings in build output

              Directory:
              - plugins/m42-sprint/compiler/


              ## Shared Context
              Read: context/_shared-context.md (project patterns, conventions, commands)
              Read: context/sprint-plan.md (how this step fits in the sprint)

              ## Instructions
              Create 4-8 gherkin scenarios that, when ALL pass, prove the step is complete.
              Each scenario MUST have:
              1. Clear Given/When/Then structure
              2. An explicit verification command that returns exit code 0 on success
              3. Binary outcome: exactly 1 (pass) or 0 (fail)

              ## Gherkin Format
              Each scenario follows this exact structure:

              ```gherkin
              Scenario: [Descriptive name]
                Given [precondition or context]
                When [action taken]
                Then [expected outcome]

              Verification: `[shell command that exits 0 on success, non-zero on failure]`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ## Example Scenarios

              ### File Existence
              ```gherkin
              Scenario: Source file exists
                Given the project structure is set up
                When I check for the module file
                Then src/auth/service.ts exists

              Verification: `test -f src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### TypeScript Compilation
              ```gherkin
              Scenario: TypeScript compiles without errors
                Given the file src/auth/service.ts exists
                When I run the TypeScript compiler
                Then no compilation errors occur

              Verification: `npx tsc --noEmit src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Function Export
              ```gherkin
              Scenario: Login function is exported
                Given src/auth/service.ts exists
                When I check for the login export
                Then the function is publicly available

              Verification: `grep -q "export.*function login\|export.*const login\|export { login" src/auth/service.ts`
              Pass: Exit code = 0 → Score 1
              Fail: Exit code ≠ 0 → Score 0
              ```

              ### Test Execution
              ```gherkin
              Scenario: Unit tests pass
                Given tests exist in src/auth/service.test.ts
                When I run the test suite
                Then all tests pass

              Verification: `npm test -- --testPathPattern="auth/service" --passWithNoTests 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ### Lint Check
              ```gherkin
              Scenario: Code passes linting
                Given the implementation is complete
                When I run the linter
                Then no lint errors in new files

              Verification: `npm run lint -- src/auth/service.ts 2>&1; echo $?`
              Pass: Last line = 0 → Score 1
              Fail: Last line ≠ 0 → Score 0
              ```

              ## Output
              Create: artifacts/step-18-gherkin.md

              ```markdown
              # Gherkin Scenarios: step-18

              ## Step Task
              Final Step: Build Verification and Cleanup

              Verify all changes compile and pass quality checks.

              Requirements:
              - Run TypeScript compilation: `npm run build` in compiler directory
              - Run type checking: `npm run typecheck` in compiler directory
              - Fix any compilation errors
              - Fix any type errors
              - Ensure no unused imports or variables
              - Verify no console.log statements left in production code (except intentional logging)

              Verification:
              - `npm run build` exits with code 0
              - `npm run typecheck` exits with code 0
              - No warnings in build output

              Directory:
              - plugins/m42-sprint/compiler/


              ## Success Criteria
              All scenarios must pass (score = 1) for the step to be complete.
              Total scenarios: [N]
              Required score: [N]/[N]

              ---

              ## Scenario 1: [Name]
              [Full gherkin with verification as shown above]

              ---

              ## Scenario 2: [Name]
              ...

              [Continue for 4-8 scenarios]
              ```

              ## Commit
              ```bash
              git add artifacts/step-18-gherkin.md
              git commit -m "plan(step-18): define gherkin scenarios"
              ```
          - id: context
            status: pending
            prompt: |
              Gather step-specific context for implementation.

              ## Your Task
              Final Step: Build Verification and Cleanup

              Verify all changes compile and pass quality checks.

              Requirements:
              - Run TypeScript compilation: `npm run build` in compiler directory
              - Run type checking: `npm run typecheck` in compiler directory
              - Fix any compilation errors
              - Fix any type errors
              - Ensure no unused imports or variables
              - Verify no console.log statements left in production code (except intentional logging)

              Verification:
              - `npm run build` exits with code 0
              - `npm run typecheck` exits with code 0
              - No warnings in build output

              Directory:
              - plugins/m42-sprint/compiler/


              ## Shared Context
              Read: context/_shared-context.md (already has project-wide patterns)
              Read: artifacts/step-18-gherkin.md (scenarios to implement)

              ## Instructions
              Research the specific code areas this step will touch:

              1. **Related Existing Code**
                 - Find similar implementations to follow as patterns
                 - Identify modules this step will import from
                 - Note any interfaces/types to implement or extend

              2. **Dependencies**
                 - List imports needed from internal modules
                 - List any new external packages needed
                 - Check for peer dependencies or version constraints

              3. **Integration Points**
                 - How will this code be called/used?
                 - What modules will import from this step's output?
                 - Are there existing tests to extend?

              4. **Specific Patterns**
                 - Error handling patterns used in similar code
                 - Naming conventions for this area
                 - File organization patterns

              ## Output
              Create: context/step-18-context.md

              ```markdown
              # Step Context: step-18

              ## Task
              Final Step: Build Verification and Cleanup

              Verify all changes compile and pass quality checks.

              Requirements:
              - Run TypeScript compilation: `npm run build` in compiler directory
              - Run type checking: `npm run typecheck` in compiler directory
              - Fix any compilation errors
              - Fix any type errors
              - Ensure no unused imports or variables
              - Verify no console.log statements left in production code (except intentional logging)

              Verification:
              - `npm run build` exits with code 0
              - `npm run typecheck` exits with code 0
              - No warnings in build output

              Directory:
              - plugins/m42-sprint/compiler/


              ## Related Code Patterns

              ### Similar Implementation: [path]
              ```typescript
              // Key pattern to follow
              [relevant code snippet]
              ```

              ### Similar Implementation: [path]
              [continue as needed]

              ## Required Imports
              ### Internal
              - `[module]`: [what to import]

              ### External
              - `[package]`: [what to import]

              ## Types/Interfaces to Use
              ```typescript
              // From [source]
              interface [Name] {
                [relevant fields]
              }
              ```

              ## Integration Points
              - Called by: [who will use this]
              - Calls: [what this will call]
              - Tests: [related test files]

              ## Implementation Notes
              - [Specific note 1]
              - [Specific note 2]
              ```

              ## Commit
              ```bash
              git add context/step-18-context.md
              git commit -m "context(step-18): gather implementation context"
              ```
          - id: execute
            status: pending
            prompt: |
              Implement the step following gherkin scenarios and context.

              ## Your Task
              Final Step: Build Verification and Cleanup

              Verify all changes compile and pass quality checks.

              Requirements:
              - Run TypeScript compilation: `npm run build` in compiler directory
              - Run type checking: `npm run typecheck` in compiler directory
              - Fix any compilation errors
              - Fix any type errors
              - Ensure no unused imports or variables
              - Verify no console.log statements left in production code (except intentional logging)

              Verification:
              - `npm run build` exits with code 0
              - `npm run typecheck` exits with code 0
              - No warnings in build output

              Directory:
              - plugins/m42-sprint/compiler/


              ## MUST READ BEFORE IMPLEMENTING
              Read these files in order:
              1. context/_shared-context.md (project patterns, conventions)
              2. context/sprint-plan.md (how this fits in sprint)
              3. artifacts/step-18-gherkin.md (scenarios to satisfy)
              4. context/step-18-context.md (specific patterns, imports)

              ## Implementation Rules

              ### Follow the Gherkin
              Your implementation MUST satisfy ALL gherkin scenarios.
              Each scenario has a verification command - mentally run it to check your work.

              ### Follow the Context
              - Use patterns from similar implementations
              - Import from specified modules
              - Implement required interfaces
              - Follow naming conventions

              ### Code Quality
              - Keep code simple and focused
              - Follow existing patterns exactly
              - No over-engineering or extra abstractions
              - Only implement what's needed for the scenarios

              ### Commits
              Make atomic commits for logical units:
              ```bash
              # After each logical piece
              git add [files]
              git commit -m "[type](step-18): [description]"
              ```

              Types: feat, fix, refactor, test, docs

              ## Implementation Checklist
              Before marking complete, verify:
              - [ ] All files from gherkin scenarios exist
              - [ ] Code follows patterns from context
              - [ ] Imports are correct
              - [ ] No TypeScript errors (run typecheck mentally)
              - [ ] Each scenario's verification should pass

              ## If Blocked
              If you encounter an issue that prevents completion:
              - Document the blocker clearly
              - Set status to needs-human
              - Do NOT leave partial/broken implementation
          - id: qa
            status: pending
            prompt: |
              Verify implementation against gherkin scenarios.

              ## Context
              Read: artifacts/step-18-gherkin.md (scenarios with verification commands)

              ## Step 1: Run Each Verification

              For EACH scenario in the gherkin file:
              1. Run the verification command
              2. Record the result: 1 (pass) or 0 (fail)
              3. If fail, capture the error output

              ## Step 2: Calculate Score

              Score = (passed scenarios) / (total scenarios)
              - Score = 1.0 (all pass) → PASS
              - Score < 1.0 (any fail) → FAIL

              ## Step 3: Generate QA Report

              Create: artifacts/step-18-qa-report.md

              ```markdown
              # QA Report: step-18

              ## Summary
              - Total Scenarios: [N]
              - Passed: [N]
              - Failed: [N]
              - Score: [X]/[N] = [percentage]%

              ## Verification Results

              | # | Scenario | Result | Details |
              |---|----------|--------|---------|
              | 1 | [Name] | PASS/FAIL | [output or error] |
              | 2 | [Name] | PASS/FAIL | [output or error] |
              ...

              ## Detailed Results

              ### Scenario 1: [Name]
              **Verification**: `[command]`
              **Exit Code**: [0 or N]
              **Output**:
              ```
              [actual output]
              ```
              **Result**: PASS / FAIL

              ### Scenario 2: [Name]
              ...

              ## Issues Found
              [If any failures, describe each issue]

              1. **[Scenario name]**: [What failed and why]

              ## Status: PASS / FAIL
              ```

              ## Step 4: Handle Outcome

              ### If ALL scenarios PASS (Score = 100%):
              1. Ensure report shows "Status: PASS"
              2. Commit the report:
                 ```bash
                 git add artifacts/step-18-qa-report.md
                 git commit -m "qa(step-18): all scenarios passed"
                 ```
              3. Mark phase as completed

              ### If ANY scenario FAILS (Score < 100%):
              You MUST inject fix phases. Do NOT just report and continue.

              1. Ensure report shows "Status: FAIL" with specific issues

              2. Find the PROGRESS.yaml file:
                 ```bash
                 PROGRESS_FILE=$(find .claude/sprints -name "PROGRESS.yaml" -type f 2>/dev/null | head -1)
                 echo "Found: $PROGRESS_FILE"
                 ```

              3. Inject fix and re-verify phases using yq:
                 ```bash
                 yq -i '
                   (.phases[] | select(.steps) | .steps[] | select(.status == "in-progress") | .phases) +=
                   [
                     {
                       "id": "fix",
                       "status": "pending",
                       "prompt": "Fix failing scenarios for step-18.\n\n## Context\nRead: artifacts/step-18-qa-report.md\n\n## Instructions\n1. Review each FAIL scenario\n2. Fix the implementation to make it pass\n3. Re-run the verification command to confirm\n4. Make atomic commits for each fix\n\n## After Fixing\nDo NOT mark as complete until ALL verifications pass."
                     },
                     {
                       "id": "reverify",
                       "status": "pending",
                       "prompt": "Re-verify all scenarios after fixes.\n\n## Instructions\nRe-run ALL verification commands from artifacts/step-18-gherkin.md\n\n## If ALL pass:\n- Update artifacts/step-18-qa-report.md with PASS status\n- Commit the updated report\n\n## If ANY still fail:\n- Update the QA report with new results\n- Inject another fix phase using yq\n- Loop continues until all pass"
                     }
                   ]
                 ' "$PROGRESS_FILE"
                 ```

              4. Mark current QA phase as failed:
                 ```bash
                 yq -i '
                   (.. | select(.id == "qa" and .status == "in-progress")) |=
                   (.status = "failed" | .error = "step-18 QA failed - see report - fix phase injected")
                 ' "$PROGRESS_FILE"
                 ```

              5. The sprint loop will now execute fix → reverify phases

              ## Important
              - EVERY scenario must pass for the step to be complete
              - Failed QA MUST inject fix phases, not just report
              - This creates a self-healing loop until all pass
          - id: verify
            status: pending
            prompt: |
              Final integration verification for the step.

              ## Your Task
              Final Step: Build Verification and Cleanup

              Verify all changes compile and pass quality checks.

              Requirements:
              - Run TypeScript compilation: `npm run build` in compiler directory
              - Run type checking: `npm run typecheck` in compiler directory
              - Fix any compilation errors
              - Fix any type errors
              - Ensure no unused imports or variables
              - Verify no console.log statements left in production code (except intentional logging)

              Verification:
              - `npm run build` exits with code 0
              - `npm run typecheck` exits with code 0
              - No warnings in build output

              Directory:
              - plugins/m42-sprint/compiler/


              ## Context
              Read: context/_shared-context.md (build commands)
              Read: artifacts/step-18-qa-report.md (should show PASS)

              ## Step 1: Build Verification
              Run the project build to ensure this step integrates:
              ```bash
              # Use commands from _shared-context.md, typically:
              npm run build
              npm run typecheck
              ```

              ## Step 2: Integration Check
              Verify this step works with the rest of the sprint:
              - Check imports resolve correctly
              - Verify no circular dependencies
              - Ensure types are compatible

              ## Step 3: Smoke Test
              If possible, manually verify the functionality:
              - Run the code path that uses this step's output
              - Check expected behavior matches gherkin scenarios

              ## Step 4: Final Commit
              If all verification passes:
              ```bash
              git add -A
              git status  # Check for any uncommitted changes
              # Only commit if there are changes
              git diff --cached --quiet || git commit -m "verify(step-18): integration verified"
              ```

              ## Outcome
              - If integration passes: Mark step as complete
              - If integration fails: Document the issue and set status to needs-human

              ## Important
              This is the final gate before moving to the next step.
              The step's gherkin scenarios already passed in QA.
              This phase ensures the step works in the broader context.
    started-at: "2026-01-17T00:38:43Z"
  - id: final-qa
    status: pending
    prompt: |
      Comprehensive Quality Assurance for the entire sprint.

      ## Context
      Read: context/_shared-context.md for build/test commands
      Read: context/sprint-plan.md for success criteria

      ## Step 1: Full Build Verification
      Run ALL build checks:
      ```bash
      # Identify commands from _shared-context.md, typically:
      npm run build
      npm run typecheck
      npm run lint
      ```

      Record each result in the QA report.

      ## Step 2: Complete Test Suite
      Run the full test suite:
      ```bash
      npm test
      ```

      Record test results and any failures.

      ## Step 3: Integration Verification
      Verify all steps work together:
      - Check that modules properly import each other
      - Verify no circular dependencies introduced
      - Test end-to-end flow if applicable

      ## Step 4: Regression Check
      Compare against main branch:
      ```bash
      git diff main...HEAD --stat
      ```

      Verify:
      - No unintended changes to existing functionality
      - All modified files are expected per sprint-plan.md
      - No temporary/debug code left in

      ## Step 5: Review All Step QA Reports
      Read all artifacts/step-*-qa-report.md files
      - Verify all steps show PASS status
      - Consolidate any warnings or notes

      ## Step 6: Generate Sprint QA Report
      Create: artifacts/sprint-qa-report.md

      ```markdown
      # Sprint QA Report: 2026-01-17_plugin-enhancements

      ## Build Verification
      | Check | Result | Output |
      |-------|--------|--------|
      | Build | PASS/FAIL | [summary] |
      | TypeCheck | PASS/FAIL | [summary] |
      | Lint | PASS/FAIL | [summary] |

      ## Test Suite
      | Metric | Value |
      |--------|-------|
      | Tests Run | [count] |
      | Passed | [count] |
      | Failed | [count] |
      | Skipped | [count] |

      ## Integration Verification
      - [ ] Modules import correctly
      - [ ] No circular dependencies
      - [ ] End-to-end flow works

      ## Step QA Summary
      | Step | Status | Notes |
      |------|--------|-------|
      | step-0 | PASS | [brief note] |
      | step-1 | PASS | [brief note] |
      ...

      ## Regression Analysis
      [Summary of changes vs main branch]

      ## Issues Found
      [List any issues, or "None"]

      ## Overall Status: PASS / FAIL
      ```

      ## Step 7: Handle Outcome

      ### If PASS:
      - Commit the QA report:
        ```bash
        git add artifacts/sprint-qa-report.md
        git commit -m "qa: sprint-level verification passed"
        ```

      ### If FAIL:
      - Document specific failures in the report
      - Set status to needs-human with details of what failed
      - The sprint cannot proceed to summary/PR until issues are resolved
  - id: summary
    status: pending
    prompt: |
      Generate sprint summary deliverable for user review.

      ## Context
      Read: context/sprint-plan.md for original goals
      Read: artifacts/sprint-qa-report.md for verification results
      Read: All artifacts/step-*-qa-report.md for step details

      ## Step 1: Collect Commit History
      ```bash
      git log main..HEAD --oneline --no-decorate
      ```

      ## Step 2: Collect File Changes
      ```bash
      git diff main..HEAD --stat
      ```

      ## Step 3: Generate Sprint Summary
      Create: artifacts/sprint-summary.md

      ```markdown
      # Sprint Summary: 2026-01-17_plugin-enhancements

      ## What Was Accomplished

      ### Step 0: [Step title]
      - [Key accomplishment 1]
      - [Key accomplishment 2]
      **Files**: [list of files created/modified]

      ### Step 1: [Step title]
      ...

      ## Files Changed
      | File | Change Type | Description |
      |------|-------------|-------------|
      | [path] | Created/Modified/Deleted | [brief description] |

      ## Commits Made
      | Hash | Message |
      |------|---------|
      | [short hash] | [commit message] |

      ## Test Coverage
      [Summary from QA report]

      ## Verification Status
      - Build: PASS
      - TypeCheck: PASS
      - Lint: PASS
      - Tests: [X/Y passed]
      - Integration: PASS

      ## Known Issues / Follow-ups
      [List any, or "None identified"]

      ## Sprint Statistics
      - Steps completed: [X/Y]
      - Total commits: [count]
      - Files changed: [count]
      - Lines added: [count]
      - Lines removed: [count]
      ```

      ## Step 4: Commit Summary
      ```bash
      git add artifacts/sprint-summary.md
      git commit -m "docs: add sprint summary"
      ```
  - id: pr-create
    status: pending
    prompt: "Push the sprint branch and create a pull request.\n\n## Context\nRead: artifacts/sprint-summary.md for PR body content\nRead: artifacts/sprint-qa-report.md for verification checklist\n\n## Step 1: Ensure All Changes Committed\n```bash\ngit status\n```\nIf there are uncommitted changes, commit them appropriately.\n\n## Step 2: Push Branch\n```bash\ngit push -u origin sprint/2026-01-17_plugin-enhancements\n```\n\n## Step 3: Create Pull Request\nUse the sprint summary to create a well-structured PR:\n\n```bash\ngh pr create \\\n  --title \"Sprint: 2026-01-17_plugin-enhancements\" \\\n  --body \"$(cat <<'EOF'\n## Summary\n[Extract key points from sprint-summary.md]\n\n## Changes\n[List of major changes from summary]\n\n## Verification Checklist\n- [x] Build passes\n- [x] TypeCheck passes\n- [x] Lint passes\n- [x] Tests pass\n- [x] Integration verified\n- [x] No regressions\n\n## Test Results\n[Extract from sprint-qa-report.md]\n\n## Files Changed\n[File list from summary]\n\n---\nFull details in `artifacts/sprint-summary.md`\n\n\U0001F916 Generated with Sprint Workflow\nEOF\n)\"\n```\n\n## Step 4: Output PR URL\nCapture and display the PR URL:\n```bash\ngh pr view --json url -q '.url'\n```\n\n## Output\n- Branch pushed to remote\n- Pull request created\n- PR URL displayed for user\n"
current:
  phase: 1
  step: 11
  sub-phase: 4
stats:
  started-at: "2026-01-17T00:35:52Z"
  total-phases: 100
  completed-phases: 0
  total-steps: 19
  completed-steps: 0
  max-iterations: 30
  current-iteration: 18
